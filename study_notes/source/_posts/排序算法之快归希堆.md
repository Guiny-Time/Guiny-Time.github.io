---
title: 排序算法之快归希堆
tags: ['算法与数据结构','算法','计算机科学技术','面试相关']
categories: 算法与数据结构
date: '2024-03-09 15:39:41'
copyright_author: 时光
cover: geometry_glacier_httpss.mj.runklX034FNpZk_male_character_profil_88fa1b11-63d6-4e9b-aa12-a33a3ead5c87.png
katex: true
hidden: true
---

在不同领域，排序算法的实现各有千秋。总体来看，排序算法大致可分为十类：

- {% label warning @选泡插 %}：选择排序/Selection Sort、冒泡排序/Bubble Sort、插入排序/Insertion Sort
- {% label success @快归希堆 %}：快速排序/Quick Sort、归并排序/Merge Sort、希尔排序/Shell Sort、堆排序/Heap Sort
- {% label info @桶计基 %}：桶排序/Bucket sort、计数排序/Counting Sort、基数排序/Radix Sort

本文将介绍第二类排序算法，它们的时间复杂度均为O(nlogn)级别。

<!-- more -->

# 时间复杂度为O(n logn)的排序算法
## 希尔排序/Shell Sort
- Unstable/In-place
- 平均时间复杂度：O(n) ~ O(n^2)之间
- 最优时间复杂度：O(n^1.3)
- 最差时间复杂度：O(n^2)，完全没排序的情况
- 空间复杂度：O(1)

<img src="https://pic.leetcode-cn.com/1643081683-ORhiPp-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.gif" width=500 title="图解希尔排序" />

希尔排序由美国辛辛那提大学的数学系博士 Donald Shell 与1959年提出，本质上是对**插入排序**的一种优化，它利用了插入排序的简单，又克服了插入排序每次只交换相邻两个元素的缺点。它的基本思想是：

1. 将待排序数组按照一定的间隔分为多个子数组，每组分别进行插入排序。这里按照间隔分组指的不是取连续的一段数组，而是每跳跃一定间隔取一个值组成一组；
2. 逐渐缩小间隔进行下一轮排序；
3. 最后一轮时，取间隔为*1*，也就相当于直接使用插入排序。但这时经过前面的「宏观调控」，数组已经基本有序了，所以此时的插入排序只需进行少量交换便可完成。

其中，每一遍排序的间隔在希尔排序中被称之为**增量**，所有的增量组成的序列称之为**增量序列**，比如上面的“图解希尔排序”中的增量序列为 [5, 2, 1]（第一次以 *5* 为间隔划分，第二次 *2* ，第三次 *1* ）。
增量依次递减，最后一个增量必须为 *1* ，所以希尔排序又被称之为「**缩小增量排序**」。

{% tabs 希尔排序的写法 %}
<!-- tab 一般来说的写法 -->
按照前文的思路，使用希尔增量序列进行分组，再对每组进行插入排序：
```Java
public static void shellSort(int[] arr) {
    // 间隔序列，在希尔排序中我们称之为增量序列
    for (int gap = arr.length / 2; gap > 0; gap /= 2) {
        // 分组
        for (int groupStartIndex = 0; groupStartIndex < gap; groupStartIndex++) {
            // 插入排序
            for (int currentIndex = groupStartIndex + gap; currentIndex < arr.length; currentIndex += gap) {
                // currentNumber 站起来，开始找位置
                int currentNumber = arr[currentIndex];
                int preIndex = currentIndex - gap;
                while (preIndex >= groupStartIndex && currentNumber < arr[preIndex]) {
                    // 向后挪位置
                    arr[preIndex + gap] = arr[preIndex];
                    preIndex -= gap;
                }
                // currentNumber 找到了自己的位置，坐下
                arr[preIndex + gap] = currentNumber;
            }
        }
    }
}
```
<!-- endtab -->

<!-- tab 优化的写法 -->
我们现在的处理方式是：处理完一组间隔序列后，再回来处理下一组间隔序列，这非常符合人类思维。但对于计算机来说，它更喜欢从第 gap 个元素开始，按照顺序将每个元素依次向前插入自己所在的组这种方式。虽然这个过程看起来是在不同的间隔序列中不断跳跃，但站在计算机的角度，它是在访问一段连续数组。
```Java
public static void shellSort(int[] arr) {
    // 间隔序列，在希尔排序中我们称之为增量序列
    for (int gap = arr.length / 2; gap > 0; gap /= 2) {
        // 从 gap 开始，按照顺序将每个元素依次向前插入自己所在的组
        for (int i = gap; i < arr.length; i++) {
            // currentNumber 站起来，开始找位置
            int currentNumber = arr[i];
            // 该组前一个数字的索引
            int preIndex = i - gap;
            while (preIndex >= 0 && currentNumber < arr[preIndex]) {
                // 向后挪位置
                arr[preIndex + gap] = arr[preIndex];
                preIndex -= gap;
            }
            // currentNumber 找到了自己的位置，坐下
            arr[preIndex + gap] = currentNumber;
        }
    }
}
```
<!-- endtab -->

<!-- tab Knuth法 -->
使用Knuth增量序列进行排序：
```Java
public static void shellSortByKnuth(int[] arr) {
    // 找到当前数组需要用到的 Knuth 序列中的最大值
    int maxKnuthNumber = 1;
    while (maxKnuthNumber <= arr.length / 3) {
        maxKnuthNumber = maxKnuthNumber * 3 + 1;
    }
    // 增量按照 Knuth 序列规则依次递减
    for (int gap = maxKnuthNumber; gap > 0; gap = (gap - 1) / 3) {
        // 从 gap 开始，按照顺序将每个元素依次向前插入自己所在的组
        for (int i = gap; i < arr.length; i++) {
            // currentNumber 站起来，开始找位置
            int currentNumber = arr[i];
            // 该组前一个数字的索引
            int preIndex = i - gap;
            while (preIndex >= 0 && currentNumber < arr[preIndex]) {
                // 向后挪位置
                arr[preIndex + gap] = arr[preIndex];
                preIndex -= gap;
            }
            // currentNumber 找到了自己的位置，坐下
            arr[preIndex + gap] = currentNumber;
        }
    }
}
```
<!-- endtab -->
{% endtabs %}

### 增量序列的选择
让我们从数学的角度定义一下增量序列：
$$D_m > D_{m-1} > D_{m-2} > ... > D_1$$
其中，增量序列的第 $k$ 项可以记作 $D_k$。希尔排序所做的就是对增量序列的每一项进行 「 $D_k$ 间隔排序」。
其中有一条重要的性质：「**$D_{k+1}$ 间隔**」的有序数组，在经过「 **$D_k$ 间隔**」的排序之后仍然是「 **$D_{k+1}$ 间隔**」有序的，这保证了希尔排序的效率，不会出现越排越乱的情况。
Donald Shell本人在论文中所选择的增量序列是这样的：
$$D_m = N/2, D_k = D_{k+1}/2$$
其中，$D_m$ 代表增量序列的首项，$N$ 是待排序的数组长度，$D_k$ 指代第 $k$ 项。这样以二分为基础的增量序列被称为**希尔增量序列**。
增量序列的选择会**极大**地影响希尔排序的效率，增量序列如果选得不好，希尔排序的效率可能比插入排序效率还要低，比如：

![选择不当的增量序列](https://pic.leetcode-cn.com/1643081713-FJKEAx-image.png)

> **不互质**：一组数的 *最大公约数* 不为 1 ，例如上图中的[8,4,2]，其最大公约数为 **2** 。

优化希尔算法的核心就在于如何优化增量序列。从“增量元素不互质，则小增量可能根本不起作用”这个发现出发，几位学者分别提出了以下改进想法：
1. **Hibbard**：既然要求互质，那增量序列就都是奇数吧，$D_k = 2^k - 1$。数学界猜想：
    - 最坏的时间复杂度为 $O(n^{3/2})$
    - 平均时间复杂度为 $O(n^{5/4})$。
2. **Knuth**：$D_1 = 1, D_{k+1} = 3 * D_k + 1$。该序列保证了各数互质，并且间隔比**Hibbard序列**更大（迭代次数更少）。数学界猜想：
    - 平均时间复杂度为 $O(n^{3/2})$ 
3. **Sedgewick**：$D_1 = 1, D_{k+1} = 9 * 4^k - 9 * 2^k + 1$ 或 $D_1 = 1, D_{k+1} = 4^k - 3 * 2^k + 1$。这个序列的间隔比 **Knuth序列**还大，适合待排序数据量较大的情况。数学界猜想：
    - 最坏的时间复杂度为 $O(n^{4/3})$
    - 平均时间复杂度为 $O(n^{7/6})$。

### 为什么说希尔排序突破了O(n^2)级算法？
排序算法本质上就是一个消除**逆序对**的过程。

对于随机数组，逆序对的数量是 O(N^2^) 级的，如果采用「交换相邻元素」的办法来消除逆序对，每次最多只能消除一组逆序对，因此必须执行 O(N^2^) 级的交换次数，这就是为什么冒泡、插入、选择算法只能到 O(N^2^) 级的原因。反过来说，基于交换元素的排序算法要想突破 O(N^2^) 级，必须通过一些比较，交换间隔比较远的元素，使得一次交换能消除一个以上的逆序对。

希尔排序算法就是通过这种方式，打破了在空间复杂度为 O(1) 的情况下，时间复杂度为 O(N^2^) 的魔咒，此后的快排、堆排等等算法也都是基于这样的思路实现的。

## 堆排序/Heap Sort
- Unstable/In-place
- 时间复杂度：初始化建堆O(n)({% label info @插入法 %}建堆O(nlogn))，重建堆O(logn)，执行n-1次
- 空间复杂度：O(1)
- 平均比较次数：2nlogn

{% video Heapsort.mp4 %}

堆（Heap）分为**大顶堆**和**小顶堆**，是一种特殊的完全二叉树，满足：
- 根节点的值 ≥ 子节点的值，这样的堆被称之为最大堆，或大顶堆；
- 根节点的值 ≤ 子节点的值，这样的堆被称之为最小堆，或小顶堆。

> **完全二叉树**
如果二叉树除了最后一层有缺失外，其它是满的，且最后一层缺失的叶子结点只出现在**右侧**，则这样的二叉树叫完全二叉树。

> **几种节点类型**
>- **根节点**：最顶端的节点
>- **叶子节点**：没有子节点的节点

利用堆的思想，W. J. Williams 在 1964 年提出了堆排序的方法：
1. **Build max heap**：用数列构建出一个大顶堆，取出堆顶的数字（最大的数）；
2. **Heapify**：调整剩余的数字，构建出新的大顶堆，再次取出堆顶的数字（调整后最大的数）；
3. 循环往复，完成整个排序。

问题来了，如何用数列构建出一个大顶堆呢？取出堆顶的数字后，如何将剩余的数字调整成新的大顶堆呢？

### 构建大顶堆
完全二叉树有一些有趣的性质：
1. 对于完全二叉树中的第 i 个数，它的左子节点下标：left = 2i + 1
2. 对于完全二叉树中的第 i 个数，它的右子节点下标：right = left + 1
3. 对于有 n 个元素的完全二叉树(n≥2)，它的最后一个非叶子结点的下标：n/2 - 1

通过这些性质，我们并不需要真的通过构建Node类的方式“建造”一棵二叉树，只需要通过数组各个元素的编号抽象出堆的结构（但本质上还是一个数组）进行操作即可。也正因为如此，堆排序可以是In-place类型的排序算法。

<img src="https://img14.360buyimg.com/ddimg/jfs/t1/93573/18/44451/29089/65eeac39F59127978/07fa2b29853f0a72.jpg" width=300 alt="手绘示意图" title="手绘示意图" />

理论已经完备，现在开始准备构建初始大顶堆吧！我们从最后一个**非叶子节点**(在示意图中指第【6/2-1】，也就是第 2 个节点“3”)开始调整大顶堆，比较节点与根节点之间数值的大小并交换。有关调整的部分，就是**Heapify**。
```Java
// 构建初始大顶堆
private static void buildMaxHeap(int[] arr) {
    // 最后一个非叶子节点的下标是 arr.length / 2-1
    for (int i = arr.length / 2 - 1; i >= 0; i--) {
        maxHeapify(arr, i, arr.length);
    }
}

```

### 调整堆(Heapify)
调整堆的核心思路在于比较当前节点与两个子节点（也可能只有一个或者没有）之间的大小关系。
1. 当存在比当前节点大的子节点时，交换当前节点与最大的子节点。
2. 判断发生交换的子节点所在的位置与其子节点的大小关系，确定交换数字后的大顶堆是否需要再次调整
3. 递归，直到未排序的部分都调整完成。

```Java
// 调整大顶堆，第三个参数表示剩余未排序的数字的数量，也就是剩余堆的大小
private static void maxHeapify(int[] arr, int i, int heapSize) {
    // 左子节点下标
    int l = 2 * i + 1;
    // 右子节点下标
    int r = l + 1;
    // 记录当前根节点、左子树节点、右子树节点三者中的最大值下标
    int largest = i;
    // 与左子树节点比较
    if (l < heapSize && arr[l] > arr[largest]) {
        largest = l;
    }
    // 与右子树节点比较
    if (r < heapSize && arr[r] > arr[largest]) {
        largest = r;
    }
    if (largest != i) {
        // 将最大值交换为当前根节点
        swap(arr, i, largest);
        // 再次调整交换数字后的大顶堆
        maxHeapify(arr, largest, heapSize);
    }
}
```
<img src="https://img14.360buyimg.com/ddimg/jfs/t1/225687/22/13772/31362/65eeb9baFfe2e1e1d/6e803e7750264e4c.jpg" alt="构建初始大顶堆手绘示意图" title="构建初始大顶堆手绘示意图" />

由此，完整的堆排序代码如下所示：
```Java
public static void heapSort(int[] arr) {
    // 构建初始大顶堆
    buildMaxHeap(arr);
    for (int i = arr.length - 1; i > 0; i--) {
        // 将最大值交换到数组最后
        swap(arr, 0, i);
        // 调整剩余数组，使其满足大顶堆
        maxHeapify(arr, 0, i);
    }
}
// 构建初始大顶堆
private static void buildMaxHeap(int[] arr) {
    // 从最后一个非叶子结点开始调整大顶堆，最后一个非叶子结点的下标就是 arr.length / 2-1
    for (int i = arr.length / 2 - 1; i >= 0; i--) {
        maxHeapify(arr, i, arr.length);
    }
}
// 调整大顶堆，第三个参数表示剩余未排序的数字的数量，也就是剩余堆的大小
private static void maxHeapify(int[] arr, int i, int heapSize) {
    // 左子结点下标
    int l = 2 * i + 1;
    // 右子结点下标
    int r = l + 1;
    // 记录根结点、左子树结点、右子树结点三者中的最大值下标
    int largest = i;
    // 与左子树结点比较
    if (l < heapSize && arr[l] > arr[largest]) {
        largest = l;
    }
    // 与右子树结点比较
    if (r < heapSize && arr[r] > arr[largest]) {
        largest = r;
    }
    if (largest != i) {
        // 将最大值交换为根结点
        swap(arr, i, largest);
        // 再次调整交换数字后的大顶堆
        maxHeapify(arr, largest, heapSize);
    }
}
```

> 在含有n个关键字的小顶堆中,关键字最大的记录有可能存储在 [n/2] + 2 的位置上。

{% note info 二叉排序树 %}
二叉排序树是具有下列性质的二叉树： 
 
  1. 若它的左子树不空，则左子树上所有结点的值都小于根结点的值； 
  2. 若它的右子树不空，则右子树上所有结点的值都大于根结点的值； 
  3. 左右子树分别为二叉排序树。

该种类型的树用来通过比较不断收紧范围查找对应元素。
{% endnote %}

## 快速排序/Quick Sort
- Unstable/In-place
- 平均时间复杂度：O(nlogn)
- 最坏时间复杂度：O(n^2)
- 空间复杂度：O(logn) ~ O(n)
- 平均比较次数：nlogn

{% video Quicksort.mp4 %}

快速排序算法是面试中考察的重点，也是应用最广泛的排序算法。快速排序使用到了**分治**的思想。排序过程是：

1. 从数组中取出一个数，称之为基数（pivot）；
2. 遍历数组，将比基数大的数字放到它的右边，比基数小的数字放到它的左边。遍历完成后，数组被分成了左右两个区域；
3. 将左右两个区域视为两个数组，重复前两个步骤，直到排序完成。

> 基数的选择没有固定标准，随意选择区间内任何一个数字做基数都可以。通常来讲有三种选择方式：
>- 选择 **第一个元素** 作为基数
>- 选择 **最后一个元素** 作为基数
>- 选择区间内一个 **随机元素** 作为基数

由此，可以写出快速排序的基本框架：

```Java
public void quickSort(int[] arr){
    quickSort(arr, 0, arr.length-1)
}
public void quickSort(int[] arr, int start, int end){
    if(start >= end)
        return;
    int mid = partition(arr, start, end);
    quickSort(arr, start, mid - 1);
    quickSort(arr, mid + 1, end);
}
public int partition(int[] arr, int start, int end){
    // 分区函数
}
```

“start >= end”反映了我们需要考虑的边界问题：当拆分完的左右数组只有一个或者没有元素时，不需要对其进行快排操作。“**partition**”函数为分区函数，选择的基数不同，该函数的实现也不同。下面的代码记录了第一种（选择第一个元素作为基数）与第三种（随机选择基数）实现的过程。
从数学的角度上来说，选择随机元素作为基数的平均时间复杂度是最优的。因为当待排序的数据是正序或逆序时，选择第一或最后一个元素会导致每一轮都只能排好一个基数，导致时间复杂度提升到O(n^2)量级。

{% tabs 快速排序的写法 %}
<!-- tab 一般来说的写法 -->
在这个写法中，我们选择左右数组中的第一个数作为基数（pivot），利用双指针思想对其进行快速排序。
从 left 开始，遇到比基数大的数，记录其下标；再从 right 往前遍历，找到第一个比基数小的数，记录其下标；然后交换这两个数。继续遍历，直到 left 和 right 相遇。然后就和刚才的算法一样了，交换基数和中间值，并返回中间值的下标。
```Java
public void quickSort(int[] arr){
    quickSort(arr, 0, arr.length-1);
}
public void quickSort(int[] arr, int start, int end){
    // 设置递归边界情况，即只有一个或没有元素时结束
    if(start >= end)
        return;
    int mid = partition(arr, start, end);
    quickSort(arr, start, mid - 1);     // 这里是不包括已经确定位置的mid的
    quickSort(arr, mid + 1, end);
}
public int partition(int[] arr, int start, int endd){
    int pivot = arr[start];
    // 设置头尾指针
    int head = start + 1;
    int end = endd;
    while(head < end){
        while(head < end && arr[head] <= pivot){
            head++;
        }
        while(head < end && arr[end] >= pivot){
            end--;
        }
        if(head < end){
            swap(head, end);
            head++;     // 继续搜索逆序对
            end--;
        }
    }
    // head与end相碰，代表当前仅有两个元素
    if(head == end && arr[end] > pivot){
        end--;
    }
    // 将pivot与end交换，结束一轮快排
    swap(start, end);
    // 返回已序mid
    return end;
}
```
<!-- endtab -->

<!-- tab 选择最后一个元素为pivot -->
和第一种写法非常类似，不展开叙述了。可以看下面的图解：

<img src="https://img11.360buyimg.com/ddimg/jfs/t1/235683/5/12303/62936/65f41ae7Ffbc8f474/c2c5f66a069969ed.jpg" alt="X$X3M~2A7C`)8$KMYA`A~9A.png" title="X$X3M~2A7C`)8$KMYA`A~9A.png" />

<!-- endtab -->

<!-- tab 随机选择pivot -->
在普通快速排序中，我们选择了固定的基数（如第一个或者最后一个），再结合双指针的方式进行快排。那如果我们不是按照这种模式化的方式选择基数，而是随机选择基数呢？
这种快速排序也叫做“**随机快速排序**”，理论上平均时间复杂度比普通快排要好，但受到随机函数的影响在性能上也会有些许损耗。
你还记得本小节开头的视频吗？视频并没有交代为什么一开始选择了“**3**”，你可以当作这个“**3**”就是**随机选择**出来的。后续的操作和视频中的如出一辙：
1. 我们先将随机挑选出的数交换到数组的最后一位
2. 然后将head和end指针设置在 start 和 end - 1 的位置
3. 接下来开始双指针吧！
```Java
public void quickSortRandom(int[] arr){
    quickSortRandom(arr, 0, arr.length-1);
}
public void quickSortRandom(int[] arr, int start, int end){
    if(start >= end)
        return;
    int mid = partitionRandom(arr, start, end);
    quickSortRandom(arr, start, mid - 1);     // 这里是不包括已经确定位置的mid的
    quickSortRandom(arr, mid + 1, end);
}
public int partitionRandom(int[] arr, int start, int endd){
    // 随机选择pivot
    int random = start + (int)(Math.random() * (endd-start+1));
    int pivot = arr[random];
    // 交换pivot与当前尾部
    swap(random, endd);
    // 设置头尾指针
    int head = start;
    int end = endd - 1;
    while(head < end){
        while(head < end && arr[head] <= pivot){
            head++;
        }
        while(head < end && arr[end] >= pivot){
            end--;
        }
        if(head < end){
            swap(head, end);
            head++;     // 继续搜索逆序对
            end--;
        }
    }
    if(head == end && arr[head] < pivot){    // head与end相碰，代表当前仅有两个元素
        head++;
    }
    // 将置于尾部的pivot与head(left)交换，结束一轮快排
    swap(head, endd);
    // 返回已序mid
    return head;
}
```
<!-- endtab -->

<!-- tab 双轴快排 -->
双轴快排（Dual-Pivot Quicksort）的思路在于通过两个pivot（p1 与 p2），在一次遍历结束后划分出三个区域（确定了两个 pivot 的最终位置），然后再利用分治思想处理新区域。但是在这个执行过程应该去如何处理分析呢？需要几个参数呢？

<img src="https://www.javacodegeeks.com/wp-content/uploads/2013/06/Optimized-DualPivot.png.jpg" />

- 假设知道排序区间[start, end]、数组为arr，则我们可以设置 p1 = arr[start], p2 = arr[end]。
- 同时还需要三个参数：left，right 和 k。
- left 初始为 start，[start, left]区域即为小于等于 p1 的区域(第一个等于)。
- right 初始为 end，[right, end]为大于等于 p2 的区域(最后一个等于)。
- k初始为start + 1，是一个从左往右遍历的指针，遍历的数值与 p1，p2 比较进行适当交换，当k >= right即可停止。

另附文章：https://cloud.tencent.com/developer/article/1745880
上文讲的很清楚，这里就不过多赘述了。
<!-- endtab -->
{% endtabs %}

优化方式除了选择随机基数之外，还可以先用**洗牌算法**（如Java中的**Collections.shuffle**函数）打乱输入数组。

```Java
private static final int SHUFFLE_THRESHOLD = 5;

public static void shuffle(List<?> list, Random rnd) {
    int size = list.size();
    if (size < SHUFFLE_THRESHOLD || list instanceof RandomAccess) {
        for (int i=size; i>1; i--)
            swap(list, i-1, rnd.nextInt(i));
    } else {
        Object arr[] = list.toArray();
        // Shuffle array
        for (int i=size; i>1; i--)
            swap(arr, i-1, rnd.nextInt(i));
        // Dump array back into list
        // instead of using a raw type here, it's possible to capture
        // the wildcard but it will require a call to a supplementary
        // private method
        ListIterator it = list.listIterator();
        for (int i=0; i<arr.length; i++) {
            it.next();
            it.set(arr[i]);
        }
    }
}

public static void swap(List<?> list, int i, int j) {
    // instead of using a raw type here, it's possible to capture
    // the wildcard but it will require a call to a supplementary
    // private method
    final List l = list;
    l.set(i, l.set(j, l.get(i)));
}

private static void swap(Object[] arr, int i, int j) {
    Object tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

```

> 快速排序在排序的过程中，既要从后向前查找，也要从前向后查找，因此宜采用**顺序存储**。
元素的交换可能会出现**新的逆序**。

{% note info 快速排序挖坑法 %}
除了前面介绍的几种方法之外，快速排序还有一种“挖坑法（三数中值法）”：
<img src="https://img14.360buyimg.com/ddimg/jfs/t1/195687/19/44108/47560/65f90331F9ed846df/6ebd095fb2fd6b6c.jpg" alt="挖坑法" title="挖坑法" />
{% endnote %}


## 归并排序/Merge Sort
- Stable/Out-place
- 时间复杂度：O(nlogn)
- 空间复杂度：O(n)

<img src="https://img14.360buyimg.com/ddimg/jfs/t1/216470/20/37859/45936/65f1351cFf8f322ea/48573fa096f46453.jpg" width=500 alt="图解归并排序" title="图解归并排序" />

<br/> 

{% video Mergesort.mp4 %}

如图解所示，归并排序分成两步，一是拆分数组，二是合并数组，它也是**分治思想**的典型应用。分治的意思是“分而治之”（很贴切又有文化的译名），分的时候体现了二分的思想。

保证递归排序效率的关键点在于，当两个要合并的数组都是有序数组的时候，后续插入的元素一定不会在前面插入的元素之前。在逐个插入的过程中，每次插入时，只需要从上次插入的位置开始，继续向后寻找插入位置即可。
以下是合并两个有序数组的代码：
```Java
// 将两个有序数组合并为一个有序数组
private static int[] merge(int[] arr1, int[] arr2) {
    int[] result = new int[arr1.length + arr2.length];
    int index1 = 0, index2 = 0;
    while (index1 < arr1.length && index2 < arr2.length) {
        if (arr1[index1] <= arr2[index2]) {
            result[index1 + index2] = arr1[index1];
            index1++;
        } else {
            result[index1 + index2] = arr2[index2];
            index2++;
        }
    }
    // 将剩余数字补到结果数组之后
    while (index1 < arr1.length) {
        result[index1 + index2] = arr1[index1];
        index1++;
    }
    while (index2 < arr2.length) {
        result[index1 + index2] = arr2[index2];
        index2++;
    }
    return result;
}
```

{% tabs 归并排序的写法 %}
<!-- tab 一般来说的写法 -->
有了我们刚才写的合并两个有序数组的方法，现在我们就要将待排序的数组拆成一对对有序数组。怎么拆呢？
我们可以通过二分法结合递归的形式进行拆分：
```Java
public static int[] void mergeSort(int[] arr) {
    if (arr.length == 0) return;
    int[] result = divide(arr, 0, arr.length - 1);
    
    return result;
}

// 对 arr 的 [start, end] 区间归并排序
private static int[] divide(int[] arr, int start, int end) {
    // 只剩下一个数字，停止拆分，返回单个数字组成的数组
    if (start == end) return new int[]{arr[start]};
    // 二分思想
    int middle = (start + end) / 2;
    // 拆分左边区域
    int[] left = divide(arr, start, middle);
    // 拆分右边区域
    int[] right = divide(arr, middle + 1, end);

    // 拆分到底之后，开始合并左右区域
    return merge(left, right);
}
```
可以看到，divide 函数将原有数组不断地**二分**（(start + end) / 2），直到只剩下最后一个数字（return new int[]{arr[start]}）。此时嵌套的递归开始返回，一层层地调用merge(int[] arr1, int[] arr2)函数，也就是我们刚才写的将两个有序数组合并为一个有序数组的函数。

这就是最经典的归并排序，只需要一个二分拆数组的递归函数和一个合并两个有序列表的函数即可。

但这份代码还有一个缺点，那就是在递归过程中，开辟了很多临时空间，接下来我们就来看下它的优化过程。
<!-- endtab -->

<!-- tab 优化：减少临时空间开辟 -->
在第一种写法中，我们在递归的过程在开辟了不少用于临时储存子数组的**left**和**right**，存在可优化的空间。为了减少在递归过程中不断开辟空间的问题，我们可以在归并排序之前，先开辟出一个临时空间**result**，在递归过程中统一使用此空间进行归并。
```Java
public static int[] mergeSort(int[] arr) {
    if (arr.length == 0) return;
    int[] result = new int[arr.length];
    divide(arr, 0, arr.length - 1, result);

    return result;
}

// 对 arr 的 [start, end] 区间归并排序
private static void divide(int[] arr, int start, int end, int[] result) {
    // 只剩下一个数字，停止拆分
    if (start == end) return;
    // 二分思想
    int middle = (start + end) / 2;
    // 拆分左边区域，并将归并排序的结果保存到 result 的 [start, middle] 区间
    divide(arr, start, middle, result);
    // 拆分右边区域，并将归并排序的结果保存到 result 的 [middle + 1, end] 区间
    divide(arr, middle + 1, end, result);
    // 合并左右区域到 result 的 [start, end] 区间
    merge(arr, start, end, result);
}
```
“分”的时候其实用不到result，主要是在“治”的时候。请看改写后的merge函数，为了实现在result内部合并有序部分，merge 函数接收的参数不再是两个数组，而是 result 数组中需要合并的两个数组的**首尾下标**。根据首尾下标可以分别计算出两个有序数组的首尾下标 start1、end1、start2、end2，之后的过程就和之前合并两个有序数组的代码类似了。
```Java
// 将 result 的 [start, middle] 和 [middle + 1, end] 区间合并
private static void merge(int[] arr, int start,  int end, int[] result) {
    int middle = (start + end) / 2;
    // 数组 1 的首尾位置
    int start1 = start;
    int end1 = middle;
    // 数组 2 的首尾位置
    int start2 = middle + 1;
    int end2 = end;
    // 用来遍历数组的指针
    int index1 = start1;
    int index2 = start2;
    // 结果数组的指针
    int resultIndex = start1;
    while (index1 <= end1 && index2 <= end2) {
        if (arr[index1] <= arr[index2]) {
            result[resultIndex++] = arr[index1++];
        } else {
            result[resultIndex++] = arr[index2++];
        }
    }
    // 将剩余数字补到结果数组之后
    while (index1 <= end1) {
        result[resultIndex++] = arr[index1++];
    }
    while (index2 <= end2) {
        result[resultIndex++] = arr[index2++];
    }
    // 将 result 操作区间的数字拷贝到 arr 数组中，以便下次比较
    for (int i = start; i <= end; i++) {
        arr[i] = result[i];
    }
}
```
<!-- endtab -->

<!-- tab 原地归并？ -->
虽然在上面的写法中不用开辟临时数组记录“分”的部分，但最后还是需要用 result 数组来“治”，这导致归并排序是Out-place类型的排序算法。那有没有办法将归并排序改写为就地形式呢？
答案是：没有！
所谓的**原地归并排序**事实上并不存在，许多算法书籍中都没有收录这种算法。它打着归并排序的幌子，卖的是**插入排序**的思想，实际排序效率比归并排序低得多，时间复杂度达到了O(n^2)。
<!-- endtab -->
{% endtabs %}

| 复习周期 |   1d   |   2d   |   7d   |   21d  |
|  :----: | :----: | :----: | :----: | :----: |
|  /      |        |        |        |        |