---
layout: post
title: 内存管理
date: 2024-12-06 00:04:06
tags:
categories: 操作系统
hidden: true
---

{% note info **缓存的目的** %}
缓存的目的是**解决CPU和主存之间的速度匹配问题**。CPU的运行速度远快于主存，Cache可以在主存与CPU之间提供数据缓冲，解决速度不匹配问题。
Cache的管理和操作由硬件直接负责，软件开发者无需关心Cache的存在，因此**对程序是完全透明的**。
{% endnote %}

{% note info **缓存的理论基础** %}
引入Cache的理论基础是**程序局部性原理**，包括**时间局部性**和**空间局部性**。
{% endnote %}

{% note info **缓存与主存** %}
Cache 和主存**并不共享地址空间**。Cache 存储的数据是主存的一个**副本**，并不占用主存的地址空间。
Cache 使用的是独立的存储硬件，它通过**映射**机制（如直接映射、全相联映射或组相联映射）将主存的部分数据复制到自身。
{% endnote %}

{% note info **替换算法** %}
- 优化替换算法（OPT）：理想情况下的算法，通过预测未来访问情况来做最优决策，但它只是一种理论模型，无法实际应用。
- 先进先出算法（FIFO）：基于“先来先服务”的思想，不考虑页面的使用频率或时间，因此可能发生Belady异常，**不属于堆栈型算法**。
- 近期最少使用算法（LRU）：基于页面的历史使用情况，选择**近期最少使用**的页面进行替换。LRU符合**堆栈型算法**的性质，不会发生Belady异常。
- 近期最久未用过算法（NRU）：LRU的变种，考虑页面最近被访问的时间，选择**近期最久未使用**的页面进行替换。NRU也属于**堆栈型算法**。
{% endnote %}

---

{% note success **缓存替换的LRU算法失败次数计算** %}
通常来说，题目会给出缓存容量大小`C`，访问的一系列页面，问访问失败的次数。
**例如**：缓存容量大小为3，访问顺序为1，2，3，3，2，1，4，3，2，1，问失败次数？
**逐步模拟 LRU 替换过程：** 
| 访问元素 | 缓存状态 | 是否命中 | 操作 |
| --- | --- | --- | --- | 
| **1** | `[1]` | **缓存失败** | 将 `1` 加入缓存 | 
| **2** | `[1, 2]` | **缓存失败** | 将 `2` 加入缓存 | 
| **3** | `[1, 2, 3]` | **缓存失败** | 将 `3` 加入缓存 | 
| **3** | `[1, 2, 3]` | 缓存命中 | 无需修改缓存 |
| **2** | `[1, 2, 3]` | 缓存命中 | 无需修改缓存 |
| **1** | `[1, 2, 3]` | 缓存命中 | 无需修改缓存 |
| **4** | `[4, 2, 3]` | **缓存失败** | 替换最久未用的 `1` |
| **3** | `[4, 3, 2]` | 缓存命中 | 无需修改缓存 |
| **2** | `[4, 3, 2]` | 缓存命中 | 无需修改缓存 |
| **1** | `[1, 3, 2]` | **缓存失败** | 替换最久未用的 `4` |

因此，失败次数为**5**。
{% endnote %}

{% note success **循环首次适应最大空闲分区问题** %}
通常来说，题目会给出主存容量`C`，然后给出用户的一系列分配/释放操作，问最终主存中的最大空闲分区是多少。
**例如**：已知分区的主存容量为100MB，初始情况没有主存被占用（即为空），主存分配和释放的顺序为（单位都为MB）：分20，分10，分30，放10，分5，分30，在采用循环首次适应算法时，主存中最大空闲分区的大小是？
1. 初始情况
    主存容量：100MB
    主存空闲分区：[100MB]
2. 分配20MB
    从第一个空闲分区分配20MB。
    剩余空闲分区：[80MB]
3. 分配10MB
    从剩余的空闲分区分配10MB。
    剩余空闲分区：[70MB]
4. 分配30MB
    从剩余的空闲分区分配30MB。
    剩余空闲分区：[40MB]
5. 释放10MB
    将之前分配的10MB释放回来（假设释放的位置不重排），现在的空闲分区变为：
    第一个分区（释放的10MB）：[10MB]
    第二个分区：[40MB]
    空闲分区列表：[10MB, 40MB]
6. 分配5MB
    按照循环首次适应算法，优先寻找**第一个大小满足的分区**（10MB 分区）分配。
    剩余空闲分区列表：[5MB, 40MB]
7. 分配30MB
    按照循环首次适应算法，继续从剩余的分区中寻找。40MB 分区满足需求，从中分配30MB。
    剩余空闲分区列表：[5MB, 10MB]

剩余的空闲分区为：[5MB, 10MB]，其中最大空闲分区大小为 10MB。
{% endnote %}

{% note success **最佳适配最大空闲分区问题** %}
通常来说，题目也会给出主存容量`C`，然后给出用户的一系列分配/释放操作，问最终主存中的最大空闲分区是多少。
**例如**：已知分区的主存容量为60MB，初始时段没有任何进程占用（即为空）。主存分配和释放顺序为：分10，放25，分15，分28，放15。在采用最佳适配算法置换时，主存中最大空闲分区的大小是？
1. 初始情况
    主存容量：60MB
    主存空闲分区：[60MB]
2. 分配10MB
    从第一个空闲分区分配10MB。
    剩余空闲分区：[50MB]
3. 释放25MB
    从剩余的空闲分区分配10MB。
    剩余空闲分区：[25MB, 50MB]
4. 分配15MB
    按照最佳适配算法，优先寻找**最小满足的分区**（25MB 分区）分配。从剩余的空闲分区分配15MB。
    剩余空闲分区：[10MB, 50MB]
5. 分配28MB
    现在的空闲分区变为：[10MB, 22MB]
6. 释放15MB
    剩余空闲分区列表：[15MB, 10MB, 22MB]

剩余的空闲分区为：[15MB, 10MB, 22MB]，其中最大空闲分区大小为 22MB。
{% endnote %}

---

{% note danger **数据局部性是如何提升计算机系统性能的？** %}
通过提高**缓存的有效性**。数据局部性是指程序访问数据时，**数据的存储位置**与**访问模式**存在的一种空间和时间上的规律性，利用缓存（CPU缓存）提升性能。
缓存命中率越高，内存访问延迟越低，系统性能越高。
{% endnote %}