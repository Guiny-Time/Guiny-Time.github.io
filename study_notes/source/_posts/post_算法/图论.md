---
layout: post
title: 图论
date: 2024-06-15 19:08:55
tags: ['算法与数据结构','数据结构','计算机科学技术','面试相关']
categories: 算法与数据结构
copyright_author: 时光
hidden: true
---

![](https://opendatascience.com/wp-content/uploads/2023/03/TT2.png)

> 图论（Graph theory），是组合数学分支，和其他数学分支如群论、矩阵论、拓扑学有着密切关系。

许多问题都可以抽象成图，比如地图、知识图谱，甚至是人际关系网。
一些关于图的基本概念有：
- **顶点**
- **边**
顶点之间的连接线称为边。
- **路径**
从一个顶点到另一个顶点之间经过的所有顶点的集合，两个顶点之间的路径可以有很多条。
- **路径长度**
一条路径上经过的边的数量。
- **环**
起点和终点为同一个顶点的路径。
- **连通性**
两个不同顶点之间存在至少一条路径，则称这两个顶点是连通的。

{% tabs 图的种类 %}
<!-- tab 无向图 -->
图中任意两个顶点之间的边都是没有方向的。
![无向图](https://oss.suning.com/mbap/mbapbk/c8dde33c008fa207bdafdecb181c3b83.png?SDOSSAccessKeyId=42IA0GY51YZ1397N&Expires=1718456627&Signature=6W3gbq8dIZPXVjMJ6P3FO70R8go%3D)

无向图中，**度**指一个顶点相连接的所有边数称为顶点的度。在上图中，顶点 5 的度为 4，因为与它相连接的边有 4 条。
<!-- endtab -->

<!-- tab 有向图 -->
图中任意两个顶点之间的边都是有方向的。
![](https://static.fuxi.netease.com/fuxi-official/web/20221109/4081911b1702e780da947acd5dac966c.jpg)

- **入度**：有向图中，一个顶点的入度为d，则表示有d条与顶点相连的边指向该顶点。
- **出度**：有向图中，一个顶点的出度为d，则表示有d条与顶点相连的边以该顶点为起点。
<!-- endtab -->

<!-- tab 加权图 -->
图中的每条边都带有一个相关的权重。这里的权重可以是任何一种度量，比如时间，距离，尺寸等。
![image.png](https://oss.suning.com/mbap/mbapbk/8786ad9b795705cd6512bf8ba2f96079.png?SDOSSAccessKeyId=42IA0GY51YZ1397N&Expires=1718456690&Signature=VHcmmqq6bhqWr64WHySL9QTk3pk%3D)

在加权图中，如果一个环的所有边的权重加起来为负数，我们就称之为**负权环**。
<!-- endtab -->
{% endtabs %}

# 图的数据结构
## 矩阵存图法
矩阵存图法也被称为邻接矩阵(adjacency matrix)存图法。邻接矩阵的长和宽分别指代顶点的标号。从矩阵的一般定义来说，第一个数代表行、第二个数代表列。
例如，
- 在有向图中，从顶点 i 指向顶点 j 的边可以用 [i, j] = 1 来表示；
- 在无向图中，由于不区分方向的概念，因此连接顶点 i 和顶点 j 的边在邻接矩阵中可以通过 [i, j] = [j, i] = 1 来表示；
- 对于加权图，将1替换为权重即可。

![](https://pub.mdpi-res.com/mathematics/mathematics-11-04533/article_deploy/html/images/mathematics-11-04533-g002.png?1699005393)

![](https://media.licdn.com/dms/image/D4E12AQFMt7-7NQxlRA/article-inline_image-shrink_1500_2232/0/1685213734094?e=1721865600&v=beta&t=BlzIVTlXnJUHrPKDzoJut7NimCr7hxB0ODPFU9w8UwQ)

在矩阵存图法中，如果我们想添加一条从顶点 i 连向顶点 j 的边，我们只需要将 [i, j] 的值设置为对应的值即可，因此添加一条边的时间复杂度为 O(1) 。
如果我们想检查两个顶点是否有直接相连的边，也只需要检查 [i, j] 的值就可以了，因此判断一条边的时间复杂度也是 O(1) 。
而矩阵存图法的弊端在于，如果想遍历一张图的所有存在的边，需要 O(n^2) 级的复杂度，其中有相当的空间还可能被浪费了。因此，这并不是存储图的最佳方式。

## 邻接表存图法
矩阵存图的最大的劣势就是在面对稀疏图时有很多空间没有储存有效信息（因为对于一个图来说，我们通常不会关注哪些点之间没有连边）。针对空间浪费问题的一个优化的思路是只考虑储存那些有连边的点对，这样我们就能够保证所储存下来的信息都会是有效的。
针对上述思路，对于一个有 n 个顶点的图，我们可以利用 n 个链表来储存图，其中第 i 个链表里存着所有从顶点 i 直接连向的点。
![](https://storage.googleapis.com/algodailyrandomassets/curriculum/graphs/implement-a-graph.png)

是不是感觉很像链式的哈希表？
有向图或者无向图应该很明了了，那带权重的图应该怎么处理呢？我们可以改写一下链表节点的结构，比如：
```C#
struct node {
    int nxt; // 连向的点
    int val; // 边权
};
```
这样记录的就不止是连向哪个顶点了。
在邻接表存图的情况下，如果我们想添加一条从顶点 i 连向顶点 j 的边，我们只需要为第 i 个链表添加一个值为 j 的结点即可，因此添加一条边的时间复杂度为 O(1) 。
如果我们想检查两个顶点是否有直接相连的边，就需要遍历第 i 或第 j 个链表（取决于是否为有向图）的值就可以了，因此判断一条边的时间复杂度是 O(出度) 。
相比于矩阵存图法由于邻接表只储存了连接的边的信息，所以其空间复杂度为 O(m) （m 表示图中边的数量），这相对于 O(n^2) 的复杂度来说是一个很大的优化。

## 链式前向星存图法
链式前向星存图和邻接表存图的方式总体思路是相同的，只是在实现的方式上有所不同。链式前向星更像是数组模拟链表的一种运用。
链式前向星与邻接表的最大的不同是：链式前向星存图法中，**边是有编号的**。不同于邻接表存图法每次遇到一条新的边，就将这条边的信息封装到结构体中；链式前向星利用若干个数组储存边的信息，**下标**就是边的编号。

```Java
int tot = 0; // 表示边的数量
int v[100000];   // 储存边的终点
int len[100000]; // 储存边的权值
```
在上面的定义中，我们并没有储存边的起点的信息。就像邻接表存图一样，在链式前向星中，我们用数组来模拟链表，因此对于每一个点 i ，也会有对应的一条链表。具体通过两个数组实现：

```Java
int head[100000]; // 表示 i 号点所对应的链表中储存的第一条边的编号
int nxt[100000];  // 表示链表中 i 号边的下一条边的编号
```
在这种实现下，我们添加一条边的代码如下所示：

```Java
void ins(int start, int end, int val) {
    // 从 start 向 end 连一条权值为 val 的边
    ++tot;
    v[tot] = end;
    len[tot] = val;
    nxt[tot] = head[start];
    head[start] = tot;
}
```
这一段代码的前三行，储存了新建的边的相关信息。接下来要做的事情是把新的这条边放入链表中。而 head[i] 就相当于 i 所对应的链表的头节点，因此我们把最新的边的 nxt 设置为 head[start] (链表里第一条边的编号) ，这是第四行所做的事情。将边插入到链表中之后，链表里面的第一条边就变成了最新的边了，因此我们还需要更新 head[start] 为 tot （第五行）。
至于遍历出边这一操作，和遍历链表相同，我们假定边的编号从 1 开始，所以当循环变量的值为 0 时，说明已经遍历完成，可以退出。代码如下：

```Java
// 遍历 cur 的出边
for (int i = head[cur]; i != 0; i = nxt[i]) {
    int next = v[i]; // next 就是这条边的终点
    int cost = len[i]; // cost 为对应的边权
}
```

链式前向星存图与邻接表存图，虽然实现方式差异较大，但实际的时间复杂度是一样的。最好根据图的**疏密**选择存储方式（稀疏图用链式前向星），一般情况下用邻接表，卡空间时间这些要求比较高的题目或者需要删除边操作的用链式前向星。

{% note primary 什么名字？ %}
![](https://oss.suning.com/mbap/mbapbk/2005767d9ac93417b1ed56b12ff75fc5.jpg?SDOSSAccessKeyId=42IA0GY51YZ1397N&Expires=1718461464&Signature=oyC6CYhXCMxFEF64sg4XSXy6oY4%3D)

这名字刚看的时候感觉好奇怪啊，英文是chain front star，属于非常生硬的直译了。查了一下图论中的<a href="https://en.wikipedia.org/wiki/Star_(graph_theory)">星</a>，指的是一种一个顶点与除它之外的所有顶点组成的集合都有一条边的特殊图，在拓扑结构上看起来比较像星星：
![](https://upload.wikimedia.org/wikipedia/commons/thumb/7/7d/Star_graphs.svg/1920px-Star_graphs.svg.png)

现在回到前文的邻接表存图法中，第 i 个链表，也就是由顶点 i 指向的所有顶点其实就是一种星。

<img src="https://oss.suning.com/mbap/mbapbk/ea29d66d668c1906a96655643c320f6c.png?SDOSSAccessKeyId=42IA0GY51YZ1397N&Expires=1718462663&Signature=eHO8UBiWng8pm%2BrEG2waYdVMbWM%3D" width=300 />

而“链式前向星”本质上是由数组模拟的邻接表，所以叫这个名字也不奇怪了。
{% endnote %}

# 并查集
**并查集**（Disjoint-set data structure），直译为不交集数据结构，常用于处理一些不交集的 **{% label info @合并 %}** 及 **{% label info @查询 %}** 问题（所以得到了并查集的名字）。在图论中，并查集可以帮助我们判断图中两个节点是否具有**连通性**。

> 在一些场合，人们也会认为并查集是一种思想，因此将其视为一种**算法**。

![](https://helloacm.com/wp-images/acm/2012/data-structure/disjoint1.jpg)

在并查集中，存在以下两种基本说法：
- **父节点**
顶点的直接父亲节点。如上图中结点 4 的父节点为结点 3 。

- **根节点**
没有父节点的节点，如上图中的结点 6 。根节点本身可以视为自己的父节点。

## 基本思想
并查集的基本思想是为每个集合指定一个“代表元素”，并通过元素所在集合的代表元素来判断两个元素是否属于同一集合。
在代码层面实现并查集，我们需要借助数组的帮助。其中：
- **索引**
数组索引通常指代顶点本身。
- **元素**
数组索引对应的元素代表该顶点的父节点。

在初始情况下，数组的索引所对应的是顶点本身，即：

![](https://upload.wikimedia.org/wikipedia/commons/thumb/6/67/Dsu_disjoint_sets_init.svg/1920px-Dsu_disjoint_sets_init.svg.png)

而后，我们进行一些**连接**（union）操作，将一些顶点连接在一起：

![](https://upload.wikimedia.org/wikipedia/commons/thumb/a/ac/Dsu_disjoint_sets_final.svg/1920px-Dsu_disjoint_sets_final.svg.png)

在这个过程中，我们不断更新结点的父节点，而最后一个集合的根节点就是该集合的“代表元素”。通过判断两个结点所处集合的“代表元素”（通过**find**操作）是否相同，就可以得知两个结点是否处在同一集合中。若不同，则代表两个结点不连通。

因此，我们可以发现在并查集中有两个重要操作：union 和 find。在并查集的具体实现上有 Quick Union 和 Quick Find 两种形式，从名称上就可以看出他们的侧重点是什么。

### Quick Find
Quick Find方法指的是实现「并查集」时，find 函数时间复杂度很低为 O(1)，但对应的 union 函数就需要承担更多的责任，它的时间复杂度为 O(N)。
在这种方法中，所有结点索引对应的值都直接指向其集合的**根结点**（而不是基本思想中的父节点），因此在union时需要改动的东西就比较多。

```Java
// UnionFind.class
public class UnionFind {
    int root[];

    public UnionFind(int size) {
        root = new int[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;    // 初始装填
        }
    }
    // 直接返回root[x]，就是集合的代表元素，也就是当前结点的根
    public int find(int x) {
        return root[x];
    }
	// 连接结点 x 与结点 y
    public void union(int x, int y) {
        // 首先找到两个结点的根节点
        int rootX = find(x);
        int rootY = find(y);
        // 如果两个结点不属于同一集合
        if (rootX != rootY) {
            for (int i = 0; i < root.length; i++) {
                // 把所有属于第二个集合的元素的根都改了
                if (root[i] == rootY) {
                    root[i] = rootX;
                }
            }
        }
    };
    // 如果根相同，则位于同一集合，结点之间联通
    public boolean connected(int x, int y) {
        return find(x) == find(y);
    }
}
```

### Quick Union
Quick Union方法指的是实现「并查集」时，相对于 Quick Find 的实现方式，我们通过降低 union 函数的职责来提高它的效率（时间复杂度O(1)），但同时，我们也增加了 find 函数的职责（时间复杂度O(m)）。
它的想法完全基于基本思想。
```Java
public class UnionFind {
    int root[];

    public UnionFind(int size) {
        root = new int[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;    // 初始装填
        }
    }
    // 通过root[x]，也就是当前结点的直接父结点，一直查询到集合的代表元素（根，此时根与索引相等）
    public int find(int x) {
        while (x != root[x]) {
            x = root[x];
        }
        return x;
    }
    // Quick体现在此，直接改被合并索引的值为父节点值即可
    public void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX != rootY) {
            root[rootY] = rootX;
        }
    };
    // 如果根相同，则位于同一集合，结点之间联通
    public boolean connected(int x, int y) {
        return find(x) == find(y);
    }
}
```
Quick Union 比 Quick Find更高效，为什么呢？因为QF在union时的时间复杂度必然为O(N)，而QU在find时最坏的时间复杂度才为O(N)，通常情况下则为O(m)，m代表当前结点到根的距离。所以总体来说，QU的效率比QF更高；只有当图完全退化成链表时，QU和QF的复杂度相同。

不过这两种方法并不是实现并查集最好的方法（特别是遇到退化的图时），接下来隆重推出两种新方法：

### 按秩合并
「**秩**」可以理解为「**秩序**」。之前我们在 union 操作的时候，我们是随机选择 x 和 y 中的一个根节点/父节点作为另一个顶点的根节点（在前面的代码中都是选的x）。但是在「按秩合并」中，我们是按照「**某种秩序**」选择一个父节点。

这里的「秩」指的是每个顶点所处的**高度**。我们每次 union 两个顶点的时候，选择根节点的时候不是随机的选择某个顶点的根节点，而是将「秩」大的那个根节点作为两个顶点的根节点，换句话说，我们将低的树合并到高的树之下，将高的树的根节点作为两个顶点的根节点。这样，我们就避免了所有的顶点连成一条线，这就是按秩合并优化的「并查集」。

在这个新规则下图将会接近二叉树的形态，因此无论是 find、union 还是 connected 函数，其时间复杂度都在 O(logN) 。这个方法是对于QU方法的优化。

```Java
// UnionFind.class
public class UnionFind {
    int root[];
    int rank[]; // 记录每个顶点的高度

    public UnionFind(int size) {
        root = new int[size];
        rank = new int[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;    // 初始装填
            rank[i] = 1;    // 此时所有高度为1，因为没有图
        }
    }
    // 和QU一样
    public int find(int x) {
        while (x != root[x]) {
            x = root[x];
        }
        return x;
    }

    public void union(int x, int y) {
        int rootX = find(x);    // 找根节点
        int rootY = find(y);
        if (rootX != rootY) {
            if (rank[rootX] > rank[rootY]) {    // 比较根节点的高度，谁高就让谁继续当根结点
                root[rootY] = rootX;
            } else if (rank[rootX] < rank[rootY]) {
                root[rootX] = rootY;
            } else {    // 相等，无所谓哪个，这里就选择x当根节点吧。此时高度需要更新
                root[rootY] = rootX;
                rank[rootX] += 1;
            }
        }
    };
    // 如果根相同，则位于同一集合，结点之间联通
    public boolean connected(int x, int y) {
        return find(x) == find(y);
    }
}
```

### 路径压缩优化
从前面的三种实现方式中，我们不难看出，要想找到一个元素的根节点，需要沿着它的父亲节点的足迹一直遍历下去，直到找到它的根节点为止。如果下次再查找同一个元素的根节点，我们还是要做相同的操作。那我们有没有什么办法将它升级优化下呢？

答案是可以的！如果我们在找到根节点之后，将所有遍历过的元素的父节点都**改成根节点**（在root数组上体现为与根节点直接相连），那么我们下次再查询到相同元素的时候，我们就仅仅只需要遍历两个元素就可以找到它的根节点了，这是非常高效的实现方式。那么问题来了，我们如何将所有遍历过的元素的父节点都改成根节点呢？这里就要拿出「**递归**」算法了。这种优化我们称之为「**路径压缩**」优化，它是对 find 函数的一种优化。

这个方法依然是对于QU方法的优化。

![image.png](https://oss.suning.com/mbap/mbapbk/8c7839faef0dc8ff17677459809ea2b8.png?SDOSSAccessKeyId=42IA0GY51YZ1397N&Expires=1718976662&Signature=PBBMtkiw0%2BfGg%2FiD1ePX%2BiQj6tk%3D)

```Java
// UnionFind.class
public class UnionFind {
    int root[];

    public UnionFind(int size) {
        root = new int[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;    // 初始装填
        }
    }
    // 递归改父节点为根节点
    public int find(int x) {
        if (x == root[x]) {
            return x;
        }
        return root[x] = find(root[x]);
    }
    // 和QU一样
    public void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX != rootY) {
            root[rootY] = rootX;
        }
    };
    // 如果根相同，则位于同一集合，结点之间联通
    public boolean connected(int x, int y) {
        return find(x) == find(y);
    }
}
```

## 终极代码
这个优化就是将「路径压缩优化」和「按秩合并优化」合并后形成的「并查集」的实现方式。

```Java
// UnionFind.class
public class UnionFind {
    int root[];
    // 添加了 rank 数组来记录每个顶点的高度，也就是每个顶点的「秩」
    int rank[];

    public UnionFind(int size) {
        root = new int[size];
        rank = new int[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;
            rank[i] = 1; // 一开始每个顶点的初始「秩」为1，因为它们只有自己本身的一个顶点。
        }
    }

		// 此处的 find 函数与路径压优化缩版本的 find 函数一样。
    public int find(int x) {
        if (x == root[x]) {
            return x;
        }
        return root[x] = find(root[x]);
    }

		// 按秩合并优化的 union 函数
    public void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX != rootY) {
            if (rank[rootX] > rank[rootY]) {
                root[rootY] = rootX;
            } else if (rank[rootX] < rank[rootY]) {
                root[rootX] = rootY;
            } else {
                root[rootY] = rootX;
                rank[rootX] += 1;
            }
        }
    };

    public boolean connected(int x, int y) {
        return find(x) == find(y);
    }
}
```
「并查集」的代码是高度模版化的，在遇到相关题目的时候可以淡定应对。推荐大家熟记「基于路径压缩+按秩合并的并查集」的实现代码。
