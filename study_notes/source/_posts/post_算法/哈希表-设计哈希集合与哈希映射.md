---
layout: post
title: 哈希表-设计哈希集合与哈希映射
date: 2024-03-31 19:46:22
tags: ['算法与数据结构','数据结构','计算机科学技术','面试相关']
categories: 算法与数据结构
copyright_author: 时光
katex: true
hidden: true
---

# 什么是哈希表?
> A hash table is a collection of items which are stored in such a way as to make it easy to find them later.
**哈希表是一组数据的集合，该存储方式便于以后查找。**
> 它把任意长度的信息转换成固定的长度输出（哈希值）。根据特定的哈希值，它可以找到对应的原信息值

哈希表是根据哈希函数组织数据、通过键（Key）直接访问在存储器存储位置的数据结构，该结构与数组（顺序存储）、链表（链式存储）并不相同，被称为“**散列存储**”，其基本原理如下图所示。哈希表通过 **{% label success @哈希函数 %}** ，将不同的 **{% label info @键 %}** 映射到不同的 **{% label primary @桶 %}** 里面。
- 空间复杂度O(n)
- 时间复杂度O(1)
    - 当存储容器为**链表**时，最坏时间复杂度为O(n)
    - 当存储容器为**平衡二叉树**时，最坏时间复杂度为O(logn)

![哈希表原理](https://upload.wikimedia.org/wikipedia/commons/thumb/7/7d/Hash_table_3_1_1_0_1_0_0_SP.svg/1200px-Hash_table_3_1_1_0_1_0_0_SP.svg.png)

- **{% label success @哈希函数 %}**：**{% label info @键 %}** 输入 **{% label success @哈希函数 %}** 后，由函数计算出对应的 **{% label danger @哈希值(Hash Value) %}**
- **{% label info @键 %}**：查找对应元素的索引，是唯一的
- **{% label primary @桶 %}**：用来存放数据的容器，可以是数组或链表
- **{% label danger @哈希值 %}**：**{% label danger @哈希值 %}** 是通过一个 **{% label success @哈希函数 %}** 把难以比较的字符串或者其他类型的数据映射成的一个整数。在使用奇形怪状的键进行查找时，底层逻辑会先将奇形怪状的键转换成哈希值再进行检索

有两种不同类型的哈希表，分别是 **{% label warning @哈希集合(HashSet) %}** 和 **{% label warning @哈希映射(HashMap) %}**。我们会在接下来的文章中介绍它们。

- **{% label warning @哈希集合(HashSet) %}**：**集合**数据结构的实现之一，用于存储**非重复值**，可以用来存储 **键/key**。
- **{% label warning @哈希映射(HashMap) %}**：**映射**数据结构的实现之一，用于存储(key, value) **键值对**。

# 哈希函数
哈希函数又称**散列函数**，原始数据经过 **{% label success @哈希函数 %}** 的处理后获得 **{% label danger @哈希值 %}** ，这是用来在 **{% label primary @桶 %}** 中查找元素的索引。一个好的哈希函数应该具有以下三种特点：
- 高效性，哈希函数需要简便高效、容易计算
- 均匀性，计算结果应该均匀分布，避免产生哈希冲突或空间浪费
- 一致性，同一个 **{% label info @键 %}** 经过 **{% label success @哈希函数 %}** 的处理产生相同的值

那我们应该如何设置哈希函数呢？从经验的角度，一般有以下几种常见的哈希函数：

## 余数法
1. 设置数组为 **{% label primary @桶 %}** 容器，数组长度可以是待处理数据的大小
2. **{% label danger @哈希值 %}** 即原始数据 x **模**（%） 数组长度的结果。
```
hash = x % 数组长度
```

## 中间平方法
1. 拿到需要hash的数，对其平方
2. 取平方完的数中间的数字再次平方
3. 重复多次上述操作，直到得到你想要的key。

<img src="https://img12.360buyimg.com/ddimg/jfs/t1/88738/20/41877/36929/660fad3eF3bb778a3/3e0ea4da352e81af.jpg" width=400 alt="CS211-1.png" title="CS211-1.png" />

这种情况下得的key具有极大的随机性（如果初始输入很大的话）

# 哈希冲突 / 哈希碰撞
Hash Collision，这种灾难性的事件发生在当两个数据的 **{% label info @键 %}** 经过 **{% label success @哈希函数 %}** 处理后得到了相同的 **{% label danger @哈希值 %}**，如下图中的John Smith和Sandra Dee：

<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/58/Hash_table_4_1_1_0_0_1_0_LL.svg/1200px-Hash_table_4_1_1_0_0_1_0_LL.svg.png">

实际上，最简单的观察一个hash function是否会发生碰撞的方法就是看这个函数是否是**单调递增/单调递减**的。

{% note info 哈希表的**负荷系数**(Load Factor) %}
负荷系数是衡量哈希表的负荷情况的系数，记作**λ**
当哈希表装满时，λ = 1；当哈希表装了一半时，λ = 0.5
```
       已经填入哈希表的元素个数
λ = ————————————————————————————
             哈希表的大小
```
负荷系数越大，哈希表越满，也越可能发生哈希碰撞.
{% endnote %}

## 线性探测法
我们可以用线性探测法处理哈希碰撞。
- 存储哈希冲突的键的**结构是数组**
- 当遇到碰撞时，检查下一个位置，在原本计算得到的key的基础上 + 1 % 数组大小
```
(h(key) + 1) % table_size
```
- 如果再遇到，那就在**最开始得到的key上** + 2 % 数组大小
- 相同思想递归

{% note warning 线性探测难题：删除问题 %}
> 当在同一个key处存在相同的碰撞，可能会导致连续的一个范围内都是这个key的线性延伸
此时，当我们删掉了这个线性延伸中间的一部分时，就可能会导致程序认为这个key的延伸已经没有了。请问怎么办呢？

正确做法是使用一个**占位符**（如下图中的“墓碑”）标记该单元格是空的，并且之前被占用过
- 查找时，不要停留在墓碑前，继续寻找
* 需要小心环绕
- 当插入时，请随意替换你遇到的任何墓碑

<img src="https://img13.360buyimg.com/ddimg/jfs/t1/227668/29/15888/14311/660fafcfF784e42f7/1a989d2060e730a3.jpg" width=300 alt="CS211-3.png" title="CS211-3.png" />

{% endnote %}

{% note success 线性探测法的优缺点 %}
- **优点**
在实践中，线性探测是最快的通用哈希策略之一。
    - 低内存开销: 只需要一个数组和一个hash函数
    - 极佳的局部性: 当冲突发生时，我们只搜索数组中相邻的位置
    - 出色的缓存性能: 这是上述两个因素的结合
- **缺点**
    - 线性探测在负载系数很高时表现出严重的性能下降
    - 碰撞的数量趋向于随着现有碰撞的数量而增长
    - 同义词在散列表中不一定相邻
{% endnote %}

## 链地址法
- 存储哈希冲突的键的**结构是链表数组**
- 当遇到碰撞时，把新的键放到原有的链表后
- 如果再遇到，那就把新的键再放到原有的链表后
- 相同思想递归

<img src="https://img10.360buyimg.com/ddimg/jfs/t1/196335/4/43418/9925/660fb126Fcb19f08b/e428ed82639dbc5e.jpg" width=350 alt="CS211-2.png" title="CS211-2.png" />

## 平方探测
- 表的**结构是数组**
- 当遇到碰撞时，在原本计算得到的 **{% label danger @哈希值 %}** 的基础上 + 1<sup>2</sup> % 数组大小
```
(h(key) + 1^2) % table_size
```
- 如果再遇到，那就在**最开始得到的key上**+2<sup>2</sup> % 数组大小
- 相同思想递归
- **为了保证您的平方探测最终将击中每一个可用点，表大小必须满足质数**

## 双散列
- 有**两个** **{% label success @哈希函数 %}** 
- 表的**结构是数组**
- 优点是不容易产生**聚集**
- 当遇到碰撞时，在原本计算得到的 **{% label danger @哈希值 %}** 的基础上 + 1 * h2(value) % 数组大小，也就是用上了第二个函数（h2）来计算新的 **{% label danger @哈希值 %}** 。
- 如果再遇到，那就在**最开始得到的 {% label danger @哈希值 %} 上** + 2 * h2(value) % 数组大小
- 相同思想递归
```
h1(key) + i * h2(key)
```

{% note info 几种方法的总结 %}
<img src="https://img13.360buyimg.com/ddimg/jfs/t1/134192/34/31926/18013/660fb282F3fce9485/aa7bdc0dcb50a5c2.jpg" width=600 alt="CS211-4.png" title="CS211-4.png" />
{% endnote %}


## 满表扩容
当负荷系数 λ 逐渐接近 1 (或者已经大于 1/2 )，我们就要考虑给哈希表扩容：
- 创建更大的表
- 扫描当前的表，移植到新的表里（使用新的hash函数）

扩容将数据重新装进哈希表的时间复杂度为O(n)，因为一共有 n 个元素，每个元素hash的时间复杂度为O(1),每个元素插入的时间复杂度为O(1)，一共是 O(1) * N + O(N)

# 哈希集合
**{% label warning @哈希集合(HashSet) %}** 是 **集合** 数据结构的实现之一，用于存储 **非重复值**，可以用来存储 **键/key**。哈希集合主要的用途是**检查一个元素是否只出现过一次**，可以用来判断数据结构中是否存在重复元素。
很多编程语言中都内置了哈希集合的实现方法，例如 Java 中的 HashSet。
```Java
// 声明哈希集
Set<Integer> hashSet = new HashSet<>();
// 添加元素
hashSet.add(3);
hashSet.add(2);
hashSet.add(2);      // 无法添加重复元素
// 移除元素
hashSet.remove(2);
hashSet.remove(2);   // 无法重复移除
// 判断是否包含
System.out.println(hashSet.contains(2));  // false
// 哈希集大小
System.out.println(hashSet.size());       // 1
// 迭代器遍历
for(Integer i : hashSet){
    System.out.println(i);
}
// 判断哈希集是否为空
if(!hashSet.isEmpty())
    hashSet.clear();     // 清空哈希集
```

{% note info 用HashSet检查重复元素 %}
```Java
boolean findDuplicartes(List<T> keys){
    Set<T> hashSet = new HashSet<>();
    for(T key : keys){
       if(hashSet.contains(key)){
            return true;
       }
            hashSet.add(key);
    }
    return false;
}
```
{% endnote %}

# 哈希映射
**{% label warning @哈希映射(HashMap) %}**：**映射**数据结构的实现之一，用于存储(key, value) **键值对**。哈希映射的主要用途体现在 value 上，起到**存储信息** 和 **聚合信息**（唯一字符） 的作用。
- 统计字符的出现次数
- 更新元素的最新下标
- 统计相同键的和
- 建立两张表/数组的映射关系（LC205）

很多编程语言中都内置了哈希集合的实现方法，例如 Java 中的 HashMap。
```Java
Map<Ingeter, Integer> hm = new HashMap<>();
hm.put(1,1);            // 加入kvp
hm.putIfAbsent(2,2);    // 如果已经存在该kvp，则无法加入
hm.get(1);              // 通过键获取值，如不存在返回null
hm.getOrDefault(3,1);   // 尝试通过键获取值，如不存在返回默认值
hm.remove(2);           // 移除kvp，如果存在则返回对应的value
System.out.println(hm.containsKey(2));      // false，检查是否存在某键
System.out.println(hm.containsValue(1));    // true，检查是否存在某值，复杂度为线性（遍历了）
System.out.println(hm.isEmpty());           // false
System.out.println(hm.size());              // 1
hm.clear();             // 清空
```
 
# 题外话-哈希表在Java中的历史
在做题的时候偶然发现了独立于HashMap或者HashSet的Hashtable类。Hashtable继承自Dictionary类，是Java 1.2 版本之前用来表示哈希表的方法。
Hashtable与HashMap的主要区别在于：
1. Hashtable只有一个contains方法，检查一个值是否在哈希表中有对应的键
    相比之下，HashMap有containsKey和containsValue两个方法，更为清晰
2. Hashtable继承自Dictionary类，而HashMap继承自AbstractMap类，是Map接口的一个实现
3. Hashtable是同步（线程安全）的，而HashMap不是
4. HashMap允许将空值作为一个表的条目的key或value，而Hashtable不允许

此外，Hashtable和HashMap采用的hash/rehash算法都大概一样，所以性能不会有很大的差异。

> 线程安全的Map
在JDK 1.5及更高版本环境中，HashMap和TreeMap都不是线程安全的。但是我们可以通过下面两种方式实现线程安全的Map：
>- Map map = new ConcurrentHashMap();
ConcurrentHashMap将Hash表分为16个桶(segment)，每次只对需要的桶进行加锁（而Hashtable是锁整张表的）。
>- Map map = Collections.synchronizedMap(new HashMap());
Collections.synchronizedXxx()方法，可以将指定的集合包装成线程同步的集合。