---
layout: post
title: 链表
date: 2024-03-31 19:46:22
tags: ['算法与数据结构','数据结构','计算机科学技术','面试相关']
categories: 算法与数据结构
copyright_author: 时光
hidden: true
---

链表是一种数据结构，属于线性表，是一种物理存储单元上非连续、非顺序的存储结构。单链表的存储密度始终小于1，因为节点空间中除了数据本身外还有指向下一个节点所在的位置。
特点：
- 顺序存取（与之相对的数组则是**随机存取**，直接访问）
- 适合频繁插入和删除（双链表比单链表更有优势）
- 不支持高效的随机元素访问
- 不方便存取

{% note success **Java 中的 List 接口** %}
Java 中的 List 接口有两个实现，即 **ArrayList** 和 **LinkedList**。其中，
1. ArrayList 是可改变大小的数组（变长数组）。
2. LinkedList 是双向链接串列（双链表）。
{% endnote %}

# 单链表
![](https://miro.medium.com/v2/resize:fit:953/1*iiEWrP2IznA6HbmuIdK0lQ.png)

单链表是一直只能从前向后遍历、每一个元素都有指向下一个节点的指针next的数据结构。通常，我们通过**Head**指针访问单链表的**第一个节点**，并通过循环找到对应的节点。
但有时，我们会为单链表的head指定为一个哑节点（dummy node），正式节点接在后面（此时第一个带数据的节点被称为**首节点**）。此时判断单链表是否为空的条件就变成了 head.neaxt == null? 了。
单链表节点的数据结构如下：
```Java
class SinglyLinkedList{
    int val;
    SinglyLinkedList next;
    SinglyLinkedList(){}
    SinglyLinkedList(int _val){
        val = _val;
    }
}
```
## 链表相交
![](https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png)
单链表的每个节点都具有唯一的前驱节点和唯一的后继节点，所以当两个单链表存在相交的节点时，这两个链表则**同时拥有这个节点**，以及这个节点的**所有后继节点**。当这个公共节点是尾节点时，两个相交的单链表则只含有公共一个节点——尾节点。
有环的单向链表和无环的单向链表不能相交，因为当相交的时候，无环的单向链表也会被迫存在一个环，只不过这个环的”起点“可能不是原来单向链表的头结点。
两个单向链表之间相交可以存在环。

# 双链表
![](https://miro.medium.com/v2/resize:fit:4000/1*Rkn3q6HJoEkRO4T_SVlyuw.png)

双链表中不仅有指向下一个节点的指针next，还有指向前一个节点的指针prev。

```Java
class DoubleLinkedList{
    int val;
    DoubleLinkedList next;
    DoubleLinkedList prev;
    DoubleLinkedList(){}
    DoubleLinkedList(int _val){
        val = _val;
    }
}
```

# 环型链表
环型链表或称循环链表，同样分为单双两种子类。
单循环链表的主要优点是**从表中任一结点出发都能扫描到整个链表**。
在表头和表尾都可能有元素被插入的情况下，在**单循环链表**中设置尾指针比设置头指针好。因为在这种情况下查找头部和尾部的复杂度都是O(1)。

## Floyd 判圈算法步长问题
Floyd 判圈算法 (Floyd’s Cycle Finding Algorithm) 是一种判断链表中是否存在 **环** 的算法，核心思想为**快慢指针**。算法指出，当链表存在环时，快慢指针一定会在环中相遇。

![](https://res.cloudinary.com/practicaldev/image/fetch/s--e_6wOF00--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/chpcvc0wjmpx2mi3l5l9.png)

![](https://camo.githubusercontent.com/44a65aa61c1b86278c0c6f21a23f1cf46e600ef284bbf6fac42963654b44125d/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303231303331383136353132333538312e706e67)

{% note info **一个长度为100的循环链表，指针A和指针B都指向了链表中的同一个节点，A以步长为1向前移动，B以步长为3向前移动，一共需要同时移动多少步A和B才能再次指向同一个节点?** %}
A向前移动1步，B向前移动3步。假设A，B都在起点，那么把A看做静止，B相对于A就是以2两步移动了。所以这个题可以这么说：在长度为100的循环链表中，A,B均在起点，A不移动，B每次移动2步，问啥时候能回到起点？
{% endnote %}

# 广义表
广义表即我们通常所说的列表（lists)。它放松了对表元素的原子性限制，允许他们有自身结构，例如广义表E((a,(a,b),((a,b),c)))。
对广义表来说，有两个重要的概念，即：
1. 长度
若广义表不空，则广义表的长度表示表所包含的**元素的个数**，也就是广义表第一层括号内的**逗号数目**。
2. 深度
广义表中括号的最大层数叫广义表的深度。

以广义表E((a,(a,b),((a,b),c)))为例，它的长度和深度如下所示：
![](https://uploadfiles.nowcoder.com/images/20220113/3900348_1642085069204/393363889A964AF8EEC533211E96C117)
可以看出长度为1，深度为4。

同时，广义表还有两个重要的操作，即：
1. 取表头（Head）
返回表头元素，如广义表E((a,(a,b),((a,b),c)))的Head操作应返回(a,(a,b),((a,b),c))。
2. 去表头（Tail）
返回广义表去除表头元素的剩余部分，如广义表F(a,(a,b),((a,b),c))的Tail操作应返回(a,b),((a,b),c)。