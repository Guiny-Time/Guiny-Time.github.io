---
layout: post
title: 递归思想
date: 2024-03-26 17:14:20
tags: ['算法与数据结构','算法','计算机科学技术','面试相关']
categories: 算法与数据结构
copyright_author: 时光
hidden: true
---

# 什么是递归？

先从递归的定义上切入：

> 在数学与计算机科学中，递归（Recursion）是指在**函数的定义**中**使用函数自身**的方法。

抽象到代码中，这句话的意义等同于以下结构：

```Java
// 定义函数 sayHello
public void sayHello(){
    System.out.println("Hello!");
    // 调用函数自身
    sayHello();
}
```

这是一个简单的递归示例，它的效果是永无止境地打印“Hello!”这句话，直到**StackOverflow**。为什么是堆栈溢出？因为在程序执行中，递归是利用**堆栈**(Stack)来实现的。每当进入一个函数调用，栈就会增加一层栈帧，每次函数返回，栈就会减少一层栈帧。当递归的层数突破了栈的上限，栈就发生了**溢出**。

<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/02/Stack_Overflow_logo.svg/2560px-Stack_Overflow_logo.svg.png" width=200 alt="image.png" title="image.png" />

所以，为了防止出现溢出或非法（例如在二叉树dfs中节点为空）的问题，我们需要为递归设置**退出条件**。当递归达到退出条件时，就会结束。以通过递归计算斐波那契数列第 n 项的值为例：

```Java
public int Fib(int n){
    if(n < 2)
        return 1;
    return Fib(n-1) + Fib(n-2);
}
```
在这个例子中，退出条件是 **n 小于 2** （n为 0 或 1）时。因为斐波那契数列的所有数字都可以靠这两个数递推得到。

{% note info 你理解递归的概念了吗？ %}
在google中键入“**递归**”或“**recursion**”，搜索结果会给出一个小彩蛋（不信的话你可以自己试一试）：

<img src="https://img13.360buyimg.com/ddimg/jfs/t1/163444/19/43753/13748/66029321F5fdfdb6f/70515371721bbfdd.jpg" alt="image.png" title="image.png" />

如果你对递归的概念还是不太清楚，你还可以[查看这个文档](/next/递归思想/)。
{% endnote %}

# 我应该在什么场景使用递归？
递归常常被用于可以**将一个大问题不断拆成子问题**去解决的场景。这种“以大化小、分而治之”的思想实际上就是**分治思想**，在[**快速排序和归并排序**](/next/排序算法之快归希堆/)中我们已经见识过了它们的威力。在下一篇文章中我们将详细说说分治思想的应用。

然而递归也不是完美的，从上文中通过**递归**计算斐波那契数列的方式可以看出，使用递归时重复计算了大量数据，比如下图重复计算了 3 次 F2 的值。如果我们可以记录中间计算的结果，是不是就可以减少开销呢？嗯，这就是记忆化搜索，也就是**动态规划**的思想。

<img src="https://img12.360buyimg.com/ddimg/jfs/t1/149505/10/42506/11440/66029a60Fc4a0907b/152eccc35ea5899c.jpg" alt="image.png" title="image.png" />