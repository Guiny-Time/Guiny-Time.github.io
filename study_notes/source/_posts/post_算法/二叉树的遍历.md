---
layout: post
title: 二叉树的遍历
date: 2024-03-24 22:03:14
tags: ['算法与数据结构','数据结构','计算机科学技术','面试相关']
categories: 算法与数据结构
copyright_author: 时光
katex: true
hidden: true
---

二叉树中的遍历方式有{% label warning @前序遍历 %}、{% label success @中序遍历 %}、{% label info @后序遍历 %}和{% label danger @层序遍历 %}。其中前三种基于**深度优先搜索**(dfs)思想的遍历方式的名称中的“**前**”、“**中**”和“**后**”指的是**根节点**在遍历时所在的顺序。
当我们知道一颗二叉树的**中序遍历结果**，我们就能**唯一**确定一颗二叉树。

{% note info **二叉搜索树** 与 **堆** %}
二叉搜索树是一种特殊的二叉树，其特点是对于每一个节点，它左子树的节点必然小于其本身，而右子树的节点则大于其本身。
联想到之前在堆排序中学习到的堆结构，是不是感觉和BST有一点点像？回忆一下堆的定义：
- 给定堆中任意节点P和C，若P是C的母节点，那么P的值会小于等于（或大于等于）C的值。P小为小顶堆；P大为大顶堆。

二者的区别就体现在**有序性**上。BST的元素维持了**全局有序**，而堆则只维持了**局部**的有序性 (偏序性)，即父节点为左右子树的最大值，但左子树中可以有元素大于右子树的元素。
同时，在数据结构上，堆就是用数组实现的二叉树，但BST存在父指针或子指针。一般在题目中都会给出类似下方的树的代码定义：
```Java
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```
{% endnote %}

# 基于DFS思想的三种遍历
## 前序遍历
前序遍历首先访问**根**节点，然后遍历**左**子树，最后遍历**右**子树。

[查看演示](前序.gif)

{% tabs 前序遍历 %}
<!-- tab 递归法 -->
```Java
public void travel(TreeNode n, List<Integer> l){
    if(n == null)
        return ;
    l.add(n.val);
    travel(n.left, l);
    travel(n.right, l);
}
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<Integer>();
    travel(root, res);
    return res;
}
```
<!-- endtab -->

<!-- tab 迭代法 -->
```Java
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<Integer>();
    Stack<TreeNode> fathers = new Stack<TreeNode>();
    while(root != null || !fathers.isEmpty()){  //栈非空或根节点不为空
        while(root != null){
            fathers.push(root);
            res.add(root.val);
            root = root.left;
        }
        root = fathers.pop().right;
    }
    return res;
}
```
<!-- endtab -->
{% endtabs %}

## 中序遍历
前序遍历首先遍历**左**子树，然后访问**根**节点，最后遍历**右**子树。

[查看演示](中序.gif)

对于一颗二叉搜索树（BST），我们可以通过中序遍历得到一个**递增**的有序序列。

{% tabs 中序遍历 %}
<!-- tab 递归法 -->
```Java
public void travel(TreeNode n, List<Integer> l){
    if(n == null)
        return ;
    travel(n.left, l);
    l.add(n.val);
    travel(n.right, l);
}
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<Integer>();
    travel(root, res);
    return res;
}
```
<!-- endtab -->

<!-- tab 迭代法 -->
```Java
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<Integer>();
    Stack<TreeNode> fathers = new Stack<TreeNode>();
    while(root != null || !fathers.isEmpty()){  //栈非空或根节点不为空
        while(root != null){
            fathers.push(root);
            root = root.left;
        }
        res.add(fathers.peek().val);
        root = fathers.pop().right;
    }
    return res;
}
```
<!-- endtab -->
{% endtabs %}

## 后序遍历
后序遍历的顺序是先遍历**左**子树，然后遍历**右**子树，最后访问**根**节点。

[查看演示](后序.gif)

{% tabs 后序遍历 %}
<!-- tab 递归法 -->
```Java
public void travel(TreeNode n, List<Integer> l){
    if(n == null)
        return ;
    travel(n.left, l);
    travel(n.right, l);
    l.add(n.val);
}
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<Integer>();
    travel(root, res);
    return res;
}
```
<!-- endtab -->

<!-- tab 迭代法 -->
这里可以取巧，将“左子树-右子树-根节点”的遍历顺序看成“根节点-右子树-左子树”的**逆序**。因此，我们可以在前序遍历的基础上稍加改动，并在最后翻转结果：
```Java
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<Integer>();
    Stack<TreeNode> fathers = new Stack<TreeNode>();
    while(root != null || !fathers.isEmpty()){  //栈非空或根节点不为空
        while(root != null){
            fathers.push(root);
            res.add(root.val);
            root = root.right;
        }
        root = fathers.pop().left;
    }
    Collections.reverse(res);
    return res;
}
```
<!-- endtab -->
{% endtabs %}

# 基于BFS思想的遍历
## 层序遍历
层序遍历就是**逐层**遍历树结构。

[查看演示](层序.gif)

BFS又称**广度优先搜索**，是一种广泛运用在树或图这类数据结构中，遍历或搜索的算法。 该算法从一个根节点开始：
1. 访问节点本身
2. 然后遍历它的相邻节点
3. 遍历它的二级邻节点、三级邻节点，以此类推。

当我们在树中进行广度优先搜索时，我们访问的节点的顺序是按照层序遍历顺序的。如果只要求直接输出所有元素的话，可以使用**队列**结构进行遍历：
```Java
public List<Integer> levelOrder(TreeNode root) {
    Queue<TreeNode> q = new LinkedList<TreeNode>();
    List<Integer> res = new ArrayList<Integer>();
    while(root != null || !q.isEmpty()){
        res.add(root.val);
        if(root.left != null)
            q.offer(root.left);
        if(root.right != null)
            q.offer(root.right);
        root = q.poll();
    }
    return res;
}
```
如果我们需要区分每一层怎么办呢？我们可以引入一个记录**每层节点个数**的levelNum，然后进行遍历。
```Java
public List<List<Integer>> levelOrder(TreeNode root) {
    //边界条件判断
    if (root == null)
        return new ArrayList<>();

    Queue<TreeNode> q = new LinkedList<>();
    List<List<Integer>> res = new ArrayList<>();
    //BFS打印，levelNum表示的是每层的结点数
    int levelNum = 0;
    //subList存储的是每层的结点值
    List<Integer> subList;

    //根节点入队
    q.add(root);
    //如果队列不为空就继续循环
    while (!q.isEmpty()) {
        levelNum = q.size();
        subList = new ArrayList<>();
        for (int i = 0; i < levelNum; i++) {
            root = q.poll();
            subList.add(root.val);
            if (root.left != null)
                q.offer(root.left);
            if (root.right != null)
                q.offer(root.right);
        }
        res.add(subList);
    }
    return res;
}
```