---
layout: post
title: something
date: 2025-02-16 14:18:21
tags:
---

Unity 面经

<!-- more -->

# Unity
- **编译型、解释型语言**：
  - 编译型语言：要求必须提前将源代码一次性转化成二进制指令
  - 解释型语言：一边执行一边转换，需要哪些源代码就转换哪些源代码，不会生成可执行程序（源代码跨平台，但解释器不跨，即每个平台都要有对应的解释器）
    - 解释型语言通过编译器将源代码编译成与平台无关的字节码文件，再由解释器（虚拟机）执行字节码文件，从而做到平台无关。但是，有利必有弊。对字节码的解释执行过程实质为：解释器先将字节码翻译为对应的机器指令，然后执行机器指令。很显然，这样经过解释执行，其执行速度必然不如直接执行二进制字节码文件。
    - 而为了提高执行速度，便引入了 JIT 技术。当解释器发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”编译成本地机器相关的机器码，并进行优化，然后再把编译后的机器码缓存起来，以备下次使用。

- **代码编译的四个过程**：
  - 预处理：处理#开头的命令，把对应头文件内容插入程序文本
  - 编译：把源代码翻译成汇编代码
  - 汇编：把汇编代码转换成机器码，产生二进制目标文件
  - 链接：使用链接器将该目标文件与其他目标文件、库文件、启动文件等链接起来生成可执行文件。
    - 动态：lib包含了函数所在DLL文件和文件函数入口，代码由运行时加载在进程空间中的DLL提供
    - 静态：lib包含了函数代码本身，编译阶段将代码加入了程序当中

- **Mono、IL、IL2CPP、托管代码**
  - 目标为.Net框架的语言被编译成CIL，然后汇编成字节码。CIL类似一个面向对象的汇编语言，并且它是完全基于堆栈的，它运行在虚拟机上（.Net Framework, Mono VM）的语言。
  - 具体过程是：C#或者VB这样遵循CLI规范的高级语言，被先被各自的编译器编译成中间语言：IL（CIL），等到需要真正执行的时候，这些IL会被加载到运行时库，也就是VM中，由VM动态的编译成汇编代码（JIT）然后在执行。
  - Mono 是跨平台的 .Net Framework 的实现。Mono 将 CLR（公共语言运行时）在所有支持的平台上重新实现了一遍（包含手机上常用的安卓平台和Switch，PS4，这样的游戏机平台），并且mono还将 .Net Framework 提供的基础类库也重新实现了一遍。
  - IL2CPP实现：得到中间语言IL后，使用IL2CPP将他们重新变回C++代码，然后再由各个平台的C++编译器直接编译成能执行的原生汇编代码。
  - 根据官方的实验数据，换成IL2CPP以后，程序的运行效率有了1.5-2.0倍的提升。
  - IL2CPP将代码翻译成C++静态语言，就无法使用动态特性，诸如反射在IL2CPP（AOT）编译模式下会编译失败
  - 托管代码：CLR托管，GC引用的代码

- **反射**
  - 在加载程序运行时，可以动态的获取和加载程序集，并且可以获取到程序集中类、对象、方法对象数据等信息的一种手段
  - 性能不好，代码管理不方便，优点就是动态加载

- **渲染流程**
  - 渲染管线：固定渲染管线、可编程渲染管线；Unity还分为高清渲染管线（HDRP）、通用渲染管线（URP）
  - GPU的渲染速度往往超过了CPU提交命令的速度，这导致渲染中大部分时间都消耗在了CPU提交Draw Call上。有一种解决这种问题的方法是使用**批处理（Batching）**，即把要渲染的模型合并在一起提交给GPU。
  - 应用阶段：CPU提交数据到GPU，场景数据（光源、摄像机、模型、视锥体），剔除（遮挡，视锥体），渲染状态（纹理、材质、着色器）
  - 几何阶段：顶点（坐标变换），曲面细分（增加顶点，如果为这些细分的顶点再准备一些位置信息，那么这些细分的顶点将有助于我们展现一个细节更加丰富的模型。这也是**贴图置换（Displacement Mapping）**的基本思路。），几何（控制GPU对顶点进行增删改操作，效率低），投影（三维转二维），裁剪（透视除法，不在[-1,1]剔除掉）、屏幕映射（转屏幕空间坐标）
  - 光栅化阶段：图元装配（点成线成面），三角形遍历（像素是否被一个三角形网格所覆盖，抗锯齿，深度计算），片元着色，逐片元操作（测试合并）、混合、送到颜色（双）缓冲

- **GPUInstance、蒙皮骨骼**
  - **蒙皮**是指将Mesh中的顶点附着（绑定）在骨骼之上，而且每个顶点可以被多个骨骼所控制。
  - **骨骼**是皮肤网格内的不可见对象，它们影响动画过程中网格变形的方式。
  - 网格数据只有一份，只需要一次DrawCall，在GPU中实例化并做变换
  - GPU Skining：场景中有很多人物动画模型的时候，性能会产生大量开销。这些开销除了 Draw Call 外，很大一部分来自于骨骼动画。GPU Skining在CPU进行骨骼变换，将骨骼变换的结果传递给GPU，进行蒙皮
    - 提取骨骼数据，计算骨骼的变换矩阵，存入一张贴图
      - 模型空间中的顶点坐标变换到骨骼空间中（是骨骼矩阵的逆矩阵），然后应用当前骨骼的变换，沿着层级关系一层层地变换下去。
    - 运行过程中，拿到播放的长度去获取矩阵，在shader中蒙皮

- **状态同步、帧同步**
  - 状态同步把战斗逻辑放到服务器，客户端发送指令给服务器，服务器把结果计算完发给客户端同步
  - 帧同步把战斗逻辑放到客户端，服务器接受指令同时转发到其他客户端，由客户端运算同步
    - 数值的随机性。伪随机算法。服务器给客户端下发一个随机种子，通过自定义随机算法，保证每次的随机结果都是可控且一致的。
    - 逻辑执行顺序不一致。用成熟稳定的开源插件或者自己实现，**保证每个update都是自主可控的**。
    - 数学计算中的精度丢失。使用定点数替代浮点数，根据需求定一个比值参数（我们项目采用的是万分比）进行定点数和浮点数的转换。
  - 观战回放方面，帧同步只需要保存所有客户端指令，而状态同步需要有观战服，在服务端把消息发送给服务器同时转发到观战服，回放是把消息按时间发给客户端。

- **批处理**
  - 动态批处理：Unity自动处理，每一帧把可以进行批处理的模型网格进行合并，再把合并后模型数据传递给 GPU，然后使用同一个材质对其渲染。
    - 顶点属性规模小于900
    - 多Pass的shader会打断合批
  - 静态批处理：适用于任何大小的几何模型

- **Unity协程的原理**
  - 协程分为两部分，协程与协程调度器：协程仅仅是一个能够中间暂停返回的函数，而协程调度是在MonoBehaviour的生命周期中实现的。 准确的说，Unity只实现了协程调度部分，而协程本身其实就是用了C#原生的”迭代器方法“。
  - C#中的迭代器方法其实就是一个协程，你可以使用`yield`来暂停，使用`MoveNext()`来继续执行。 当一个方法的返回值写成了`IEnumerator`类型，他就会自动被解析成迭代器方法*（协程）*，你调用此方法的时候不会真的运行，而是会返回一个迭代器，需要用`MoveNext()`来真正的运行。

# Lua

- **Table**

  - 数组部分（紧凑且高效的随机访问）和哈希表部分（链表式存储）

- **pairs、ipairs**

  - 遍历数组
  - pairs：无序输出所有键值
  - ipairs：按序输出array部分的键值，直到索引n不存在

- **_\_index 、\_\_newindex**

  - index主要用于访问；lua表访问时，如果存在该值，则返回该值，如果没有则检查是否有index，有则接着查找元方法

  - newindex主要用于创建；当对table中不存在的索引赋值时，会查找newindex，如果有这个元方法，就调用这个元方法，而不是执行复制。如果这个元方法是一个table，解释器就在table中进行复制，而不是对原来的table。

    ```Lua
    local k = {}
    local mt = {
    	__newindex = k
    }
    
    local t = {}
    setmetatable(t, mt)
    
    t[1] = 20 --t中没有值，而值在k中
    ```

- rawset、rawget

  - rawset：在不触发元方法的情况下将table[index]设置为value
  - rawget：在不触发元方法的情况下获取table[index]的值

- **继承实现**
  ```Lua
  -- 元表实现
  Object = {class_id = 0}
  function Object:new(o)
      o = o or {}
      setmetatable(o,self) -- 对象o调用不存在的成员时都会去self中查找，而这里的self指的就是Object
      self.__index = self
  	return o
  end
  
  --闭包实现
  --Create an class.
  function class(classname, super)
      local superType = type(super)
      local cls
  
      if superType ~= "function" and superType ~= "table" then
          superType = nil
          super = nil
      end
  
      if superType == "function" or (super and super.__ctype == 1) then
          -- inherited from native C++ Object
          cls = {}
  
          if superType == "table" then
              -- copy fields from super
              for k,v in pairs(super) do cls[k] = v end
              cls.__create = super.__create
              cls.super    = super
          else
              cls.__create = super
          end
  
          cls.ctor    = function() end
          cls.__cname = classname
          cls.__ctype = 1
  
          function cls.new(...)
              local instance = cls.__create(...)
              -- copy fields from class to native object
              for k,v in pairs(cls) do instance[k] = v end
              instance.class = cls
              instance:ctor(...)
              return instance
          end
  
      else
          -- inherited from Lua Object
          if super then
              cls = clone(super)
              cls.super = super
          else
              cls = {ctor = function() end}
          end
  
          cls.__cname = classname
          cls.__ctype = 2 -- lua
          cls.__index = cls
  
          function cls.new(...)
              local instance = setmetatable({}, cls)
              instance.class = cls
              instance:ctor(...)
              return instance
          end
      end
  
      return cls
  end
  ```

- **Lua反射**
    - 利用全局变量表 `_G`
    在 Lua 中，全局变量存储在全局表 `_G` 中。你可以遍历 `_G` 来获取所有全局变量和函数的名称及其对应的值。例如：
    ```Lua
    for k, v in pairs(_G) do
        print(k, v)
    end
    ```
    - 使用元表（Metatable）
    Lua 的元表机制允许你为表定义自定义行为，比如对成员访问进行拦截，这在某种程度上可以实现反射效果。例如，我们可以为表定义 __index 元方法，以动态返回字段信息
    ```Lua
    local obj = {}
    local mt = {
        __index = function(table, key)
            print("访问字段:", key)
            return rawget(table, key)
        end
    }
    setmetatable(obj, mt)

    obj.name = "Lua"
    print(obj.name)  -- 输出时会触发 __index，从而打印出访问的字段信息
    ```
    - 利用 `debug` 库
    Lua 的 debug 库提供了一些调试和信息查询函数，可以用来获取函数的调用信息、局部变量、函数参数等。例如：
        - debug.getinfo(function)：获取函数的调试信息，如函数名、定义位置等。
        - debug.getlocal(level, index)：获取指定调用层次的局部变量信息。

- **弱引用**

  - __mode设置为k、v、kv
  - 不会增加引用对象的计数，也不会阻止被引用对象的垃圾回收。当被引用的对象只剩下弱引用时，它可以被垃圾回收器自动回收。
  - 当使用弱引用时，需要注意以下几点：
    1. 弱引用的生命周期：由于弱引用不会增加引用对象的计数，因此当引用对象只剩下弱引用时，垃圾回收器可能会立即回收该对象。因此，我们需要确保在需要使用引用对象时，弱引用仍然存在。
    2. 弱表的键和值的限制：Lua 的弱表只能以对象作为键或值，而不能使用基本类型（如数字、字符串等）作为键或值。
    3. 弱引用的使用场景：弱引用通常用于需要动态跟踪对象生命周期的情况，例如对象缓存、对象关联、观察者模式等。在这些场景中，弱引用可以自动处理对象的添加和删除，而不需要手动管理引用。
    4. 弱引用的性能影响：使用弱引用可能会带来一些性能开销，因为垃圾回收器需要额外的工作来处理弱引用。在性能敏感的情况下，需要评估弱引用的使用是否值得。

- **GC**

  - 增量式GC：标记清除
  - **每个GC周期由四个阶段组成，分别是标记(`mark`)、清理(`cleaning`)、清除(`sweep`)和析构(`finalization`)：**
    - 标记阶段把根节点集合(`root set`)标记为活跃，并且保存在活跃对象中的对象也是可达的，因此同样标记为活跃（弱引用表除外）。当所有可达对象标记完成后，标记阶段结束。
    - 清理阶段会处理析构器和弱引用表。Lua会遍历所有被标记为需要进行析构，且非活跃的对象，将这些对象放置在一个单独的列表中，供析构阶段使用。除此之外，还会遍历弱引用表，移除里面的弱引用的对象
    - 清除阶段Lua会遍历所有对象，如果一个对象没有被标记为活跃，则将其回收。如果这个对象被标记为活跃，则将标记清除，为下一轮GC做准备。
    - 析构阶段调用清理阶段被分离出的对象的析构器。
  - 分代式GC
  - 在分代GC模式中，垃圾收集器频繁的执行小型垃圾回收，每次都从最近创建的对象中进行扫描，清理其中的垃圾，而不是扫描所有对象。如果这种小型GC后内存仍然超出限制，它将暂停程序的运行，遍历所有对象进行GC。

- **upvalue、闭包**

  - upvalue是让lua来模拟实现，类似c语言中，静态变量机制的一种机制。一个带上upvalue的函数，我们称之为闭包(closure)。一个c函数，带上upvalue的结构，我们称之为c闭包。而一个lua函数，带上upvalue，我们称之为lua闭包
  - 运行函数时，Lua会创建一个新的数据对象，其中包含了相应的函数原型的引用、环境（查找全局变量的表）的引用和一个由所有upvalue引用组成的数组。这个对象叫做闭包
  
- **C#、lua交互**

  - 通过虚拟栈实现，栈的索引分正负，正则1代表栈底，负则-1代表栈顶

  - C#调用Lua：由C#把数据放到栈中，由lua去栈中获取数据，然后返回数据对应的值到栈顶，再由栈返回到C#。

  - Lua调用C#：先生成C#源文件对应的Wrap文件或者编写C#源代码所对应的C模块，然后将源文件内容通过Wrap或C模块注册到Lua解释器中，然后由Lua去调用这个模块的函数。

  - C#传递对象到Lua：

    - lua本身提供了C_API,让我们push一个值到lua虚拟栈上。lua可以通过访问lua虚拟栈，来访问这个对象。各种**lua_pushXXX**的接口。Lua虚拟栈是lua和其他语言交换数据的中介。

    - xlua的push API归为两类：一类是针对某种特定类型的push，暂且叫做**LowLevelAPI**；还有一类是基于LowLevelAPI封装的更上层的**HighLevelAPI**。HighLevelAPI会帮你找到最适合的LowLevelAPI调用

      ```C#
      //LowLevel
      PushObject
      PushPrimitive
      PushDecimal
      ...
      
      //HightLevel
      根据对象类型来调用对应push方法，if else判断
      ```

    - 当传递一个c#对象的时候，我们创建一个userdate，并把这个索引值赋给这个userdata。然后，lua在全局注册表中，有一张专门的表用来存放c#各种类型所对应的元表，而**meta_ref**就是当前这个对象所对应类型的元表的索引id，我们通过他找到对应的元表，就可以通过setmetatable来绑定操作这个对象的方法。最终lua就可以愉快的使用这个对象。

    - gc：由lua的gc驱动的。

    - 我们把对象push到lua时，会缓存在c#的对象池中，所以是不会被mono的gc所释放掉，这样就保证了lua能够安全的持有c#对象。同时我们也会把这个对象的代理缓存到lua中，而lua中对象的缓存表是一个弱表，也就是说，当没有其他的lua引用这个对象时，lua的gc会把这个对象从lua的缓存中回收，而对象被gc回收的过程会触发这个对象的的*__gc*元方法。而这个*__gc*元方法就会通知到c#这端，来告诉我们lua不再使用这个对象，我们可以把它从对象缓存池中移除。当没有其他c#对其的引用时，mono的gc就会正常的回收这个对象。

    - 传递函数主要是指*LuaCSFunction*，也就是可以被lua直接调用的c#函数。普通的c#函数也可以传递，属于前面的基元类型，只是简单的传递一个IntPtr指针，虽然不能直接被lua调用，但是可以被lua传递（函数式编程，比如作为回调和返回值）。

    - 当我们push一个LuaCSFunction函数到lua中后，这个函数和栈上的参数会被当作另一个包装函数*csharp_function_wrap*的upvalue，生成一个闭包，最终把这个闭包push到lua虚拟栈上。

- **lua热更新**

  - 项目上，根据目录结构把所有代码文件载入全局（文件路径和类映射），然后访问时从全局环境中访问，查找不到就报错。热更时把规定的目录文件代码全部卸载（package.loaded），然后按照之前的文件映射重新加载。（未考虑新增文件的处理，也未考虑upvalue的清理，开发周期上已经满足要求，生产环境还需要更加精细的控制）
  - 新增热更可以把进程关闭

- Socket流程