---
layout: post
title: 计算机网络八股
date: 2024-04-08 13:43:16
categories: 计算机网络
tags: ['计算机网络','计算机科学技术','面试相关','八股文']
copyright_author: 时光
katex: true
hidden: true
---
面试频率
- 五星：红色
- 四星：黄色
- 三星：绿色
- 两星：蓝色
- 一星：紫色

# 计算机网络体系结构

{% note info 计算机网络分层的好处 %}
1. 各层之间相互独立、相关隔离。每层只考虑当前层如何实现，无需考虑其他层
2. 提高整体结构的灵活性，层次之间结构解耦合
3. 大问题变小，复杂问题变简单
{% endnote %}

{% note danger **计算机网络为什么要分层** %}
计算机网络是个非常复杂的系统，相互通信的两个计算机必须高度协调工作，但是这种协调是很复杂的。
分层可以将庞大复杂的问题，转化成若干个较小的局部问题，这些局部的较小的问题就比较易于研究和处理。
{% endnote %}

{% note danger **计算机网络是怎么分层的** %}
计算机网络中，我们为不同类型的事件划分了“层(layer)”的概念，每层通过特定的协议提供相应的服务，组成了计算机网络体系结构（即分层结构）。其中：
1. 各层之间相互独立，每层只实现一种相对独立的功能
2. 每层之间界面自然清晰，易于理解，相互交流尽可能少
3. 结构上相互分离，每层都采用最合适的技术来实现
4. 保持下层对上层的独立性，上层单向使用下层提供的服务
5. 整个分层结构应该能促进标准化工作
{% endnote %}

{% note warning OSI七层模型的每一层 %}
口诀：物联网叔会使用
1. 应用层：通过**应用程序**间的交互来完成特定的网络应用
2. 表示层：解释交换数据的**含义**。该层提供的服务主要包括**数据压缩**，**数据加密**以及**数据描述**。
3. 会话层：负责建立、管理和终止表示层实体之间的**通信会话**。该层提供了数据交换的定界和同步功能，包括了建立**检查点**和恢复方案的方法。
4. 传输层：负责因特网中两台主机的**进程**提供通信服务。
5. 网络层：选择合适的**网间路由**和**交换节点**，确保数据按时成功传送。
6. 数据链路层(链路层)：数据链路层将网络层交下来的 IP 数据报组装成**帧**，在两个相邻节点间的**链路上传送帧**。
7. 物理层：实现计算机节点之间比特流的**透明传送**，尽可能屏蔽掉具体传输介质和物理设备的差异。该层的主要任务是确定与传输媒体的接口的一些特性（机械特性、电气特性、功能特性，过程特性）
{% endnote %}

{% note danger 五层体系结构中的每一层 %}
五层体系的协议结构是综合了 OSI 和 TCP/IP 优点的一种协议，包括应用层、传输层、网络层、数据链路层和物理层。其中应用层对应 OSI 的上三层，下四层和 OSI 相同。五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是 TCP/IP 四层体系结构。
1. 应用层：为特定**应用程序**提供数据传输服务。
2. 传输层：为**进程**提供通用数据传输服务。
3. 网络层：为**主机**提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。
4. 数据链路层：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是**为同一链路的主机**提供数据传输服务。
5. 物理层：负责比特流在**传输介质**上的传播。
{% endnote %}

{% note danger **三种计算机网络模型的关系是什么** %}
五层体系的协议结构是综合了 OSI 和 TCP/IP 优点的一种协议，包括应用层、传输层、网络层、数据链路层和物理层。其中应用层对应 OSI 的上三层，下四层和 OSI 相同。五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是 TCP/IP 四层体系结构。

<img src="https://img10.360buyimg.com/ddimg/jfs/t1/241758/29/7032/37745/66138988Fc58692d0/ed7675035a8ed2e7.jpg" alt="image.png" title="image.png" />

{% endnote %}

{% note danger **每一层分别包含哪些协议** %}
<img src="https://img10.360buyimg.com/ddimg/jfs/t1/241758/29/7032/37745/66138988Fc58692d0/ed7675035a8ed2e7.jpg" alt="image.png" title="image.png" />
{% endnote %}

{% note warning **数据如何在各层中传播** %}
<img src="https://img13.360buyimg.com/ddimg/jfs/t1/247333/28/7068/25547/661389d1F0206a9f5/f5a7dd3fd2a6fe08.jpg" alt="image.png" title="image.png" />

假设一个主机上的一个应用向另一个主机的一个应用发送数据，所经历的流程将如上图所示。

1. 在发送主机端，一个**应用层报文**被传送到**传输层**。在最简单的情况下，传输层收取到报文并附上附加信息，该首部将被**接收端**的传输层使用。
2. 应用层报文和传输层首部信息一道构成了**传输层报文段**。附加的信息可能包括：允许接收端传输层向上向适当的应用程序交付报文的信息以及差错检测位信息。该信息让接收端能够判断报文中的比特是否在途中已被改变。
3. 传输层则向网络层传递该报文段，网络层增加了如**源和目的端系统地址**等网络层首部信息，生成了**网络层数据报文**。
4. 该数据报文接下来被传递给链路层，在数据链路层数据包添加发送端 MAC 地址和接收端 MAC 地址后被封装成**数据帧**。
5. 在物理层数据帧被封装成**比特流**，之后通过传输介质传送到对端。而在接收主机端，整个过程正好反过来。
{% endnote %}

{% note warning **数据在网络各层中的存在形式** %}
1. 应用层：报文
2. 传输层：报文段/数据段
3. 网络层：数据报/数据包
4. 数据链路层：帧/数据帧
5. 物理层：比特流
{% endnote %}

# 应用层
{% note success uri和url的区别 %}
网络上的资源必须有一个**唯一**的表示，才可以在网络上被访问。常见的几种表示如下：
- uri(uniform resource identifier) 统一资源**标识符**。
- url(uniform resource location) 统一资源**定位符**，统指绝对路径。
- urn(uniform resource name) 统一资源**名**。

三者之间关系为， url 和 urn 分别是 URI 的**子集**。
统一资源标志符URI就是在某一规则下能把一个资源独一无二地标识出来。url是通过路径的方式进行标识的，是url的**一种实现方式**。就像我们可以用中华人名共和国居民身份证标识每一个中国人，也可以通过地址（如：动物住址协议://地球/中国/浙江省/杭州市/西湖区/某大学/14号宿舍楼/525号寝/张三）标识。

<img src="https://img11.360buyimg.com/ddimg/jfs/t1/247857/27/7205/4620/66138fa7Fedc84ebd/1d5bd53073f70d35.jpg" alt="image.png" title="image.png" />

{% endnote %}

{% note success 获取网络资源 %}
1. 一般是访问资源使用的协议类型，比如http://、https://。
2. 服务器的 web 地址，可以为域名或者 ip 地址 + 端口号，比如 localhost:8080 或者 127.0.0.1:8080。不添加默认为 80 ，这是访问域名不用加端口号的原因 。
3. web 服务器上的某个资源，比如leetbook/read/networks-interview-highlights。

> 注意：url是否以"/"结尾，意义是不同的，用户无感知的原因是因为服务器自动处理了这种差异。
{% endnote %}

{% note info 应用程序体系架构 %}
应用程序体系体系架构主要分为两种。
- C/S(client/server) ：客户端之间不进行通信，客户端向**服务端**发送请求获取数据，服务器要一直开机，需要配备大量的数据中心。比如：微信，google，bing等等。C/S可以更好地实现资源共享，并且能解决通信异步的问题。链路上只传输请求命令和执行结果，从而降低通信开销。
- P2P(peer to peer) ：对等通信，不需要数据中心，没有客户端和服务端的区别，应用程序在间断连接的主机对之间直接通信。主要应用在流量密集型应用。比如：迅雷，bitTorrent，或者在局域网的文件内部共享应用中。

目前大型互联网应用主要采用的是 C/S 架构，导致 P2P 架构逐渐被人遗忘。 C/S 架构又可以细分为 C/S(client/server) 和 B/S(browser/server)，即根据客户端类型划分。
- 本地客户端：速度快，安全，灵活性较高，但是开发成本就高，比如游戏客户端。
- 浏览器：不需要安装，依托于浏览器，安全性较低，成本极低。

目前很多应用既可以通过本地客户端访问也可以通过浏览器使用。比如，微信，outlook等等。
{% endnote %}

{% note success web的结构组件 %}
web 是极为复杂的，不仅只有 client 与 server 之间简单的请求响应 ，还包含了一些特殊的 server ，他们承担着一些特殊的作用。

- 代理：位于客户端和服务器之间的 http中间实体。
出于安全考虑，通常会将代理做为转发所有 Web 流量的可信任中间节点使用，可以对请求和响应进行过滤。比如，校园网中可以过滤一些不健康的内容，禁止学生进行访问。

![image.png](https://oss.suning.com/mbap/mbapbk/4e74ad19ca03eafb414b0907f98caf4e.png?SDOSSAccessKeyId=42IA0GY51YZ1397N&Expires=1717845762&Signature=KI7O%2FBYWdmWA5%2FgAPziRTWPKLLM%3D)

- 网关：连接其他应用程序的特殊 web 服务器。
做为其他服务器的中间实体使用。常用于将 http 流量转化为其他的协议。网关接受请求时就好像自己本身是资源源服务器一样，客户端对此无感知。

![image.png](https://oss.suning.com/mbap/mbapbk/3e5ece81e56c0dd708fd363db0f6e406.png?SDOSSAccessKeyId=42IA0GY51YZ1397N&Expires=1717845795&Signature=3u8snvMnn5Cjh4cJhAJVwDNzETQ%3D)

- 隧道： 对 http通信报文进行盲转发的特殊代理。
对两条连接之间的数据进行盲转发，https就是通过隧道实现的。http连接承载加密的安全套接字层`(ssl,secure sockets layer)流量，这样 ssl 流量就可以直接穿过只允许 web 流量通过防火墙，反正亦然。

![image.png](https://oss.suning.com/mbap/mbapbk/5ed79701317ab72d3bb6710ab159a91b.png?SDOSSAccessKeyId=42IA0GY51YZ1397N&Expires=1717845844&Signature=9MCoGY%2B7twu1hHT24vM0kYbjeH0%3D)

{% endnote %}

{% note danger dns是啥工作原理，主要解析过程是什么 %}
域名系统 (dns,domain name system) 是 Internet 或其他 Internet 协议（ip） 网络中计算机、服务和其他资源的分层分布式命名系统。它将各种信息与分配给每个关联实体的域名相关联。最重要的是，它将容易记忆的域名转换为数字ip地址，用于定位和识别具有底层网络协议的计算机服务和设备。DNS采用的是C/S架构。

1. dns的作用
在dns 出现之前，互联网中某台主机的唯一标识是这台机器的 ip 地址，但是这种方式记起来很麻烦，人们更喜欢便于记忆的名称。为了解决这个问题，人们需要一种从主机名称到 ip 地址转换的服务，域名系统作为将域名和 ip 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。
> 小提示：dns域名支持中文字符

2. dns服务器的结构
dns域名的结构是 xxx.xxx.xxx，是分层的。分为顶级域名（一级域名），二级域名，三级域名 . . . . .
顶级域名会根据国家地区，或者组织进行划分,比如cn（代表中国）、edu（代表教育组织）。二级域名就是在顶级域名前面加前缀,比如 leetcode.cn。也正因为如此，dns服务器的结构是树状的。
域名以及服务器结构如下：
![image.png](https://oss.suning.com/mbap/mbapbk/688ed4a3757999db271179914dd7bffe.png?SDOSSAccessKeyId=42IA0GY51YZ1397N&Expires=1717846000&Signature=n89MArtyKbXZByojTGYkimrJyi0%3D)

3. dns的原理
以一个例子来了解 dns 的工作原理。
假设一个客户端 A，想要查询 a.leetcode.cn 的 ip 地址，考虑缓存的情况。
    - 客户端 A 首先查询本地的 hosts 文件，查询是否有网址映射关系，如果没有，进行下一步查找。
    - 查找本地的 dns 解析器缓存，如果没有进行下一步。
    - 根据 tcp/ip 参数查找设置好的首选 dns 服务器 ip 地址，一般叫做本地 dns 服务器，查询本地 dns 服务器。本地 dns 服务器如果没有，它就会进行下一步操作。
    - 本地dns会访问根服务器 ，然后根据后缀名，从根服务器中查找对应的顶级域名服务器的 ip ，然后以此向下查找域名服务器的 ip ，然后查找网址映射关系,直到找到为止。
![image.png](https://oss.suning.com/mbap/mbapbk/1c5dc910549a8f9a49087608c03d46ea.png?SDOSSAccessKeyId=42IA0GY51YZ1397N&Expires=1717846095&Signature=k2Uzu%2Bx0JbQgXWtpk%2BqfCyzPLHQ%3D)
> 客户端 A 向本地域名服务器查询为递归查询，本地域名服务器向根域名服务器查询为迭代查询。

4. dns 数据传输
dns 的数据传输既采用 udp 协议也采用 tcp 协议。
- dns 是通过 53 端口进行通信，默认是采用 udp 协议进行数据传输的，除了个别情况，也就是说绝大多数情况是采用 udp 进行传输。
- 使用 tcp 传输的情况:
    - 当返回的响应超过的 512 字节（ udp 最大只支持 512 字节的数据）。
    - 区域传送：主域名服务器向辅助域名服务器传送变化的那部分数据。

> 注意: tcp 协议和 tcp 协议是可以同时绑定同一个端口的。
区域传输: dns 服务器中数据不总是一成不变的，域名数量是不断增加，而且一些域名对应着的服务器的也是在变化的，所以其实 dns 服务器中的数据是不断增加的，并且随时流动的，所以可以将区域传输简单理解为 dns 服务器之间进行的数据传输。

5. dns 域名服务器名称概念
- 根域名服务器：最高层次的域名服务器，所有的根域名服务器都知道所有的顶级域名服务器的ip地址，全球有 13 个根域名服务器。
- 顶级域名服务器：负责处理所有顶级域名，提供到权威域服务器的映射。
- 授权(权威)域名服务器：提供主机名到 IP 地址间的映射服务
- 主域名服务器：一个或多个区域域名解析工作的主要域名服务器，通常也是一个或多个区域的授权域名服务器。
- 辅助域名服务器：协助主域名服务器提供域名查询服务，在主机很多的情况下，可以有效分担主域名服务器的压力。当主域名服务器故障时，辅助域名服务器能够在数据有效期内继续为主机提供域名解析服务。

{% endnote %}

{% note danger 用户输入网址到显示对应页面的全过程是什么 %}
![image.png](https://oss.suning.com/mbap/mbapbk/4e89b0b2ae7bbe60b324d915ef79871e.png?SDOSSAccessKeyId=42IA0GY51YZ1397N&Expires=1717846250&Signature=Xq%2FJZvRKlrzXyvw88aXBWH7HYd8%3D)
1. dns 解析：访问一个网站时，浏览器获得一个域名，通过 dns 服务将域名解析为 ip 地址。
2. tcp 连接：向 Web 服务器发起 tcp 连接请求。
3. 发送 http 请求：浏览器向 Web 服务器发起一个 http 请求，http 协议是建立在 tcp 协议之上的应用层协议，其本质是在建立起的 tcp连接中，按照 http 协议标准发送一个索要网页的请求。
4. 处理请求并返回：服务器获取到客户端的 http 请求后，会根据 http 请求中的内容来决定如何获取相应的文件，并将文件发送给浏览器。
5. 浏览器渲染：浏览器根据响应开始显示页面，首先解析 html 文件构建 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。
6. 断开连接：客户端和服务器断开连接。
{% endnote %}

{% note danger http头部 %}
http 主要有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。除此之外，还有一种扩展首部，该种首部还未添加的 http 标准中去。在一些大型互联网公司内部，开发者需要特定的扩展首部来实现特殊的功能。
- 通用首部字段：请求和响应都可以使用的首部，与报文相关的最基本的信息。
- 请求首部字段：仅在请求中使用的首部。
- 响应首部字段：仅在响应中使用的首部。
- 实体首部字段：用于应对实体部分的首部，一般是对实体内容进行说明。

常用的首部
- 通用首部
![image.png](https://oss.suning.com/mbap/mbapbk/c06cbf45dc6e670374b457e947c53e71.png?SDOSSAccessKeyId=42IA0GY51YZ1397N&Expires=1717848196&Signature=COlURWnaQ5QrT%2BD4368CeLsXUnU%3D)

- 请求首部

![image.png](https://oss.suning.com/mbap/mbapbk/32df31a13754115eb2e235a856411a99.png?SDOSSAccessKeyId=42IA0GY51YZ1397N&Expires=1717848325&Signature=BNvnhGPK%2BuD6mrUIWD0fhYYnNGM%3D)

- 响应首部

![image.png](https://oss.suning.com/mbap/mbapbk/aa1f8545914fb41eb0193539e27cefb4.png?SDOSSAccessKeyId=42IA0GY51YZ1397N&Expires=1717848306&Signature=M37%2FCqDr4g9YDl4HrIf0%2BvFQg7k%3D)

- 实体首部

![image.png](https://oss.suning.com/mbap/mbapbk/98626a743afab91f08048b616ccc3a6d.png?SDOSSAccessKeyId=42IA0GY51YZ1397N&Expires=1717848284&Signature=pvaVuM%2FAxFJ1ejhiSz78I6jkPS4%3D)

> http请求首部目录：https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers

与状态码一样，对于 http 首部，只要记住几个常用的就可以
{% endnote %}

{% note danger http状态码有哪些 %}
![image.png](https://oss.suning.com/mbap/mbapbk/9fcd5b9f9b5c53a630fc7be90eb1b8f4.png?SDOSSAccessKeyId=42IA0GY51YZ1397N&Expires=1717848101&Signature=FrcQ%2BS%2Bw4MANXvVzOqHmiXW1I4Q%3D)
比较常见的状态码(面试只需要了解以下状态码即可)

- 200：成功返回响应
- 301：永久重定向，客户端第一次访问此 url 时，告知客户端以后直接访问新的 url，该状态保存在浏览器缓存中。
- 302；临时重定向，客户端每次访问此 url 时，告知客户端重定向到新的 url ，后续访问依然访问当前的 url。
- 400：发送的请求错误，请求格式错误，或者没有服务器要求的数据。
- 401：没有权限访问，当前用户没有权限访问此资源。
- 403: 请求被服务器禁止。
- 404：请求的 url 不存在，一般是 url 出错。
- 500： 服务器处理请求出现错误。
- 501：服务器超出能力之外的方法，例如：请求的方法服务器不支持。
- 504：来自网关或者代理服务器，请求资源服务器时超时。

> http状态码目录：https://developer.mozilla.org/en-US/docs/Web/HTTP/Status

与请求方法一样，http 状态码也是为了方便开发的一种标准，大部分的服务器在大范围上都是遵循该标准的。但是不能保证所有服务器严格遵循此标准，毕竟状态码只是服务器返回数据中的一部分，一些自定义的服务器可能对于所有的 5XX 类型错误都返回 500 状态码。
{% endnote %}

{% note danger http请求方法 %}
![image.png](https://oss.suning.com/mbap/mbapbk/183e65b5d6230a2cf4e7543aa2b640b0.png?SDOSSAccessKeyId=42IA0GY51YZ1397N&Expires=1717848723&Signature=SfPDOTddvPlZr5GNMy3%2Fc%2BcxXOU%3D)

http 请求方法是为了服务器功能实现起来更方便，但不意味着每种特定的方法只能实现某种特定的功能。http 方法设计较为灵活，方法本身虽然有一些规则，但是最重要的还是开发者如何开发设计，正因为如此，不同的浏览器和不同的服务器会有一些限制，但是这和 http 方法关系不大。比如：

- 有些服务器不支持get 方法设置 body，对于这种服务器，get 方法通常是通过以 url 的 parameters 或者 Anchor 进行传递数据的

![image.png](https://oss.suning.com/mbap/mbapbk/7641ff0025093848f8f4dfb396b284e1.png?SDOSSAccessKeyId=42IA0GY51YZ1397N&Expires=1717848536&Signature=jNZP4O0d4yCtLZHHAYa0c9LQV8w%3D)

也就是说 get 方法传递数据的大小和 url 的长度直接相关，url 本身并没有对长度进行限制，但是浏览器会对 url 进行限制，比如 FireFox 限制 url 的最大长度为 65536 个字符，也就是 64KB的大小，而 Chrome 限制 url 最大长度为 8182个字符，也就是 8 KB 的大小。
- post 方法向服务器发送数据是通过 body ，post 方法本身对 body 的大小也没有限制，但是不同的服务器处理的能力是不同的，较为强大的服务器可以接收几十 GB 的数据，而一些服务器最多只能接收几十 MB 的数据。
{% endnote %}

{% note danger get 和 post的区别 %}
- get 提交的数据会放在 url 之后，post 提交的数据放在 body 上。
    - get请求参数会以 url 的形式完整的保留在浏览器的记录里，会存在安全问题。而 post 数据放在请求主体中，且数据不会被浏览器记录，相比 get 方法，post 方法更安全，主要用于修改服务器上的资源。
    > 注意：http有安全方法的概念，即不改变服务器状态。 get 方法不会改变服务器状态，而 post 会改变服务器的状态，从这个角度来看，get方法更安全。
总结：get 方法对于服务器更安全，post 方法对于客户端更安全.

    - post 可以进行复杂的加密，get 则不可以
    - get 只支持 ASCII 字符格式的参数，而 post 方法没有限制。
    - get 提交的数据大小有限制（这里所说的限制是针对浏览器而言的），而 post 方法提交的数据理论上没限制

- get 方法具有幂等性，post 方法不具有。
> 幂等性，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。

- post方法有时会发送两个 tcp 数据包，与浏览器有关
    - 使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。
    - 而 GET 方法 Header 和 Data 会一起发送
    > XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。
{% endnote %}

{% note danger http和https的区别 %}
1. https: 使用价格昂贵;速度稍慢;默认端口为 443;通信安全。
2. http： 免费;速度稍快;默认端口为80;通信不安全。

http具有以下风险：
- 使用明文通信，内容可能会被窃听
- 不验证通信方的身份，通信方的身份有可能遭遇伪装
- 无法证明报文的完整性，报文有可能遭篡改

所以引入了 https，通过 **ssl**(Secure Sockets Layer)/**tls**(Transport Layer Security) 的方式使 http 变成了安全的 https。
- http 数据发送时 request 直接通过 tcp 发送；数据接收时，tcp 接收的数据作为 response
- httpsv数据发送时 request 通过 ssl/tls 进行处理，然后再通过 tcp 进行发送；数据接收时，同样也是要通过 ssl/tls 进行处理。相当于在应用层 http 和传输层 tcp 之间多加了一步处理

![image.png](https://oss.suning.com/mbap/mbapbk/54df99e59154ad56f84a413b0d204ab2.png?SDOSSAccessKeyId=42IA0GY51YZ1397N&Expires=1717849434&Signature=UVqHgXWcdCrtN1Q%2BUjV8xIyLuHM%3D)

> 注意：http3.0 传输协议已经从 tcp切换为 udp
{% endnote %}

{% note danger https的加密方式 %}
https通过以下方式处理安全问题：
1. 数据加密
加密方式有两种：对称加密和非对称加密
    - 对称加密：加密和解密使用同一密钥。运算速度快，但无法安全地将密钥传输给数据接收方。
    - 非对称加密：加密和解密使用不同密钥。
非对称加密的密钥分为公钥和私钥，公开密钥所有人都可以获得，数据发送方获得接收方的公开密钥，通过公开密钥进行加密，接收方收到数据后，通过私有密钥解密，获取数据内容。这种方式更安全一点，但运算速度很慢

https 的数据加密分别利用了这两种加密方式的优点。首先通过非对称加密，传输对称加密所需的密钥，然后使用密钥进行通信加密。这样既兼顾了安全性，又有了更高的运算速度。这个流程看似完美无瑕，但其实过程中第一步发送方获取的公开密钥可能被篡改。可以通过数字证书的方式来解决这个问题。

![image.png](https://oss.suning.com/mbap/mbapbk/7149fca3b4d8d3c85077729f4ba8bcb6.png?SDOSSAccessKeyId=42IA0GY51YZ1397N&Expires=1717849611&Signature=Ofi8NtOtBGZNrljHy9UGtDA2DME%3D)

2. 数字证书认证
数字证书认证机构 (CA, Certificate Authority) 是客户端和服务器双方都信任的第三方机构
    - 服务器事先向数字证书机构申请数字证书，数字证书机构对数据做数字签名，然后将数据和数字签名打包在一起，做成数字证书，发送给服务端
    - https通信时，服务器把数字证书发给客户端。客户端取得其中的数据和数字签名，使用数字证书机构的公开密钥验证数据和数字签名是否合法

这里数字证书机构的公开密钥不是通过网络获取，而是事先在浏览器内部植入的。浏览器事先会植入常用认证机构的公开密钥。
数字证书中数据可以包含很多的信息。比如：服务端的身份信息，可以非对称加密的公开密钥等等
通过这种方式，即能验证了通信方身份，也可以实现安全加密。

3. 通过 ssl/tls 报文摘要功能检验报文完整性
    - http 也提供了 MD5 报文摘要功能，但不是安全的。因为MD5报文摘要的值也是可以被篡改的
    - https 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作；加密 + 摘要检验 + 认证 = 数据完整
{% endnote %}

{% note danger http是不保存状态的协议，如何保存用户状态 %}
http 是一种不保存状态，即无状态协议。http 协议自身不对请求和响应之间的通信状态进行保存。也就是说 http 协议对于发送过的请求和接受过的请求都不做持久化处理，这样可以更快地处理大量事物，确保协议的可伸缩性。
http 不保存状态，那么服务端是如何知道请求是那个客户端发送过来的呢？解决方案有很多种，我们介绍一下最简单的两种。
1. session 的形式
    - 客户端第一次发送信息到服务器时，服务器为该客户端创建一个 session 对象，该 session 包含客户端身份信息，同时为该 session 生成一个 sessionId 。
    - 服务端将这个 sessionId 分配给客户端，客户端发送请求时带有此 sessionId ，服务端就可以区分客户端。

2. cookie 的形式
    - 客户端第一次发送信息到服务器时，服务器根据该客户端信息编码加密生成一个 cookie。
    - 服务端将此 cookie 发送给客户端，客户端发送请求时带有此 cookie ，服务端就可以区分客户端。

服务器将 cookie 和 sessionId 发送给客户端时是通过 set-cookie 首部，客户端将两个字断发送给服务器是通过 cookie 首部。发送请求时，cookie 首部可以包含多个服务端的 cookie，服务端接收请求时，取出自己所需的 cookie。
cookie 首部包含的信息如下：

![image.png](https://oss.suning.com/mbap/mbapbk/7c5386cdaf1fef99eb6a55e64add4183.png?SDOSSAccessKeyId=42IA0GY51YZ1397N&Expires=1717848948&Signature=xPgpNLhEMZ4cfcXQ%2Fs%2BhZhxFLWU%3D)

- 客户端禁用 cookie 首部时，如何传递 cookie 信息？
可以将 cookie 信息放到 url 的 params 中或者请求的 body 中，但一般的解决方案是放在 url 的 params 中，通过重写 url 的方式传递。
- cookie 和 session 两种解决方案的区别
    - session 解决方案需要在服务端存储客户端的数据，分布式服务器需要设置单独且唯一的数据中心，占用资源较大。但是客户端携带的 sessionId 不包含的用户信息，较为安全。
    - cookie 的解决方案不需要在服务器存储客户端的数据，占用资源较小，可拓展性较高；请求携带的cookie 携带着用户信息，相对来说，没那么安全 ；从数据量上来看，cookie 一般都比 sessionId 大，传输过程中占用较大资源。
{% endnote %}

{% note success http不同版本的区别 %}
- http 0.9,
http 于 1990 年问世。那时的 http 并没有作为正式的标准被建立。 现在的 http 其实含有 http1.0 之前版本的意思，因此被称为 http/0.9。
- http 1.0: http 第一个正式版本。
- http 1.1, 相比于 http1.0 的新特性。
    - 默认是长连接，并且支持流水线，支持同时打开多个 TCP 连接，客户端需要使用多个连接才能实现并发和缩短延迟。
    - 支持虚拟主机，新增状态码 100，支持分块传输编码，新增缓存处理指令 max-age。
    - 不会压缩请求和响应首部，占用不必要的网络流量。
    - 不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。
- http 2.0, 相比于 http1.1 的新特性。
    - 相比于 http/1.1 的文本（字符串）传送， http/2.0 采用二进制传送。客户端和服务器传输数据时把数据分成帧，帧组成了数据流，流具有流 ID 标识和优先级，通过优先级以及流依赖能够一定程度上解决关键请求被阻塞的问题。
    - http/2.0 支持多路复用。因为流 ID 的存在， 通过同一个 http 请求可以实现多个 http 请求传输，客户端和服务器可以通过流 ID 来标识究竟是哪个流从而定位到是哪个 http 请求。
    - http/2.0 头部压缩。http/2.0 通过 gzip 和 compress 压缩头部然后再发送，同时通信双方会维护一张头信息表，所有字段都记录在这张表中，在每次 http 传输时只需要传头字段在表中的索引即可，大大减小了重传次数和数据量。
    - http/2.0 支持服务器推送。 服务器在客户端未经请求许可的情况下，可预先向客户端推送需要的内容，客户端在退出服务时可通过发送复位相关的请求来取消服务端的推送。
- http 3.0
http3.0 是在 quic(quick udp internet connection) 基础上发展起来的，其底层使用 udp 进行数据传输，上层仍然使用 http/2.0。在 udp 与 http/2.0 之间存在一个 quic 层，其中 tls 加密过程在该层进行处理。http/3.0 主要有以下几个特点：
    - 使用 UDP 作为传输层进行通信。
    - 在 UDP 之上的 QUIC 协议保证了 HTTP/3 的安全性。QUIC 在建立连接的过程中就完成了 TLS 加密握手。
    - 建立连接快，正常只需要 1 RTT 即可建立连接。如果有缓存之前的会话信息，则直接验证和建立连接，此过程 0 RTT。建立连接时，也可以带有少量业务数据。
    - 不和具体底层连接绑定，QUIC 为每个连接的两端分别分配了一个唯一 ID，上层连接只认这对逻辑 ID。网络切换或者断连时，只需要继续发送数据包即可完成连接的建立。
    - 使用 QPACK 进行头部压缩，因为 在 HTTP/2 中的 HPACK 要求传输过程有序，这会导致队头阻塞，而 QPACK 不存在这个问题。
{% endnote %}

{% note warning websocket %}
一般的 web 程序是 c/s 架构，也就是说服务端不能主动给客户端发送数据。只有当客户端向服务端发送请求时，服务端才可以向客户端返回响应。但是很多场景下都需要服务端直接向客户端发送请求，比如进行服务推送。面对这种情况，一般的处理方案是客户端轮训服务端，客户端不断向服务端发送请求。这种方式的效率是十分低下，并且占用大量的计算资源，即包括客户端资源也包括服务器资源。

websocket 的出现就是为了解决这个问题。websocket，即 web 浏览器与 web 服务器之间全双工通信标准。其中，websocket 协议由 IETF 定为标准，WebSocket API 由 W3C 定为标准。

> 通信方式：
>- 单工通信：单向传输
>- 半双工通信：双向交替传输
>- 全双工通信：双向同时传输

websocket 的特征：
1. 建立在 tcp 协议之上。
2. 与 http 协议有着良好的兼容性。默认端口也是 80 和 443 ，并且握手阶段采用 http 协议，因此握手时不容易屏蔽，能通过各种 http 代理服务器。
3. 数据格式比较轻量，性能开销小，通信高效。可以发送文本，也可以发送二进制数据。
4. 没有同源限制，客户端可以与任意服务器通信。
{% endnote %}

{% note info 网络编程socket %}
套接字 (Socket) 是对网络中不同主机上的应用进程之间进行通信的接口，网络进程通信的一端就是一个套接字，不同主机上的进程便是通过套接字发送报文来进行通信。例如 tcp 用主机的 ip 地址 + 端口号作为 tcp 连接的端点，这个端点就叫做套接字。

套接字主要有以下三种类型：
- 流套接字(tcp 套接字）：流套接字基于 tcp 传输协议，tcp协议发送数据流。主要用于提供面向连接、可靠的数据传输服务。由于 tcp 协议的特点，使用流套接字进行通信时能够保证数据无差错、无重复传送，并按顺序接收，通信双方不需要在程序中进行相应的处理。
- 数据报套接字(udp套接字)：数据报套接字基于 udp 传输协议，udp 协议发送数据报。对应于无连接的 udp 服务应用。该服务并不能保证数据传输的可靠性，也无法保证对端能够顺序接收到数据。此外，通信两端不需建立长时间的连接关系，当 udp 客户端发送一个数据给服务器后，其可以通过同一个套接字给另一个服务器发送数据。当用 udp 套接字时，丢包等问题需要在程序中进行处理。
- 原始套接字：由于流套接字和数据报套接字只能读取 tcp 和 udp 协议的数据，当需要传送非传输层数据包（例如 Ping 命令时用的 ICMP 协议数据包）或者遇到操作系统无法处理的数据包时，此时就需要建立原始套接字来发送。
{% endnote %}

{% note info 内容分发网 CDN %}
内容分发网络(Content distribution network，CDN)是一种互连的网络系统，它利用**更靠近用户的服务器**从而更快更可靠地将 html、css、javascript、音乐、图片、视频等静态资源分发给用户。

CDN主要有以下优点：
- 更快地将数据分发给用户；
- 通过部署多台服务器，从而提高系统整体的带宽性能；
- 多台服务器可以看成是一种冗余机制，从而具有高可用性。
{% endnote %}

{% note info 抓包软件原理 %}
网络数据在网络中传输，无论如何都要经过网络节点，假如需要监控客户端与服务器交互之间的网络节点，监控其中任意一个网络节点（网卡），获取所有经过网卡中的数据，对这些数据按照网络协议进行解析，这就是抓包的基本原理。而中间的网络节点不受我们控制，是基本无法实现抓包的，因此只能在客户端与服务器之间进行抓包
{% endnote %}

{% note info 常用协议及其端口 %}
对于应用层来说，考察的重点集中在 http 协议和 dns 这两块，其他协议考察较少，我们仅加以了解即可。
![image.png](https://oss.suning.com/mbap/mbapbk/275e098cbb424ef0631d103bc662f336.png?SDOSSAccessKeyId=42IA0GY51YZ1397N&Expires=1717853469&Signature=9698U3WWFwKMnD%2FHNnbAiDlctW0%3D)
{% endnote %}

# 传输层

{% note info **传输层如何给应用层提供传输服务 ？** %}
答案是 **socket**。socket 分很多类型， socket 就是对应的传输协议提供的传输服务，最常见的 socket 就是 **tcp socket** 和 **udp socket**，我们可以通过 socket 提供的传输服务来实现应用层的应用。
- 服务端
```java
// 声明端口
  int port = 80;
  ServerSocket serverSocket = new ServerSocket(port);
  // 等待客户端连接，建立和客户端通信的 socket
  Socket socket = serverSocket.accept();
  // 获取通信的传输流
  InputStream inputStream = socket.getInputStream();
  // 读取数据
  int len;
  byte[] bytes = new byte[1024];
  StringBuilder sb = new StringBuilder();
  while ((len = inputStream.read(bytes)) != -1) {
      sb.append(new String(bytes,0,len, StandardCharsets.UTF_8));
  }
  // 关闭连接 并且打印的接收的内容
  inputStream.close();
  System.out.println(sb.toString());
  socket.close();
  serverSocket.close();
```
- 客户端
```java
// 服务端的 host 和 端口号 
  String host = "leetcode.cn";
  int port = 80;
  Socket socket = new Socket(host,port);
  // 获取服务器的传输
  OutputStream outputStream = socket.getOutputStream();
  String message = "hello world";
  // 发送消息
  outputStream.write(message.getBytes(StandardCharsets.UTF_8));
  // 关闭连接
  outputStream.close();
  socket.close();
```
{% endnote %}

{% note warning **socket** %}
socket 是网络中发生和接收数据的端点。 socket 地址通常是协议类型、IP 地址和端口号的组合。
- ip 地址：客户端或者服务端的网络 ip 地址。
- 端口号：网络通信过中，客户端可以通过 ip 地址找到对应的服务器，但是服务器运行很多个程序，所以需要通过端口号找到对应的应用程序。一台计算机会有 65536 个端口号，256 ✖️ 256，端口号从 0 ~ 65535。
- 协议：只包括TCP 和 UDP。

传输层发展至今，虽然传输层协议有很多种，但是socket 地址的协议类型只有两种，只有 TCP 和 UDP 。其他的协议都是基于这两种协议开发出来的。
每个进程的 socket 地址唯一的。地址包括协议，所以同一个ip同一个port可以支持两个进程，一个 TCP 进程，一个 UDP 进程。
{% endnote %}

{% note warning **UDP 协议的特点** %}
- 发送数据的时机容易把控：采用 udp 协议发送数据的，会立即发送数据，发出即发送。
- 无需建立连接：无需任何准备就可发送数据。
- 无连接状态：无需在端系统中维护连接状态。
- 分组首部开销小：首部数据较小。
{% endnote %}

{% note success **UDP 报文结构** %}
报头由 4 个 16 位长（2 字节）字段组成，分别说明该报文的源端口、目的端口、报文长度和校验值

![image.png](https://oss.suning.com/mbap/mbapbk/2b8612e9afcd57f6499919a0b1a08f38.png?SDOSSAccessKeyId=42IA0GY51YZ1397N&Expires=1717765889&Signature=IN2hLW%2FptcUfy9wur80KFwLK3%2FE%3D)

- 源端口：发送数据报的应用程序所使用的 udp 端口，占据 16 位。
- 目的端口：接收端计算机上 udp 软件使用的端口，占据 16 位。
- 长度：该字段占据 16 位，表示 udp 数据报长度，包含 udp 报文头和 udp 数据长度。因为 udp 报文头长度是 8 个字节，所以这个值最小为 8，因为这个字段 16 位，这个值最大为 2 的 16 次方，所以udp理论上最大传输数据为2的16次方 - 8 (不考虑其他报文头的情况)，但是实际上对 udp 数据包的大小限制只有 512 字节或者 8192 字节。因为数据包越大，丢包率越高，所以传输标准将这个数据包的大小限制的更小一点。
- 校验值：该字段占据 16 位，可以检验数据在传输过程中是否被损坏。
{% endnote %}

{% note info **UDP 校验和** %}
udp 校验和提供了部分差错检测功能。

- 使用伪首部（包含32位的源IP地址、目的IP地址、16位的UDP长度、8位的协议类型组成）、UDP头部（不包括校验和字段）和数据部分进行16位求和。
- 如果发生溢出，结果只保留16位。
- 将求和结果取反，得到校验和。
- 将校验和放入UDP头部的校验和字段。

接收方收到数据报后，重新计算校验和并与收到的校验和进行比较，判断校验和字段是否相同，这个方法可以检测到绝大部分差错。
{% endnote %}

{% note danger **面向连接的协议-三次握手** %}
tcp 协议是面向连接的协议，客户端发送数据前需要和服务端建立连接，发送完毕后需要断开连接以节省资源。tcp通过三次握手建立连接，通过四次挥手关闭连接。
为了确保客户端和服务端都能正常发送和接收数据。三次握手是从客户端开始。

握手前状态：客户端和服务端都是处于连接关闭状态。服务端首先处于 listen 状态，等待客户端连接，然后就进入三次握手。

1. 客户端向服务端发送一个SYN(synchronize)包，随后客户端进入SYN-SENT 阶段。
标志位为 SYN：表示请求建立连接；
序列号为 Seq = x(x 一般为随机数)；
2. 服务端收到客户端发送SYN包后，对该包进行确认后结束 LISTEN 阶段，并返回一段 TCP 报文，随后服务器端进入 SYN-RECV(同步接收) 阶段。
标志位为 SYN 和 ACK：表示确认客户端的报文 Seq 序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接；
序号为 Seq = y，将自己的初始序列号同步给客户端。
确认号为 Ack = x + 1，表示收到客户端的序号 Seq 并将其值加 1 作为自己确认号 Ack 的值，告诉客户端自己接收的Seq没错；
3. 客户端接收到发送的 SYN + ACK 包后，明确了从客户端到服务器的数据传输是正常的，从而结束 SYN-SENT 阶段。并返回最后一段报文，随后客户端进入 ESTABLISHED状态。
标志位为 ACK，表示确认收到服务器端同意连接的信号；
序号为 Seq = x + 1，表示收到服务器端的确认号 Ack，并将其值作为自己的序号值；
确认号为 Ack= y + 1，表示收到服务器端序号 seq，并将其值加 1 作为自己的确认号 Ack 的值。
4. 当服务器端收到来自客户端确认收到服务器数据的报文后，得知从服务器到客户端的数据传输是正常的，从而结束 SYN-RECV 阶段，进入 ESTABLISHED 阶段，从而完成三次握手。
![image.png](https://oss.suning.com/mbap/mbapbk/f4bde2aebee6d4403b75176400b18d9b.png?SDOSSAccessKeyId=42IA0GY51YZ1397N&Expires=1717770670&Signature=w63Blw7w9ChjBLZCu9zxDh3dz1k%3D)
{% endnote %}

{% note danger **深入理解三次握手** %}
1. 为什么要进行三次握手 ？
确认客户端和服务端都可以正常发送接收数据。
    - 第一次握手：确认客户端可以正常发送数据。
    - 第二次握手：确认客户端可以正常发送数据，确认服务端可以正常接收数据。
    - 第三次握手：确认客户端可以正常发送数据，确认服务端可以正常接收数据，确认服务端可以正常发送数据，服务可以正常接收数据。

2. 客户端服务端的状态变化
客户端状态变化
- close：握手前，无连接，准备连接状态。
    发送第一次握手请求
- SYN-SENT：发送连接请求后，等待服务端响应状态。
    - 收到第二次握手请求
    - 发送第三次握手请求
- ESTABLISHED：收到服务端请求，进入连接状态。

服务端状态
- close：握手前。
- LISTEN：服务器开启，无连接，等待客户端发送连接请求。
    - 收到第一次握手请求。
    - 发送第二次握手请求。
- SYNC-RECV：有客户端发送请求，进入结束等待状态。
    - 收到第三次握手请求。
- ESTABLISHED：收到客户端请求，进入连接状态。

3. 握手失败，如果握手过程中，网络断开，会出现什么情况？

![image.png](https://oss.suning.com/mbap/mbapbk/9d1d07c737ce6e7a3cfb5885c964bb8c.png?SDOSSAccessKeyId=42IA0GY51YZ1397N&Expires=1717771974&Signature=jIKGo1QGyByAAx%2F6l7qg8DLwmOY%3D)
{% endnote %}

{% note info **四次挥手** %}
为了告知客户端和服务端将未发送的数据发送完毕，并且关闭连接，四次挥手是从客户端开始的。

挥手前状态：客户端和服务端都处于连接状态(ESTAB-LISHEN)，进入四次挥手。

1. 首先客户端向服务器发送一段 TCP 报文表明其想要释放 TCP 连接，随后客户端进入 FIN-WAIT-1 阶段，即半关闭阶段，并且停止向服务端发送通信数据。
    - 标记位为 FIN，表示请求释放连接；
    - 序号为 Seq = u；

2. 服务器接收到客户端请求断开连接的 FIN 报文后，结束 ESTABLISHED 阶段，进入 CLOSE-WAIT 阶段并返回一段 TCP 报文，随后服务器开始准备释放服务器端到客户端方向上的连接。客户端收到服务器发送过来的 TCP 报文后，确认服务器已经收到了客户端连接释放的请求，随后客户端结束 FIN-WAIT-1 阶段，进入 FIN-WAIT-2 阶段
    - 标记位为 ACK，表示接收到客户端释放连接的请求；
    - 序号为 Seq = v；
    - 确认号为 Ack = u + 1，表示是在收到客户端报文的基础上，将其序号值加 1 作为本段报文确认号 Ack 的值。

3. 服务器端在发出 ACK 确认报文后，服务器端会将遗留的待传数据传送给客户端，待传输完成后即经过 CLOSE-WAIT 阶段，便做好了释放服务器端到客户端的连接准备，再次向客户端发出一段 TCP 报文，随后服务器端结束 CLOSE-WAIT 阶段，进入 LAST-ACK 阶段。并且停止向客户端发送数据。
    - 标记位为 FIN 和 ACK，表示已经准备好释放连接了；
    - 序号为 Seq = w；
    - 确认号 Ack = u + 1，表示是在收到客户端报文的基础上，将其序号 Seq 的值加 1 作为本段报文确认号 Ack 的值。

4. 客户端收到从服务器发来的 TCP 报文，确认了服务器已经做好释放连接的准备，于是结束 FIN-WAIT-2 阶段，进入 TIME-WAIT 阶段，并向服务器发送一段报文。
    - 标记位为 ACK，表示接收到服务器准备好释放连接的信号；
    - 序号为 Seq= u + 1，表示是在已收到服务器报文的基础上，将其确认号 Ack 值作为本段序号的值；
    - 确认号为 Ack= w + 1，表示是在收到了服务器报文的基础上，将其序号 Seq 的值作为本段报文确认号的值。

5. 随后客户端开始在 TIME-WAIT 阶段等待 2 MSL。服务器端收到从客户端发出的 TCP 报文之后结束 LAST-ACK 阶段，进入 CLOSED 阶段。由此正式确认关闭服务器端到客户端方向上的连接。客户端等待完 2 MSL 之后，结束 TIME-WAIT 阶段，进入 CLOSED 阶段，由此完成「四次挥手」。

![image.png](https://oss.suning.com/mbap/mbapbk/ba9413d36b90b8f01679fcb72501cf23.png?SDOSSAccessKeyId=42IA0GY51YZ1397N&Expires=1717772170&Signature=9UV4rtzK4KQLtF3ToD3c0bJGRBo%3D)
{% endnote %}

{% note danger **深入理解四次挥手** %}
1. 为什么需要四次挥手 ？
确认双方都得知双方都没有要传输的数据。

- 第一次挥手：客户端向服务端请求关闭连接。
    - 客户端：客户端无数据传输。
    - 服务端：无感知。
- 第二次挥手：服务端收到客户端的请求，并且告知客户端等我处理完毕数据。
    - 客户端：客户端无数据传输。
    - 服务端：客户端无数据传输。
- 第三次挥手：服务端处理完毕数据，告知客户端，服务端数据处理完毕。
    - 客户端：客户端无数据传输，服务端无数据传输。
    - 服务端：客户端无数据传输，服务端无数据传输。
- 第四次挥手：客户端得知服务端数据处理完毕，双方数据都处理完毕，可断开连接。
    - 客户端：客户端无数据传输，服务端无数据传输。
    - 服务端：客户端无数据传输，服务端无数据传输，得知客户端知道服务端无数据传输。
- 客户端服务端的状态变化

2. 客户端状态
- ESTABLISHED四次挥手前，处于连接状态。
    - 发送第一次挥手请求。
- FIN-WAIT-1：客户端从连接状态变成等待断开连接状态。
    - 收到第二次挥手请求。
- FIN-WAIT-2：确认服务端收到了第一次握手请求。
    - 收到第三次挥手请求。
    - 发送第四次挥手请求。
- TIME-WAIT：确认服务端数据处理完毕，等待一段时间后断开连接。
- CLOSE：断开连接状态。

3. 服务端状态
- ESTABLISHED四次挥手前，处于连接状态。
    - 收到第一次挥手请求。
    - 发送第二次挥手请求。
- CLOSE-WAIT：告知客户端收到挥手请求，进入等待断开连接状态，将未发送的数据发送出去。
    - 发送第三次挥手请求。
- LAST-ACK：告知客户端数据都已经处理完毕。
    - 收到第四次挥手请求。
- CLOSE：确认客户端收到第三次挥手请求，断开连接。

4. 挥手失败的情况？
![image.png](https://oss.suning.com/mbap/mbapbk/5f02b5a29a1d02ea3b57d99269cad06f.png?SDOSSAccessKeyId=42IA0GY51YZ1397N&Expires=1717842759&Signature=oLmwrNBENTGIFv68u0r%2BxiRFLP4%3D)

5. 四次挥手的问题？
- 可以看到，如果四次挥手的过程中出现问题，客户端和服务端都可能在一段时间内处于半连接状态，此时无法进行开启新的连接。如果大量连接都处于这种状态，将会浪费大量连接资源。可以根据具体情况，修改系统内核参数，减少处于这种状态的时间。
- 四次挥手后，客户端要等待2MSL(Maximum Segment Lifetime,指一段 TCP 报文在传输过程中的最大生命周期)时间，因为要确认服务端收到了第四次挥手，如果服务端没有收到第四次挥手，就会重新发送第三次挥手，此时客户端再次发送第四次挥手，等待2MSL时间，如果2MSL 时间没收到，则认为服务端收到了请求。

{% endnote %}

{% note success **TCP 报文结构** %}
![image.png](https://oss.suning.com/mbap/mbapbk/0f1275550812522302b5505dd5693374.png?SDOSSAccessKeyId=42IA0GY51YZ1397N&Expires=1717842868&Signature=rj9MrdpjGOEl9upxeEW4rKV6Fto%3D)

- 源端口和目的端口号：它用于多路复用/分解来自或送往上层应用的数据，其和 IP 数据报中的源 IP 与目的 IP 地址一同确定一条 TCP 连接。

- 序号和确认号字段：序号是本报文段发送的数据部分中第一个字节的编号，在 TCP 传送的流中，每一个字节一个序号。例如一个报文段的序号为 100，此报文段数据部分共有 100 个字节，则下一个报文段的序号为 200。序号确保了 TCP 传输的有序性。确认号，即 ACK，指明下一个想要收到的字节序号，发送 ACK 时表明当前序号之前的所有数据已经正确接收。这两个字段的主要目的是保证数据可靠传输。

- 首部长度：该字段指示了以 32 比特的字为单位的 TCP 的首部长度。其中固定字段长度为 20 字节，由于首部长度可能含有可选项内容，因此 TCP 报头的长度是不确定的，20 字节是 TCP 首部的最小长度。

- 保留：为将来用于新的用途而保留。

- 控制位：URG 表示紧急指针标志，该位为 1 时表示紧急指针有效，为 0 则忽略；ACK 为确认序号标志，即相应报文段包括一个对已被成功接收报文段的确认；PSH 为 push 标志，当该位为 1 时，则指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队； RST 为重置连接标志，当出现错误连接时，使用此标志来拒绝非法的请求；SYN 为同步序号，在连接的建立过程中使用，例如三次握手时，发送方发送 SYN 包表示请求建立连接；FIN 为 finish 标志，用于释放连接，为 1 时表示发送方已经没有数据发送了，即关闭本方数据流。

- 接收窗口：主要用于 TCP 流量控制。该字段用来告诉发送方其窗口（缓冲区）大小，以此控制发送速率，从而达到流量控制的目的。

- 校验和：奇偶校验，此校验和是对整个 TCP 报文段，包括 TCP 头部和 数据部分。该校验和是一个端到端的校验和，由发送端计算和存储，并由接收端进行验证，主要目的是检验数据是否发生改动，若检测出差错，接收方会丢弃该 TCP 报文。

- 紧急数据指针：紧急数据用于告知紧急数据所在的位置，在URG标志位为 1 时才有效。当紧急数据存在时，TCP 必须通知接收方的上层实体，接收方会对紧急模式采取相应的处理。

- 选项：该字段一般为空，可根据首部长度进行推算。主要有以下作用：
1. TCP 连接初始化时，通信双方确认最大报文长度。
2. 在高速数据传输时，可使用该选项协商窗口扩大因子。
3. 作为时间戳时，提供一个 较为精准的 RTT。

- 数据：TCP 报文中的数据部分也是可选的，例如在 TCP 三次握手和四次挥手过程中，通信双方交换的报文只包含头部信息，数据部分为空，只有当连接成功建立后，TCP 包才真正携带数据。
{% endnote %}

{% note danger **如何保证可靠传输** %}
1. 数据分块
​应用数据被分割成 TCP 认为最适合发送的数据块。并且给每一个数据块进行编号，在传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答，即发送 ACK 报文，这个 ACK 报文当中带有对应的确认序列号，如果发送过程中，存在数据块丢失或者发送重复，接收方根据序列号整理数据块，删除重复的数据块，要求发送方重新发送丢失的数据块。

2. 校验和
与UDP 校验和相同，监测数据传输过程中可能出现的差错。

3. 流量控制
让发送方的发送速率不要太快，让接收方来得及接收，TCP 连接的双方都有一个固定大小的缓冲空间，发送方发送的数据量不能超过接收端缓冲区的大小。当接收方来不及处理发送方的数据，会提示发送方降低发送的速率，防止产生丢包。TCP 通过滑动窗口协议来支持流量控制机制。

4. ARQ协议
ARQ(Automatic Repeat-reQuest)自动重传协议：每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。

5. 超时重传
当 TCP 发出一个报文段后，它启动一个定时器，等待目的端确认收到这个报文段。如果超过某个时间还没有收到确认，将重发这个报文段。

6. 拥塞控制
在实际的网络通信系统中，除了发送方和接收方外，还有路由器，交换机等复杂的网络传输线路，此时就需要拥塞控制。拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况。常用的解决方法有：慢开始和拥塞避免、快重传和快恢复。
{% endnote %}

{% note danger **TCP 拥塞控制** %}
在实际的网络通信系统中，除了发送方和接收方外，还有路由器，交换机等复杂的网络传输线路，此时就需要拥塞控制。拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况。常用的解决方法有：慢开始和拥塞避免、快重传和快恢复。

- 慢开始：当发送方开始发送数据时，由于一开始不知道网络负荷情况，如果立即将大量的数据字节传输到网络中，那么就有可能引起网络拥塞。一个较好的方法是在一开始发送少量的数据先探测一下网络状况。慢开始的慢指的是初始发送报文段的数量为 1，如果收到确认，则发送两个报文段，之后每收到一个确认报文，发送报文端的数量就翻倍，直到到达慢开始门限，当发送报文段的数据大于门限数量时，使用拥塞避免算法。
- 拥塞避免：当网络拥塞发生时，慢开始门限值减半，发送的报文段数量改变为 1 ,然后再次重复两种算法（慢开始和拥塞避免）。
---
- 快重传：接收方每收到一个失序的报文就立即发送重复确认，而不要等到自己发送数据时才捎带进行确认，假定发送方发送了 Msg 1 ~ Msg 4 这 4 个报文，已知接收方收到了 Msg 1，Msg 3 和 Msg 4 报文，此时因为接收到收到了失序的数据包，按照快重传的约定，接收方应立即向发送方发送 Msg 1 的重复确认。 于是在接收方收到 Msg 4 报文的时候，向发送方发送的仍然是 Msg 1 的重复确认。这样，发送方就收到了 3 次 Msg 1 的重复确认，于是立即重传对方未收到的 Msg 报文。由于发送方尽早重传未被确认的报文段，因此，快重传算法可以提高网络的吞吐量。
- 快恢复：快恢复算法是和快重传算法配合使用的，该算法主要有以下两个要点：
    - 当发送方连续收到三个重复确认，执行乘法减小，慢开始门限值减半；
    - 由于发送方可能认为网络现在没有拥塞，因此与慢开始不同，发送报文段的数量减半，然后执行拥塞避免算法，线性增加发送报文段的数量。
{% endnote %}

{% note primary **TCP 粘包问题** %}
- 为什么会发生TCP**粘包**和**拆包**?
1. 发送方写入的数据大于套接字缓冲区的大小，此时将发生拆包。
2. 发送方写入的数据小于套接字缓冲区大小，由于 TCP 默认使用 Nagle 算法，只有当收到一个确认后，才将分组发送给对端，当发送方收集了多个较小的分组，就会一起发送给对端，这将会发生粘包。
3. 进行 MSS （最大报文长度）大小的 TCP 分段，当 TCP 报文的数据部分大于 MSS 的时候将发生拆包。
4. 发送方发送的数据太快，接收方处理数据的速度赶不上发送端的速度，将发生粘包。

- 常见解决方法
1. 在消息的头部添加消息长度字段，服务端获取消息头的时候解析消息长度，然后向后读取相应长度的内容。
2. 固定消息数据的长度，服务端每次读取既定长度的内容作为一条完整消息，当消息不够长时，空位补上固定字符。但是该方法会浪费网络资源。
3. 设置消息边界，也可以理解为分隔符，服务端从数据流中按消息边界分离出消息内容，一般使用换行符。

- 什么时候需要处理粘包问题？
1. 当接收端同时收到多个分组，并且这些分组之间毫无关系时，需要处理粘包；而当多个分组属于同一数据的不同部分时，并不需要处理粘包问题
{% endnote %}

# 网络层
{% note success **ip地址** %}
ip 地址是一个数字标签，例如 192.0.2.1 ，用于与使用 ip 协议进行通信的计算机网络连接，IP 地址主要有两个作用：
1. 网络接口标识.
2. 地址寻址。

**IPv4** (Internet Protocol version 4) 定义 IP 地址为 32 位二进制数字组成，其中分为四组 8 位二进制数字，每 8 位二进制数字转为十进制，就是常见的 ip 地址的形式。
{% endnote %}

{% note success **五类ip地址** %}
![](https://static.s123-cdn-static-c.com/uploads/1887341/2000_5c5f54e402598.jpg)

为了便于寻址以及层次化构建网络，每个 ip 地址包括两个标识码，即 **网络id** 和 **主机id**。同一个物理网络上的所有主机都使用同一个网络 id ，每个网络主机有一个唯一的主机 id ，根据网络 id 的不同将网络 ip 分为五类。

- A 类地址
由 1 字节的网络地址和 3 字节的主机地址组成，一个A类网络内理论上有 $$2^{24}$$ 个 ip 地址，为大型网络设计的。
> 网络号范围为 `0 - 127`，其中 0 代表任何地址，127 为回环测试地址。

- B 类地址
由 2 个字节的网络地址和 2 个字节的主机地址组成，网络地址的最高位必须是“10”，地址范围从 128.0.0.0 到191.255.255.255。可用的B类网络有16382个，每个网络能容纳6万多个主机 。
- C类地址
由 3 字节的网络地址和1字节的主机地址组成，网络地址的最高位必须是“110”。范围从 192.0.0.0 到 223.255.255.255。C类网络可达 $$2^{21}$$（209 万余）个 IP 地址，每个网络能容纳 254 个主机。
- D 类地址
用于多点广播（Multicast），它标识一组计算机共享同一协议，可以一次性寻址多个接收者。D 类地址的第一个字节以“1110”开始，范围从 224.0.0.0 到 239.255.255.255 。这些地址被保留用于多点广播，不会分配给特定的网络或主机。
- E 类地址
以“11110”开始，为将来使用保留。

> 全零(“0.0.0.0”)地址对应于当前主机。全“1”的IP地址(“255.255.255.255”)是当前子网的广播地址。

在 IP 地址 3 种主要类型里，各保留了 3 个区域作为私有地址，其地址范围如下：
1. A 类地址：10.0.0.0～10.255.255.255
2. B 类地址：172.16.0.0～172.31.255.255
3. C 类地址：192.168.0.0～192.168.255.255
{% endnote %}

{% note success **NAT v.s. ipv6** %}
随着互联网的发展 ipv4 提供的 ip 地址不够用了，人们提出了两种解决方案：

- nat(network address translation)网络地址转换协议
将内网地址转为公网ip的协议，实现多层网络地址转换。
- ipv6
使用 128 位二进制数字作为 ip 地址。

{% img http://localhost:4000/next/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1/image.png %}

{% img https://cattyhouse-guiny.xyz/next/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1/image.png %}

{% endnote %}

{% note primary **ARP协议** %}
arp(address resolution protocol) 地址解析协议：根据主机的ip 地址获取主机的mac 地址。每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。

有两台计算机 A 和 B 在局域网内通过以太网电缆和网络交换机相互连接，中间没有网关或路由器。A 有一个数据包要发送给 B，它确定 B 的 IP 地址，为了发送消息，它还需要 B 的 mac 地址。首先，A 使用缓存的 ARP 表根据 B 的 ip 地址查找 mac 地址，如果找到MAC 地址，就可以发送消息。如果没有，A 就会发送一个局域网广播的 ARP 请求 B 的 MAC的，这个消息被局域网内所有的计算机接受，B 返回一个包含 MAC 和 IP 地址的 ARP 响应消息。作为响应请求的一部分，B 可以将 A 的一个条目插入到它的 ARP 表中，以备将来使用。
{% endnote %}

{% note primary **ICMP协议** %}
icmp(internet control message protocol) 因特网控制报文协议 ，主要是实现 IP 协议中未实现的部分功能，是一种网络层协议。该协议并不传输数据，只传输控制信息来辅助网络层通信。其主要的功能是验证网络是否畅通（确认接收方是否成功接收到 IP 数据包）以及辅助 IP 协议实现可靠传输（若发生 IP 丢包，ICMP 会通知发送方 IP 数据包被丢弃的原因，之后发送方会进行相应的处理。ping 和 traceroute 都是通过 icmp 协议实现的。
- ping
即因特网包探测器，是一种工作在网络层的服务命令，主要用于测试网络连接质量。
- traceroute
其主要用来跟踪一个分组从源点耗费最少 TTL到达目的地的路径。
{% endnote %}

# 数据链路层
{% note success **数据链路层主要做什么事情** %}
1. **封装成帧**：将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。
<img src="https://img10.360buyimg.com/ddimg/jfs/t1/197042/17/34273/7230/661d267fF6f1c1ffd/235f3e272b93f526.jpg" alt="image.png" title="image.png" />

2. **透明传输**：帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。
3. **差错检测**：数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。
{% endnote %}

{% note success **MAC 地址和 IP 地址分别有什么作用** %}
MAC(media access control)地址，也称为局域网地址，以太网地址或物理地址，它是一个用来确认网络设备位置的地址。在 OSI 模型中，网络层负责 IP 地址，数据链接层则负责 MAC 地址。MAC 地址用于在网络中唯一标示一个网卡，一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的 MAC 地址。

- mac 地址和ip 地址的关系：
    - MAC 地址是数据链路层和物理层使用的地址，是写在网卡上的物理地址。MAC 地址用来定义网络设备的位置。
    - IP 地址是网络层和以上各层使用的地址，是一种逻辑地址。IP 地址用来区别网络上的计算机。
    - 互联网中主机之间相互传递数据的逻辑是，先通过 ip 地址找到对应的局域网，然后再找到对应的主机。
    - 如果只采用 ip 地址，不用mac 地址：不安全， 同一个ip 地址可能绑定多个主机，而无论何时mac 地址和主机是一一对应的。
    - 如果只采用mac 地址，不用ip 地址：没有办法使用ip 通过网段寻找目标主机，需要在全网段内没有规律的找一个主机，效率太慢。
{% endnote %}

# 物理层
{% note success **物理层主要做什么事情** %}
物理层是 OSI 模型中最低的一层，也是最基本的一层。简单的说，网络的物理层面**确保原始的数据可在各种物理媒体上传输**。
{% endnote %}

{% note info **主机之间的通信方式有哪些** %}
1. 单工通信：单向通信，发送方和接收方是固定的，消息只能单向传输。例如采集气象数据、家庭电费，网费等数据收集系统，或者打印机等应用主要采用单工通信。
2. 半双工通信：也叫双向交替通信，通信双方都可以发送消息，但同一时刻同一信道只允许单方向发送数据。例如传统的对讲机使用的就是半双工通信。
3. 全双工通信：也叫双向同时通信，全双工通信允许通信双方同时在两个方向上传输，其要求通信双方都具有独立的发送和接收数据的能力。例如平时我们打电话，自己说话的同时也能听到对面的声音
{% endnote %}

{% note success **为什么要采用信道复用** %}
信道复用技术的目的是让不同的计算机连接到相同的信道上，以共享信道资源。 在一条传输介质上传输多个信号，提高线路的利用率，降低网络的成本。
{% endnote %}


{% note info 信道复用有哪些技术 %}
1. 频分复用 (FDM，Frequency Division Multiplexing)
频分复用是将信道的总带宽划分为多个独立的子带宽，并将不同的信号分配到不同的子带宽中进行传输。每个子带宽可以看作是一个独立的信道。频分复用广泛应用于无线通信、有线电视等领域。
2. 时分复用 (TDM，Time Division Multiplexing)
时分复用是将时间分为若干个时隙，将不同信号分配到不同的时隙中进行传输。每个时隙可以看作是一个独立的信道。时分复用可以应用于有线和无线通信系统，如电话系统、数字信号传输等。
3. 波分复用 (WDM，Wavelength Division Multiplexing)
波分复用主要应用于光纤通信，通过将光信号分为不同的波长进行传输，实现在同一光纤中同时传输多路信号。波分复用可以大大提高光纤的传输容量，降低传输成本。
4. 码分复用 (CDM，Code Division Multiplexing)
码分复用又称为码分多址(CDMA，Code Division Multiple Access)，它通过使用不同的码片序列对信号进行编码和解码，实现信号在同一信道上的同时传输。码分复用具有抗干扰能力强、频谱利用率高等特点，广泛应用于移动通信、卫星通信等领域。
{% endnote %}

{% note info 宽带接入技术 %}
1. 数字用户线 (DSL，Digital Subscriber Line) ：DSL 技术利用现有的电话线传输高速数据，主要包括 ADSL(Asymmetric Digital Subscriber Line，非对称数字用户线) 和 VDSL(Very-high-bit-rate Digital Subscriber Line，超高速数字用户线)。DSL 技术通过在不同频段传输语音和数据，实现了高速上网和电话业务的同时使用。
2. 有线电视宽带接入(Cable Modem) ：有线电视宽带接入技术利用有线电视网络传输数据。宽带电缆调制解调器 (Cable Modem)连接到有线电视线路，实现高速数据传输。有线电视宽带接入具有传输速率高、覆盖范围广等优点。
3. 光纤到户(FTTH，Fiber to the Home)：光纤到户是一种将光纤直接连接到用户家庭的- 宽带接入技术。FTTH 利用高速光纤传输数据，具有传输速率高、抗干扰能力强、传输距离远等优点。FTTH已成为未来宽带接入的主流技术。
4. 无线宽带接入(Wireless Broadband Access)：无线宽带接入技术通过无线电波传输数据，主要包括Wi-Fi、WiMAX(Worldwide Interoperability for Microwave Access，全球微波接入互操作性) 和 4G/5G 等。无线宽带接入具有部署灵活、覆盖广泛等优点，适用于各种场景。
{% endnote %}

# 网络安全

{% note success dos 攻击 和 ddos 攻击是什么，如何防范 ？ %}
DoS（Denial of Service，拒绝服务） 攻击和 DDoS（Distributed Denial of Service，分布式拒绝服务）攻击都是网络安全领域常见的攻击手段。它们的目的是通过消耗目标系统的资源（如带宽、处理能力、内存等），使目标系统无法正常提供服务。

1. DoS 攻击：DoS 攻击通常由单个攻击者发起，通过向目标系统发送大量请求或特制的恶意数据包，使目标系统的资源耗尽，从而导致正常用户无法访问目标系统。常见的 DoS 攻击类型包括 SYN Flood、ICMP Flood、UDP Flood 等。DoS 攻击的缺点是攻击者的IP 地址容易被识别，从而受到追踪和制裁。
2. DDoS 攻击：DDoS 攻击是 DoS 攻击的一种升级形式，它利用多个受控制的计算机（僵尸网络）同时发起攻击，使攻击更难以防御和追踪。DDoS 攻击可以同时从多个方向消耗目标系统的资源，导致目标系统瘫痪。由于涉及的攻击来源众多，DDoS 攻击的防御难度要大于DoS 攻击。

防御 DoS 和 DDoS 攻击的方法包括：
- 限制单个 IP地址的请求速率。
- 使用防火墙、入侵检测系统（IDS）和入侵预防系统（IPS） 等安全设备。
- 采用负载均衡技术分散请求压力。
- 与互联网服务提供商（ISP）合作，进行流量清洗和封锁恶意IP 地址。

DoS 和DDoS 攻击对网络安全造成严重威胁，需要采取综合性措施进行防范和应对。
{% endnote %}

{% note success ARP 攻击的原理 %}
ARP 协议是一种利用 ip 地址获取 mac 地址的一种协议，而 ARP 攻击正是利用ARP协议的漏洞和不足进行攻击。

ARP 攻击就是攻击者通过伪造 ARP 请求和应答报文，使目标设备与网络中其他设备之间的通信受到干扰，从而达到窃取、篡改数据或拒绝服务的目的。常见的 ARP 攻击类型有：

1. ARP 欺骗（ARP Spoofing）：攻击者向网络中的设备发送伪造的 ARP 应答报文，使得目标设备将攻击者的 MAC 地址与一个错误的IP 地址绑定。这样，目标设备在与错误 IP 地址通信时，实际上会将数据发送给攻击者。
2. ARP中间人攻击（Man-in-the-Middle Attack）：攻击者向两台通信设备发送伪造的 ARP 应答报文，使它们分别将攻击者的 MAC 地址与对方的IP 地址绑定。这样，攻击者可以截获、窃取、篡改这两台设备之间的通信数据，实现中间人攻击。

防御 ARP 攻击的方法包括：
1. 静态 ARP 表：在网络设备上配置静态 ARP 表，将 IP 地址和 MAC 地址的对应关系固定下来，使攻击者无法通过伪造 ARP 报文篡改地址映射关系。
2. ARP 防护设备：部署 ARP 防护设备，如防火墙、入侵检测系统（IDS）等，以监控和阻止异常 ARP 报文。
3. 动态 ARP 检查（Dynamic ARP Inspection，DAI）：在交换机上启用 DAI 功能，检查通过交换机的 ARP 报文，验证其 IP 地址和 MAC 地址的对应关系，拦截异常 ARP 报文。
{% endnote %}

{% note success AES加密 和 RSA加密 %}
AES（Advanced Encryption Standard，高级加密标准） 和 RSA（由发明者Rivest、Shamir、Adleman的姓氏首字母组成）都是密码学中广泛使用的加密算法，但它们的加密原理和应用场景有所不同。

- AES ： AES 是一种对称加密算法，即加密和解密使用相同的密钥。AES 的密钥长度可以选择 128 位、192 位或 256 位。AES 的加密过程包括多轮的重复操作，包括置换、替换、行移位和列混合等。AES算法具有较高的安全性和运算效率，广泛应用于保护数据的机密性。
- RSA： RSA 是一种非对称加密算法，即加密和解密使用一对不同的密钥，分别称为公钥和私钥。公钥用于加密数据，私钥用于解密数据。RSA 算法的安全性基于大数分解问题，密钥长度通常选择 1024 位、2048 位或更长。RSA 算法用于保护数据的机密性、确保数据的完整性和实现数字签名等功能。

AES 和 RSA 的主要区别如下：
- 对称加密与非对称加密：AES 是对称加密算法，加密和解密使用相同的密钥；而RSA 是非对称加密算法，加密和解密使用不同的密钥。
- 效率：AES 加密和解密的运算速度较快，消耗资源较少；而 RSA 算法由于涉及大数计算，运算速度较慢，消耗资源较多。
- 应用场景：AES 适用于加密大量数据，如文件加密、网络通信加密等；RSA 常用于加密较小的数据，如密钥交换、数字签名等。

在实际应用中，AES 和 RSA 经常结合使用，以充分发挥各自的优势。例如，在安全通信中，先使用 RSA 算法交换 AES 密钥，然后使用 AES 密钥加密通信数据，实现高效且安全的数据传输。
{% endnote %}
