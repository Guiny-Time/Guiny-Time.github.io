---
layout: post
title: 二叉树问题的基本思想
date: 2024-03-26 20:07:12
tags: ['算法与数据结构','数据结构','计算机科学技术','面试相关']
categories: 算法与数据结构
copyright_author: 时光
hidden: true
---

<img src="https://img12.360buyimg.com/ddimg/jfs/t1/158523/31/43466/201208/6602bb0eF3a49da2f/7e37a5a8755d862f.jpg" width=600 alt="image.png" title="image.png" />

与二叉树有关的问题，最常用的解决方法是[递归](/next/递归思想/)。在二叉树相关的递归中，主要有 **自顶向下** 和 **自底向上** 两种模式。接下来我们将介绍这两种模式，并以计算二叉树的最大深度这道题为例，展示两种思想背后的差异。

1. **自顶向下**
在自顶向下类型的递归中，程序先操作根节点（相关状态已知），然后将根节点的状态一路传递下去。这种先检查根节点的思想其实和上一节中介绍的**前序遍历**思想是相吻合的。
其核心思路是：上层数值将值传递给下层，直到最后一层停止递归。
```Java
public int maxDepthTopDown(TreeNode root, int pram){
    // 设置递归的终止条件(base case)
    if(root == null)
        return pram;
    // 每往下一层，层数+1
    int leftD = maxDepthButTopDown(root.left, pram + 1);
    int rightD = maxDepthButTopDown(root.right, pram + 1);
    // 返回左右子树的最大深度
    return Math.max(leftD, rightD);
}
```

2. **自底向上**
在自底向上类型的递归中，我们首先对所有子节点递归地调用函数，然后根据返回值和根节点本身的值得到答案。这个过程可以看作是**后序遍历**的一种。
上层数值依赖于下层返回的数值，最后得到两个值（根的左子树的深度和根的右子树的深度）取最大值即可
```Java
public int maxDepthDownTop(TreeNode root) {
    // 设置递归的终止条件(base case)，返回底层节点的特殊值
    if(root == null)
        return 0;
    // 递归左右子树
    int leftD = maxDepth(root.left);
    int rightD = maxDepth(root.right);
    // 返回当前深度，由于往上走，所以加一
    return Math.max(leftD, rightD) + 1;
}
```

# 如何选择递归模式？
总的来说，当遇到树问题时，请先思考一下两个问题：

1. 你能确定一些参数，从该节点自身解决出发寻找答案吗？
2. 你可以使用这些参数和节点本身的值来决定什么应该是传递给它子节点的参数吗？

如果答案都是肯定的，那么请尝试使用 “**自顶向下**” 的递归来解决此问题。或者你可以这样思考：

1. 对于树中的任意一个节点，如果你知道它子节点的答案，你能计算出该节点的答案吗？ 

如果答案是肯定的，那么 “**自底向上**” 的递归可能是一个不错的解决方法。