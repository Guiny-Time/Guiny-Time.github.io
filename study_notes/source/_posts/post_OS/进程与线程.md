---
layout: post
title: 进程与线程刷题笔记
date: 2024-12-05 23:54:12
tags:
categories: 操作系统
hidden: true
---

{% note info **进程与线程的主要区别** %}
主要区别：**进程有自己的内存空间，线程共享内存空间**

| **特性** | **进程** | **线程** |
| --- | --- | --- |
内存空间 | 独立的内存空间 | 共享进程的内存空间
资源开销 | 创建和切换开销大 | 创建和切换开销小
通信方式 | 需要借助 IPC（如管道、消息队列等） | 可以直接共享内存，通信方便
执行单位 | 操作系统资源分配的基本单位 | 操作系统调度的基本单位
故障影响 | 一个进程崩溃不会直接影响其他进程 | 一个线程崩溃可能导致整个进程崩溃

{% endnote %}

{% note info **进程与线程** %}
无论操作系统是否支持多线程，**进程**始终是操作系统中**分配资源**（如内存、文件句柄等）的基本单位；**线程**是**调度**的基本单位。
同一进程中的线程共享相同的**地址空间**（例如代码段、数据段和堆）。线程的独立部分仅限于**栈**和**寄存器**。
**系统级线程**的切换需要操作系统**内核**的支持，而用户级线程的切换是由用户态的线程库实现的，不需要内核参与。
{% endnote %}

{% note info **可能导致当前进程阻塞的事件** %}
阻塞是指一个进程因为等待某些条件（如资源可用、I/O完成等）而暂停执行。阻塞状态的进程不占用 CPU，处于等待队列中。
1. 进程P申请**临界资源**。如果临界资源（如互斥锁、信号量）已被其他进程占用，那么进程 P 需要等待资源释放，这会导致 P 阻塞。
2. 进程P从**磁盘读取数据**。磁盘读取是一种 I/O 操作，需要等待操作系统完成。
{% endnote %}

{% note info **同步与互斥机制** %}
**互斥锁**和**自旋锁**是同步工具，用于解决多个线程对共享资源的竞争问题，两种锁都可能导致**饥饿**和**死锁**问题。
死锁的根本原因是资源竞争和锁顺序的问题，与锁的类型（互斥锁或自旋锁）和数量无直接关系。
{% endnote %}

---

{% note success **独占资源与进程卡死的判断** %}
已知S1和S2为**独占资源，
进程P1使用资源情况: 申请资源S1->申请资源S2->释放资源S1; 
进程P2使用资源情况: 申请资源S2->申请资源S1->释放资源S2, 
系统仅开放了进程P1, P2, 系统会发生什么事情？
解答：**必定卡死**。死锁的四个必要条件：
1. 互斥条件：资源是独占的，同一时间只能有一个进程使用。
    S1 和 S2 是独占资源，满足互斥条件。
2. 占有且等待条件：一个进程占有一个资源，同时又申请另一个资源并处于等待状态。
    P1 占有 S1 并申请 S2；P2 占有 S2 并申请 S1，满足占有且等待条件。
3. 不可剥夺条件：资源不能被强制夺走，只能由占有它的进程主动释放。
    资源 S1 和 S2 只能由对应占有的进程释放，满足不可剥夺条件。
4. 环路等待条件：多个进程形成资源申请的环路。
    P1 等待 S2，而 S2 被 P2 占有；P2 等待 S1，而 S1 被 P1 占有，形成环路等待条件。

死锁条件完全满足，因此系统必定产生进程卡死。
{% endnote %}

{% note success **线程代码执行输出** %}
有两个线程 A 和 B，共享两个变量 `x` 和 `y`，初始值都为 0，线程 A 执行以下操作：
```Java
x = 1;
y = 2;
```
线程 B 执行以下操作：
```Java
if (y == 2) {
System.out.println(x);
}
```
输出的结果是什么样的？
遇到这种问题我们需要明确的是：线程 A 和线程 B 是并发执行的，彼此之间的**操作顺序未定**。在并发情况下，以下几种执行顺序可能发生：
1. 线程 A 先执行
    线程 B 检查 y 的值，发现 y 为 2，因此打印 x 的值 1。
2. 线程 B 先执行
    线程 B 检查 y 的值，发现 y 为 0（因为线程 A 还未执行），因此不打印任何内容。
3. 线程 A 和线程 B 并行执行
    线程 B 可能会在 y 被设置为 2 之前检查 y 的值，因此不会打印任何内容。
    如果线程 B 在 y 被设置为 2 之后检查 y 的值，它将打印 x 的值，即 1。

由于Java共享变量可见性的问题，x的修改可能不会立即反映，所以也可能输出0。
{% endnote %}

---

{% note danger **同个进程的不同线程有什么不能被共享？** %}
**栈**是不能被共享的，因为每个线程都有自己独立的栈空间（用于存储线程的局部变量、函数调用信息等）。
堆、全局变量、文件句柄（进程级资源）这些都是可以共享的。
{% endnote %}