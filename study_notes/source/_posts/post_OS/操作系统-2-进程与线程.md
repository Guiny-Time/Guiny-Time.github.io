---
layout: post
title: 操作系统-2-进程与线程
date: 2025-01-12 20:41:49
tags:
categories: 操作系统
hidden: true
---

# 进程
## 进程的概念、组成、特征
**概念**：“进程”和“程序”的区别。

- **程序**（Program）：**静态**的、存放在磁盘里的可执行文件，也就是一系列的指令集合。
- **进程**（Process）：**动态**的、程序的一次执行过程。同一个程序多次执行会对应多个进程。

例如 QQ 的 `.exe` 文件是一个可执行文件（程序），点击 QQ 运行时可以在任务管理器中找到一个进程。开启多次 QQ 会建立多个 QQ 进程。
<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA8dc914f3da35fadf32124efad281d664.png" alt="任务管理器中的QQ进程" />

---

**组成**：一个进程实体（**进程映像**）由哪些部分组成呢？答案是 **PCB**、**程序段**和**数据段**。
- **PCB**：给操作系统用的。
    - **PID**（Process ID，进程 ID）：一个唯一的、不重复的 ID，用来区分不同的进程。
    - **UID**（UserID，进程所属用户 ID）：描述该进程由哪位用户创建。
    - **资源分配清单**：内存区域占用、正在使用哪些 I/O 设备、正在使用哪些文件等，可用于实现操作系统**对资源的管理**。
    - **进程控制和管理信息**：CPU使用时间、磁盘使用情况、网络流量使用情况；进程当前状态（就绪/阻塞/运行/...），可以用实现操作系统**对进程的控制和调度**。
    - **处理机相关**：PSW（程序状态字信息）、PC（程序计数器）等各种寄存器的值，用于实现进程切换。
    这些信息会被统一放进**进程控制块**（PCB）的数据结构中。PCB 是一个进程的唯一标志，在进程创建时创建、进程结束时回收。
- **程序段**：程序的代码（指令序列），给进程自己用的。
- **数据段**：运行过程中产生的各种数据（如：程序中定义的变量），给进程自己用的。

**进程**本身是动态的，但**进程实体**（进程某一时刻的快照）是静态的。换句话说，进程是进程实体的**运行过程**，是系统进行**资源分配**和**调度**的一个独立单位。
<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VAf0845c29f0a3b16fd30d1b02cf1c6101.png" alt="资源管理器所展现的一些记录" />

---

**特征**：进程有哪些重要特征？

1. **动态性（最基本的特征）**：进程是程序的一次执行过程，是动态地产生、变化和消亡的。
2. **并发性**：内存中有多个进程实体，各进程可并发执行。
3. **独立性**：进程是独立运行、独立获得资源、独立接受调度的基本单位。
4. **异步性**：各进程按各自独立的、不可知的速度向前推进，操作系统要提供“进程同步机制”来解决异步问题。
5. **结构性**：每个进程都会配置一个 PCB，从结构上看，进程由程序段、数据段、PCB 三部分组成。

## 进程的状态与转换、进程的组织
**进程的五种状态**：
<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VAddc5addbd614058b7bcd0ea41d2f2bdc.png" alt="进程的状态" />

1. **创建态（New）**：进程正在被创建，操作系统会为进程在内存中**分配资源、初始化 PCB**。
2. **就绪态（Ready）**：当进程完成创建，**具备运行条件**。此时由于没有空闲 CPU，进程**暂时不能运行**。内存中可能存在多个处于就绪态的进程。
3. **运行态（Running）**：CPU 空闲时，操作系统就会让它**选择一个处于就绪态的进程运行**，CPU 会执行该进程的指令序列（程序）。
4. **阻塞态（Blocked/Waiting）**： 进程运行过程在因为**请求等待某个事件**（例如等待 I/O）发生而无法继续执行。
5. **终止态（Terminated）**：当进程运行结束，可以**执行 `exit` 系统调用**（或遇到错误中断），请求操作系统终止该进程。操作系统会**回收内存中的资源和 PCB**，随后进程消失。

---

**状态的转换**：
<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VAa146ffbe67abcaa78f0ab5ba841878c7.png" alt="进程的状态切换" />

- **就绪 -> 运行**：进程被操作系统调度，被 CPU 运行
- **运行 -> 就绪**：时间片用完，或 CPU 被抢占
- **运行 -> 阻塞**：进程**通过系统调用**等方式请求某个资源或等待某个事件发生（进程的**主动行为**）
- **阻塞 -> 就绪**：申请的资源被分配或等待的事件发生了（**被动行为**）

阻塞态是没有办法直接变成运行态的，就绪态也无法转换为阻塞态，因为阻塞这一行为是进程主动请求的，需要在运行时才能发出。

---

**进程的组织方式**：即各个进程PCB的组织方式。

PCB 中有一个变量 `state` 用来表示进程当前的状态，通常以**数字**的形式表示，例如：1表示创建态、2表示就绪态、3表示运行态...。为了对同一个状态下的各个进程进行统一的管理，操作系统会将各个进程的 PCB 组织起来。组织的方式有两种：

1. **链接方式**：
操作系统管理一系列**状态队列**（**优先队列**）的指针，队列会指向所有处于该状态的 PCB，优先级越高越前。
阻塞队列可能会因为阻塞原因的不同而被划分为多个队列。
2. **索引方式**：
操作系统管理一系列**状态表**的指针，表里是 PCB。

## 进程控制
**基本概念**：
进程控制的主要功能是对系统中所有的进程实施有效的**管理**，具有**创建新进程、撤销已有进程、实现进程转换**等功能。简单来说，进程控制就是**实现进程状态转换**。

进程控制是通过**原语**来实现的。原语是一种特殊的程序，它的**执行具有原子性**（**运行必须一气呵成、不可中断**）。

{% note info **为什么进程控制需要一气呵成？** %}
操作系统执行进程状态改变的过程其实有两个步骤：
1. 修改 `state` 变量的值
2. 改变 PCB 所处的数据结构（队列或表）的位置

如果在这个过程中触发了中断，只执行了步骤 1 而没有执行步骤 2，就会引发关键数据结构信息不统一的问题，因此需要确保这两步的**原子性**，必须一气呵成地执行完。
{% endnote %}

---

**原语的原子性实现**：
<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA3433a663d6442dfa78d02fcaf77f8a76.png" alt="原子性的实现" width=300 />

原语的原子性是通过“**关中断**指令”和“**开中断**指令”这两个**特权指令**实现的。
- **关中断指令**：执行后，CPU 不再检查中断信号，中断无法发生。
- **开中断指令**：执行后，CPU 继续检查中断信号，中断可以发生。

这样关中断和开中断中间的指令序列就是不可被中断的，就具有原子性了。

---

**相关原语**：

1. **进程创建**（发生在用户登录/作业调度/提供服务/应用请求等时）：
    - **创建原语**（创建态 -> 就绪态）
        - 申请空白 PCB
        - 为新进程分配所需资源
        - 初始化 PCB
        - 将 PCB 插入就绪队列
- **进程终止**（发生在进程正常结束/异常结束/外界干预（用户终结进程）等时）：
    - **撤销原语**（就绪态/阻塞态/运行态 -> 终止态 -> 无）
        - 从 PCB 集合中找到终止进程的 PCB
        - 若进程正在运行，立即剥夺 CPU，将 CPU 分配给其他进程
        - 终止其所有**子进程**
        - 将该进程拥有的资源归还给父进程或操作系统
        - 删除 PCB
- **进程阻塞**（需要等待系统分配某种资源 / 需要等待相互合作的其他进程完成工作）：
    - **撤销原语**（运行态 -> 阻塞态）：
        - 找到要阻塞进程的 PCB
        - 保护进程运行线程，将 PBC 状态信息设置为“阻塞”，暂停进程运行
        - 将 PCB 插入相应事件的等待队列
- **进程唤醒**（等待的事件已经发生了）：
    - **唤醒原语**（阻塞态 -> 就绪态）：
        - 在事件等待队列中找到 PCB
        - 将 PCB 从等待队列移除，设置进程状态为“就绪”
        - 将 PCB 插入就绪队列
- **进程切换**（时间片到/有更高优先级的进程到/主动阻塞/进程终止）：
    - **切换原语**（运行态 -> 就绪态，就绪态 -> 运行态）：
        - 将运行环境信息存入 PCB
        - PCB 移入相应队列2
        - 选择另一个进程执行，为其更新 PCB
        - 根据 PCB 恢复新进程所需的运行环境

## 进程通信（IPC）
进程间通信（IPC）指的是**两个进程之间产生的数据交互**。由于进程是分配系统资源的基本单位，因此各进程拥有的**内存地址空间相互独立**，不同的进程无法访问其他进程的资源，所以需要操作系统支持提供 IPC。

**共享内存**：
<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA348db3a874ddea8208e862359540b57d.png" alt="共享内存" />

进程可以申请一片“**共享存储区**”，通过将需要传递的信息写在共享内存区实现数据共享。另外需要注意的是：为了避免出错，各个进程对共享空间的**访问应该是互斥的**（只有一个进程可以访问共享内存），可以通过操作系统提供的**同步互斥工具**（P、V操作，会在后续提到）实现。

有两种实现共享内存的方式：

1. **基于存储区的共享**：
操作系统在内存中划出一块共享内存，数据的形式、存放位置都**由要通信的进程控制**（而不是操作系统），这样很灵活、速度很快，是一种**高级通信**的方式。
2. **基于数据结构的共享**：
比如共享空间里只能放一个长度为 10 的数组（类似于一个**特殊的全局变量**）。这种方式速度慢、限制多，是一种**低级通信**的方式。

---

**消息传递**：
<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA89b0118b2d93d02b04412772415b21d7.png" alt="共享内存（左）和消息传递（右）" width=350 />

进程间的数据交换以**格式化的消息**为单位，通过操作系统提供的“**发送消息**”和“**接收消息**”两个**原语**实现数据交换。格式化的消息由**消息头**（发送进程ID、接收进程ID、消息长度等）和**消息体**组成。

1. **直接通信方式**
发送消息的进程要**指明接收消息的进程的ID**。直接通信借助进程的 PCB 中的**消息队列**实现，发送过来的消息会被加入这个消息队列中。
    - 发送进程 P 使用**发送原语** send（Q，msg）；
    - 操作系统将消息 `msg` 挂到进程 Q 的消息队列；
    - 进程 Q 通过**接收原语** recieve（P，&msg）获取来自进程 P 的消息；
    - 操作系统从消息队列中拿出消息，放到进程 Q 的内存中。
2. **间接通信方式**
通过“信箱”间接地通信，因此又叫“**信箱通信方式**”。操作系统运行多个进程从信息中收 / 发消息。
    - 进程 P 可以**申请一个或多个邮箱**；
    - 进程 P 使用**发送原语**将消息**发送到某个信箱**；
    - 进程 Q 使用**接收原语**从某个信息中接收消息 `msg`；
    - 操作系统将 `msg` 复制到进程 Q 的内存中。

---

**管道通信**：
<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA62f79667ae05c0d527ac7825388952a4.png" width=350 />

- **写进程**可以往管道的一端写入数据，**读进程**可以从管道的另一端读数据，**数据的流动只能是单向的**（半双工），如果要实现双向同时通信则需要建立两条管道。
- 各进程要互斥地访问管道（由操作系统实现）。
- 当**管道写满**时，**写进程将阻塞**，直到读进程将管道中的数据取走。
- 当**管道读空**时，**读进程将阻塞**，直到写进程往管道中写入数据。
- 管道中的数据一旦被读出就彻底消失了，多个进程读同一个管道可能会出错。对此，
    - 允许多个写进程，一个读进程
    - 允许多个写进程，多个读进程，但操作系统会让各个读进程轮流读数据
- “管道”是一种特殊的共享文件（`pipe` 文件），是一个在内存中**大小固定的缓冲区**。管道中的数据是**先进先出**（FIFO）的。

{% note success **管道和共享内存的区别是什么**？ %}
管道通信和共享内存都是在内存中开辟了一块空间，那它们之间有什么区别呢？主要就在于**数据的组织形式**上。
共享内存非常自由，进程可以随意存储，其他进程可以随意读取。
而管道则严格遵守 FIFO 的原则。
{% endnote %}

{% note info **管道与有名管道** %}
- **管道**(pipe)
管道是一种半双工的通信方式，数据只能单向流动，而且只能在**具有亲缘关系的进程间**使用。进程的亲缘关系通常是指父子进程关系。

- **有名管道** (namedpipe)
有名管道也是半双工的通信方式，但是它允许**无亲缘关系进程间**的通信。
{% endnote %}

---

**信号量**：
<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VAa60bd16f400adf11a51c82deeee58d3f.png" width=450 />

信号量是一个**计数器**，可以用来控制多个进程对共享资源的访问。它常作为一种**锁机制**，防止某进程正在访问共享资源时，其他进程也访问该资源。信号量由以下两部分组成：

1. **计数器**（Counter）
计数器记录了当前“资源”的可用数量。比如，计数器值为 3，代表资源还能给 3 个进程用。如果用光了（计数器变成 0），后来的进程就得等待。
2. **等待队列**（Queue）
如果资源用完了，进程就会进入“等待队列”，排队等着被唤醒。

信号量的两个操作：
- **`P` 操作**（wait）：进程要访问资源时执行 `P` 操作：
    - 计数器减 1，如果结果 >= 0，说明有资源，可以使用。
    - 如果结果 < 0，说明没资源了，把进程挂起，排队等资源。
- **`V` 操作**（signal）：进程用完资源后执行 V 操作：
    - 计数器加 1，如果结果 > 0，说明还有空余资源。
    - 如果有进程在等待队列里，唤醒一个，让它接着用。

---

**信号**：信号在进程间通信中，就像是一个“电话铃”，用来**通知进程某个事件发生了**。进程通过接收信号来响应外界或内核的某些动作。

信号的实现机制由两个部分组成：
1. **信号表**
每个进程都有一个信号表，里面记录了进程对各种信号的处理方式（默认处理、自定义处理或阻塞）。
2. **信号队列**
信号不会直接中断进程，而是排到信号队列中，等到进程有机会处理时再执行。

- 信号是一种**软中断**，每个信号都有一个编号（比如 SIGINT 是 Ctrl+C 产生的信号），不同信号表示不同的事件。
- 信号可以由**操作系统**发送（比如定时器超时）、**用户手动**发送（用 kill 命令），或者**进程之间**相互发送。信号会被送到**目标进程的信号队列中**，操作系统会通知目标进程。
- 目标进程可以选择如何响应信号：
    - 执行默认动作（比如终止、忽略）。
    - 自定义信号处理函数（比如收到信号时写个日志）。
    - 阻塞信号（暂时不处理）。

---

**套接字**（Socket）：
套接字可以实现**不同设备**的进程之间的通信，过程分为以下几个步骤：
1. **建立套接字**：通信的进程双方都创建一个 `Socket` 对象。
2. **绑定地址**：告诉套接字数据该发往哪里（IP + 端口号）。
3. **监听和连接**：一方监听，另一方尝试连接。
4. **读写数据**：通过 `send()` 和 `recv()`（TCP）或者 `sendto()` 和 `recvfrom()`（UDP）完成通信。

# 线程
## 线程的概念与特点
**什么是线程，为什么要引入线程？**
<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA7b7ecb9e742a9a47c7634ff3b40f7e07.png" alt="单线程与多线程" width=400 />

有的进程可能需要“同时”做很多事情，而传统的进程只能串行地执行一系列程序。为此引入了“线程”的概念，来**增加并发度**。此时，线程变成了**基本的CPU执行单元**，也是**程序执行流的最小基本单位**。线程可以被理解成**轻量级的进程**。

> QQ 可以支持视频聊天、传送文件等。这两个功能就可以拆成两个线程，可以并发完成了。

**进程**只作为**除 CPU 之外的系统自由的分配单元**，每个线程有自己独立的寄存器和栈。

---

**引入线程机制后，有什么变化？**
- **资源分配/调度**：
    - 传统：进程是资源分配、调度的基本单位；
    - 引入线程：进程是资源分配的基本单位，线程是调度的基本单位。
- **并发性**：
    - 传统：只能在进程间并发；
    - 引入线程：各线程间也能并发，提升了并发度。
- **系统开销**：
    - 传统：需要切换进程的运行环境，系统开销很大；
    - 引入线程：同一进程内的线程切换不需要切换进程环境，系统开销很小。

---

**线程有哪些重要的属性？**
1. 线程是处理及调度的单位
2. 多 CPU 计算机中，各个线程可以占用不同的 CPU。
3. 每个线程都有一个线程 ID、线程控制块（TCB）
4. 线程也要就绪、阻塞、运行三种基本状态
5. 线程集合不拥有系统资源
6. 同一进程的不同线程间共享进程的资源
7. 由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预
8. 同一进程中的线程切换，不会引起进程切换
9. 不同进程中的线程切换，会引起进程切换
10. 切换同进程内的线程，系统开销很小
11. 切换进程，系统开销较大

## 线程的实现方式和多线程模型

**线程的实现方式**：
1. **用户级线程**（ULT）：
    - 用于早期的操作系统（如 Unix），它们只支持进程而不支持线程，线程是用户通过**线程库**实现的，比如下面的代码展示的 `while` 循环就是一个最简单的线程库。
    - **线程库实现了线程的管理**（而非操作系统管理）。
    - 操作系统无法感知到用户级线程的存在。
    - 用户级线程的创建/切换不需要切换到内核态，系统开销小、效率高。
    - 一个用户级线程被阻塞会导致整个进程被阻塞（所有线程都无法继续执行），并发度低。
    ```C++
    int main(){
        int i = 0;
        while(true){
            if(i == 0){
                // 处理功能A
            }
            if(i == 1){
                // 处理功能B
            }
            if(i == 2){
                // 处理功能C
            }
            i = (i + 1) % 3; // i 在 0，1，2，0，1，2，...中循环
        }
    }
    ```
2. **内核级线程**（KLT）：
    - 由现代操作系统（如Windows、Linux）支持，操作系统能意识到内核级线程的存在。
    - 由操作系统管理和调度，线程切换时需要切换到内核态。
    - 当一个内核级线程被阻塞，别的线程还可以继续执行，并发性强。多线程可以在多喝处理及上并行执行。
    - 一个进程可能有多个线程，线程管理的成本高、开销大。

---

**多线程模型**：用户级线程和内核级线程各有利弊，不如把它们取其长处结合起来，这就是多线程模型的思想，其中包括以下几种类型：
<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA436ca3ebd247b1b90531d7456759dc60.png" />

1. **一对一模型**：
    - **一个用户级线程映射到一个内核级线程**。每个用户进程有与用户级线程同数量的内核级线程。
    - 这就是内核级线程，具有内核级线程的所有优缺点。
2. **多对一模型**：
    - **多个用户级线程映射到一个内核级线程**。一个用户进程只被分配一个内核级线程。
    - 这就是用户级线程，具有用户级线程的所有优缺点。
3. **多对多模型**：
    - **`n` 个用户级线程映射到 `m` 个内核级线程**（`n` ≥ `m`）。每个用户进程对应 `m` 个内核级线程。
    - 克服了多对一模型并发度不高（一阻塞则全阻塞）的问题，也解决了一对一模型开销太大的缺点（一个用户进程占用太多内核级线程）。
    - 用户级线程是“**代码逻辑**”，而内核级线程是“**运行机会**”。一段代码只有获得了运行机会才会被 CPU 执行。
    - 所有内核级线程都被阻塞后，进程才会进入阻塞态。

## 线程的状态和转换
线程的状态/状态转换**和进程完全一致**。

线程的**组织与控制**是通过类似于 PCB 的 **TCB** 实现的。TCB 包含了以下内容：
- **线程标识符/TID**：类似于 PID，是线程的唯一标识。
- **程序计数器/PC**：线程目前执行到哪里了。
- **其他寄存器**：线程运行的中间结果。
- **堆栈指针**：堆栈保存函数调用信息、局部变量等。
- **线程运行状态**：运行/就绪/阻塞。
- **优先级**：线程调度、资源分配的参考。

TCB 形成了一张 **TCB 表**

## 线程间通信

**锁机制**：包括**互斥锁**、**条件变量**、**读写锁**。

- **互斥锁**：提供了以排他方式防止数据结构被并发修改的方法。 
- **读写锁**：允许多个线程同时读共享数据，而对写操作是互斥的。 
- **条件变量**：可以以**原子**的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。

---

**信号量**：包括无名信号量和命名信号量。
- **无名信号量**：最常用的一种信号量，特点是仅在**创建它的进程或线程内部共享**。
    - 使用方式：通常定义在内存中，比如堆、栈、全局变量中，直接通过指针传递。
    - 作用范围：仅限于同一进程中的多个线程之间，或在多进程中通过共享内存实现。
- **命名信号量**：特点是通过一个全局名字进行标识和访问，可以用于**多个进程之间**的通信。
    - 使用方式：通过系统调用 sem_open，指定一个名字。
    - 作用范围：跨进程共享。

进程的信号量如果用无名也需要借助共享内存，跨进程操作涉及内核态切换，效率较低。

---

**信号**：类似进程间的信号处理，但更简单，因为线程共享同一个地址空间，通信成本较低 。

# 调度
## 调度的概念、层次

**基本概念**：当有一堆任务需要处理，但由于资源优先，就需要确定**某种规则**来决定**处理这些任务的顺序**，这就是调度研究的问题。

在计算机中，一个**作业**就是一个具体的任务。如果说“用户向系统提交一个作业”，就约等于用户让操作系统启动一个程序来处理一个具体的任务。

---

**三个层次**：
1. **高级调度**（作业调度，无 -> 创建 -> 就绪）：
    - 外存 -> 内存（面向作业）
    - 计算机的内存是**有限**的，操作系统按照一定的原则从**外存中的作业后备队列**中体哦选一个作业调入内存，并**创建进程**（建立 PCB）。
    - 每个作业只会调入一次、调出一次（撤销 PCB）。
2. **中级调度**（内存调度，挂起 -> 就绪）：
    - 外存 -> 内存（面向进程）
    - 计算机内存是有限的，所以在内存不够是可能将某些进程的数据**调出到外存**，等内存空闲或进程需要运行的时候再重新调入内存。
    - 暂时调到外存等待的进程状态为**挂起状态**，被挂起的进程的 PCB 会组织成**挂起队列**。
    - 中级调度按照某种策略决定将哪个处于挂起状态的进程重新调入内存。
    - 中级调度发生的频率比高级调度高。
3. **低级调度**（进程调度 / 处理机调度，就绪 -> 运行）：
    - 内存 -> CPU
    - 操作系统按照某种策略从**就绪队列**中选取一个进程，将处理机分配给它。
    - 进程调度是操作系统中**最基本、最低级的一种调度**，在一般的操作系统中都必须配置进程调度。
    - 进程调度的**频率很高**，一般几十毫秒一次。

## 调度的时机、切换与过程

**进程调度的时机**：

- **什么时候需要进程调度？**
    1. 进程**主动放弃**
        - 进程正常终止
        - 运行过程中发生异常而终止
        - 进程主动请求阻塞（如：等待 I/O）
    2. 进程**被动放弃**
        - 时间片用完（每个**时钟中断**或 k 个时钟中断）
        - 有更紧急的事情需要处理（如 I/O 中断）
        - 有更高优先级的进程进入就绪队列
- **什么时候不能进行进程调度？**
    1. **处理中断**的过程中
    2. 进程处于**操作系统内核程序临界区**中
    3. 在**原子操作过程中**（原语）

---

**进程调度的切换与过程**：

- **“狭义的调度”和“切换”的区别**：
    - **狭义的进程调度**：选择一个要运行的进程
    - **进程切换**：让一个进程让出处理机、另一个进程占用处理及
    - **广义的进程调度**：上面两步加起来
- **进程的切换过程需要做什么？**
    1. 对原来运行进程的各种数据（PC、PSW、寄存器数据等）的保存
    2. 对新的进程的各种数据的恢复
    由此可以看出，进程的切换也是**有代价的**，过于频繁的调度和切换会使整个系统的效率降低，大部分时间被花在了进程切换上，真正用于执行进程的时间减少。
---

**进程调度的方式**：

1. **非抢占式**（非剥夺调度方式）：只允许进程**主动放弃**处理机，即该进程终止或进入阻塞态。无法及时处理紧急任务，适合早期的批处理操作系统。
2. **抢占式**（剥夺调度方式）：当一个进程在执行时，如果有一个更重要 / 紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更紧迫的进程。适合分时操作系统、实时操作系统。

## 调度器和闲逛进程
**调度器**：

进程从运行态 -> 就绪态和从就绪态 -> 运行态的这两个过程就是由**调度程序**引起和决定的。让哪个进程运行涉及到**调度算法**，运行多长时间涉及到**时间片大小**。

---

**闲逛进程**：

就绪队列没有其他就绪进程的时候，调度程序让 CPU 运行闲逛进程（Idle）。也就是说 CPU 不可能处于空闲状态，必须有点事干。

闲逛进程的**优先级最低**，可以使 0 地址指令，占一个完整的指令周期（检查中断），耗能很低。

## 调度算法
调度算法有五个评价指标：
- **CPU利用率**：$\frac{CPU忙碌的时间}{总时间}$。
- **系统吞吐量**：$\frac{单位时间内完成的作业数量}{总时间}$。
- **周转时间**：作业被提交给系统开始，到作业完成的时间间隔（ $完成时间 - 提交时间$）。
    - 周转时间包括在后备队列上等待调度的时间（**高级调度**）、在就绪队列上等待调度的时间（**低级调度**）、在 **CPU 上执行的时间**、**等待 I/O** 操作的时间。
    - **平均周转时间**：$\frac{各作业周转时间之和}{作业数}$。
    - **带权周转时间**：$\frac{作业周转时间}{作业实际运行时间}$。这个值必然 > 1，数字越小越好。
    - **平均带权周转时间**：$\frac{各作业带权周转时间之和}{作业数}$。
- **等待时间**：作业处于**等待处理机状态**时间之和。对于作业来说还要加入在**外存后备队列**中的时间。
    - **平均等待时间**：$\frac{各作业等待时间之和}{作业数}$。
- **响应时间**：用户提出请求到**首次**产生响应所用的时间。

### 先来先服务（FCFS）
- **思想**：从公平的角度考虑，类似于排队，**非抢占式**。
- **规则**：按照作业到达顺序进行服务
- **优缺点**：
    - **优点**：公平、简单、不会导致饥饿
    - **缺点**：长作业后的短作业等待时间很长，对长作业有利，对短作业不利。
- **应用**：
    - **用于作业**：先到后备队列的作业先调度
    - **用于进程**：先到就绪队列的进程先调度

### 最短作业优先（SJF）
- **思想**：追求最少的平均等待时间，最少的平均周转时间、最少的平均带权周转时间，非抢占式。
- **抢占式版本**：**最短剩余时间优先**算法。每当**有新进程进入就绪队列时**就会改变就绪队列，选择剩余时间最短的去执行。
- **规则**：按照当前已经到达的**最短**（服务时间最短）的作业/进程先进行服务
- **优缺点**：
    - **优点**：抢占式时，**平均等待时间和平均周转时间最少**。在进程**几乎同时**到达时，平均等待时间和平均周转时间最少。
    - **缺点**：不公平，对短作业有利，对长作业不利，可能产生**饥饿**现象（长作业迟迟得不到服务）。
- **应用**：
    - **用于作业**：-
    - **用于进程**：称为**短进程优先**算法

### 高响应比优先（HRRN）
- **思想**：兼顾作业的等待时间和运行时间，定义了**响应比**。
- **规则**：按照当前已经到达的**最高响应比**（$\frac{等待时间 + 要求服务的时间}{要求服务的时间}$）的作业/进程先进行服务，**非抢占式**。
- **优缺点**：
    - **优点**：综合考虑了**等待时间**和**运行时间**：
        - 等待时间相同时，要求服务时间短的先运行；
        - 要求服务时间相同时，等待时间长的先运行。
        - 等待时间越长，相应比越高，避免了长作业饥饿的问题
    - **缺点**：长作业后的短作业等待时间很长，对长作业有利，对短作业不利。
- **应用**：
    - **用于作业**：ok
    - **用于进程**：ok

---

上述三种调度算法一般用于早期的**批处理**系统，因为不关心**响应时间**、不区分**紧急程度**、**用户交互性**差。下面的调度算法则与现代**交互式**系统有关：

---

### 时间片轮转（RR）
- **规则**：
    - 公平地、轮流地为各个进程服务，让每个进程在一定**时间间隔**（**时间片**，例如100ms）内都可以得到响应。
    - 如果一个进程在时间片内未执行完，则剥夺处理机放到队列末尾，因此是**抢占式**（时钟中断）的。
    - 如果一个时间节点同时有新进程加入队列和进程完成，一般认为新进程在完成进程的前面。
    - 如果一个进程的执行时间小于时间片，则主动放弃处理机并**发生调度**。
- **优缺点**：
    - **优点**：公平、响应快、不会导致饥饿，适合分时操作系统。
    - **缺点**：
        - 如果时间片**太长**，时间片轮转可能会**退化**成先来先服务算法。
        - 如果时间片**太小**，会导致进程切换过于**频繁**，导致系统花费大量的时间来处理进程切换。
        - 时间片的大小一般需要让切换进程的开销占比不超过 `1`%。
- **应用**：
    - **用于作业**：只有作业放入内存建立了进程之后才能被分配时间片，因此不适用于作业。
    - **用于进程**：ok

### 优先级队列
- **规则**：
    - 根据紧急程度，为每个作业 / 进程设置**优先级**，调度时选择**最高优先级**的执行。
    -   抢占式（新进程到达时和完成时检查队列）和非抢占式的版本都有。
    - 有时就绪队列会有多个，可以按照不同优先级来组织。
    -   根据优先级是否可以发生改变，分为**静态优先级**和**动态优先级**。
    -   优先级通用规则：
        1. 系统高于用户
        2. 前台高于后台
        3. 偏好 I/O 型进程（**I/O 繁忙型进程**，因为 I/O 设备和 CPU 可以并行工作）而不是计算型进程（**CPU 繁忙进程**）。
    - 动态优先级规则（类似高相应比优先）：
        1. 等待时间增加，提升优先级
        2. 占用处理机很久，降低优先级
        3. 频繁 I/O，提升优先级
- **优缺点**：
    - **优点**：可以区分任务的紧急程度，适合实时操作系统。
    - **缺点**：如果一直有高优先级的进程到来，就有可能导致低优先级进程**饥饿**。
- **应用**：
    - **用于作业**：no
    - **用于进程**：ok

### 多级反馈队列
- **规则**：
    - 设置多级就绪队列，各队列优先级从高到低，时间片从小到大（这里指的是各个级别的时间片长度是不同的）。
    - 新进程到达时先进入第 1 级队列，按先来先服务原则排队等待分配时间片，若用完时间片进程还未结束，则进入下一级队列队尾。
    - 只有第 k 级队列为空时，才会为 k + 1 级队列头部的进程分配时间片。
    - **抢占式**，如果运行第 k 级进程时，更高优先级的队列有了进程，则先运行新进程，将当前进程放入第 k 级队列尾部。
- **优缺点**：
    - **优点**：公平（FCFS）、高响应（RR）、短进程完成快（SPF）、避免用户作假、可以灵活调整偏好程度（例如将 I/O 密集型进程放回原队列，保证其高优先级）。
    - **缺点**：可能造成**饥饿**。
- **应用**：
    - **用于作业**：只有作业放入内存建立了进程之后才能被分配时间片，因此不适用于作业。
    - **用于进程**：ok

### 多级队列调度
- **规则**：
    - 设置多级就绪队列，各队列优先级不同，或按照时间片进行划分。
    - 固定优先级（不太合理）：只要高优先级的队列有东西，则只运行高优先级。
    - 时间片划分：为队列分配时间，例如高优先级50%，中优先级40%，低优先级10%
    - 各个队列中间的调度策略可以不同，例如高级用优先级调度、中级用RR、低级用FCFS。
- **优缺点**：
    - **优点**：公平（FCFS）、高响应（RR）、短进程完成快（SPF）、避免用户作假、可以灵活调整偏好程度（例如将 I/O 密集型进程放回原队列，保证其高优先级）。
    - **缺点**：可能造成**饥饿**。
- **应用**：
    - **用于作业**：只有作业放入内存建立了进程之后才能被分配时间片，因此不适用于作业。
    - **用于进程**：ok

# 同步与互斥
## 进程同步与进程互斥
**什么是进程同步？**

进程本身具有**异步性**：各个进程并发执行，以独立的、不可预知的速度向前推进。但有时，我们希望进程以某种顺序运行（例如先写后读），这就需要依赖**进程同步**。

**同步**又称**直接制约关系**，指为了完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上**协调**它们的**工作次序**而产生的<u>制约关系</u>。进程间的直接制约关系就是源于它们之间的相互合作。

---

**什么是进程互斥？**

互斥指的是**一个时间段内只允许一个进程**访问某个资源，其他想访问资源的进程必须等待，直到资源被释放。一段时间内只允许一个进程使用的资源被称为**临界资源**，许多物理设备（例如摄像头、打印机）都是临界资源。

临界资源的访问在逻辑上分为以下四个部分：

- **进入区**：负责检查**是否可以进入**临界区，若可进入，则应设置**正在访问临界资源的标志**（可以理解成“上锁”，其他进程检查时就无法进入访问了），以阻止其他进程同时进入临界区。
- **临界区（临界段）**：critical section，访问临界资源的那段代码。
- **退出区**：负责解除**正在访问临界资源的标志**（可以理解成“解锁”）。
- **剩余区**：remainder section，做一些其他处理。

并且临界资源的互斥访问应当遵守以下原则：

1. **空闲让进**：临界区**空闲**时，可以允许一个请求进入临界区的进程**立即进入**临界区。
2. **忙则等待**：当一个进程已经在临界区时，其他试图进入临界区的进程**必须等待**。
3. **有限等待**：对请求访问的进程，应保证能**在有限时间内进入**临界区（保证不会饥饿）。
4. **让权等待**：当进程不能进入临界区时，应当立即**释放处理机**（进入阻塞态），防止进程忙等待。

## 进程互斥的软件实现
### 单标志法
<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VAb62b2ae8777f7f7ac098ef75d362fa21.png" width=450 />

**思想**：两个进程在**访问完临界区后**，会把临界区的**权限转移**通过 `trun` 变量交给另一个进程。也就是说，**每个进程进入临界区的权限只能被另一个进程赋予**。
**问题**：违反了**空闲让进**原则。

### 双标志先检查法
- **思想**：用一个布尔数组 `flag[]` 来表示各个进程**是否想要进入临界区**（即“进入意愿”），例如当 `flag[0] = true` 时表示 0 号进程想要进入临界区。
    1. 每个进程在进入临界区之前会先检查是否有别的进程想要进入临界区；
    2. 如果没有就把自己的标志位设成 `true`（上锁），开始访问临界区；
    3. 使用完之后，把自身标志位设为 `false`（解锁）。
- **问题**：可能在并发中两个进程都设成 `true` 后被剥夺，导致两个进程都在临界区，违反了**忙则等待**原则。这是**非原子操作**导致的。

### 双标志后检查法
- **思想**：同样用一个布尔数组 `flag[]` 来表示各个进程**是否想要进入临界区**，
    1. 但先上锁
    2. 再检查，如果没有其他进程要使用临界资源则开始使用
    3. 用完解锁。
- **问题**：可能会导致**循环等待**，违背了**空闲让进**和**有限等待**原则，产生**饥饿**现象。

### Peterson算法
<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VAbcb67c6d69ed516943950ed06b1cca79.png" width=450 />

- **思想**：结合了双标志法和单标志法的思想，如果两个进程都想进入临界区，那么可以让进程尝试“孔融让梨”。Peterson算法同样用一个布尔数组 `flag[]` 来表示各个进程**是否想要进入临界区**。进程在进入区会：
    1. 把自己的标志位设成 `true`，表示自己想要进入临界区；
    2. 把 `trun` 设为另一个进程，表示谦让；
    3. 检查其他进程**是否想使用**临界资源，且**最后是否是自己表示了谦让**（对方没有让回来），如果是就继续等待，否则使用临界资源；
    4. 用完之后设置自己的标志位为 `false`。
- **问题**：未遵循**让权等待**原则。

## 进程互斥的硬件实现
### 中断屏蔽法
- **思想**：利用原语的**关中断-开中断**思想，在使用临界资源时关中断（不会发生进程切换），直到使用完再开中断，简单高效逻辑清晰。
- **问题**：不适用于**多处理机**，因为关中断指令只对一个处理机有效。开关中断是特权指令，只适用于**内核进程**（用户进程没有权限执行）。

### TestAndSetLock（TS指令/TSL指令）
- **思想**：TS / TSL指令是**硬件实现**的，不可被**中断**。系统有个**共享变量** `lock` 来表示是否有其他进程在使用临界资源。TSL 实现简单且适用于多处理机环境。
- **问题**：不满足**让权等待**原则，想进入临界区的进程会一直卡在 `while` 循环执行 TSL 指令。

### Swap指令（XCHG指令）
- **思想**：Swap 指令也叫 **Exchange** 指令，或简称为 **XCHG** 指令，是**硬件实现**的，不可被**中断**。swap 指令交换了两个变量的**布尔值**，通过 `lock` 记录临界区是否被上锁。Swap 实现简单且适用于多处理机环境。
- **问题**：不满足**让权等待**原则，想进入临界区的进程会一直卡在 `while` 循环，造成**忙等待**。

## 互斥锁
“锁”可以被简单理解为一个**布尔型**的变量，表示当前是否被上锁。互斥锁用于实现资源互斥，包含 `acquire` 方法（用于获得锁）和 `release` 方法（释放锁），两个方法必须是**原子操作**。

```C++
// 获得锁
acquire(){
    while(!available)；   // 忙等待（导致CPU资源浪费）
    available = false;  // 获得锁
}
// 释放锁
release(){
    available = true;   // 释放锁
}
```

需要连续循环忙等的互斥锁可以被称为**自旋锁**（spin lock），例如 **TSL** 指令、**swap** 指、**单标志法**都是自旋锁。

{% note info **忙等待的优缺点** %}
锁的忙等待违反了“**让权等待**”原则，导致 CPU 资源浪费，那为什么我们还要在一些场景下使用忙等待呢？

忙等待期间不用切换进程上下文，因此在多处理器系统中，如果上锁的时间很短，则等待的**代价很低**。在多处理器系统中，可以一个核忙等，其他核照常工作，并快速释放临界区。
但忙等不适合单处理机系统，因为**忙等的过程中不可能解锁**。
{% endnote %}

## 信号量
前面我们介绍的几种实现互斥的方法都无法满足**让权等待**原则，于是引出了**信号量**机制。一个信号量就是一个**变量**（可以是整型，也可以是更复杂的记录型变量），可以用来**表示系统中某种资源的数量**。我们可以通过一对**原语**（`wait(S)` 和 `signal(S)`，可以被简称为 **PV 操作**）操作信号量 `S`，避免出现问题。
### 整型信号量
整型信号量用**整数型的变量**来表示信号量，用来表示系统中某种资源的**数量**。

```C++
// 资源数量
int S = 1;
// P 操作
void wait(int S){
    while(S <= 0);  // 没有资源了
    S = S - 1;  // 获得一个资源
}
// V 操作
void signal(int S){
    S = S + 1;  // 释放一个资源
}
```

所有进程在申请资源时都会经历类似的事情：
1. 调用 `wait` 原语申请资源
2. 使用临界资源
3. 调用 `signal` 释放资源

整型信号量还是存在**忙等待**的问题，并不满足让权等待的原则。

### 记录型信号量
记录型信号量用**记录型的变量**（例如结构体）来表示信号量：

```C++
// 信号量
typedef struct{
    int value;  // 资源数量
    struct process *L;  // 等待队列
} semaphore;
// P 操作
void wait(semaphore S){
    S.value--;
    // 检查值，如果发现资源不够了则阻塞当前进程，并将进程挂到信号量的等待队列中
    if(S.value < 0){
        block(S.L);
    }
}
// V 操作
void signal(semaphore S){
    S.value++;
    // 用完资源，发现还有进程在等待队列，则唤醒队列中阻塞的进程
    if(S.value <= 0){
        wakeup(S.L);
    }
}
```
可以看出，通过 `block` 原语和 `wakeup` 原语，记录型信号量解决了**让权等待**的问题，主动自我阻塞放弃了 CPU 资源。

### 用信号量实现互斥和同步
**信号量实现进程互斥**
1. 划分临界资源区域
2. 设置**互斥信号量** `mutex`，初始值为 `1`（只有一个进程能进入临界区）
3. 在进入区执行 `P(mutex)` 申请资源
4. 在退出区执行 `V(mutex)` 释放资源

这背后的思想其实就是信号量，当有进程通过 **P 操作**进入临界区后，临界资源被占用，`mutex` 变为 `0`。对不同的临界资源，其信号量是不一样的，不可以**混用**。

---

**信号量实现进程同步**
进程同步指的是让各个并发进程**按照要求有序地推进**。
1. 分析什么地方需要实现**同步关系**，即保证必须**一前一后**执行的两个操作。
2. 设置同步信号量 `S`，初始值为 `0`。
3. 在“前操作”之后执行 `V(S)`，即**前V**
4. 在“后操作”之前执行 `P(S)`，即**后P**

<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VAb4247bb84bf2085c74d90a399f47d7c2.png" />

## 问题
### 生产者-消费者问题
- **生产者进程**：可以往缓冲区中写入数据；
- **消费者进程**：可以从缓冲区中拿取数据；
- **缓冲区**：初始为空、大小为 `n` 的临界资源，各进程必须**互斥访问**（设置**互斥信号量** `mutex`）。

在这个问题中，我们采用两个**同步信号量**来保证执行顺序，避免出现覆盖问题。

1. **full**（初始值为 `0`）
    - 生产者通过 **V 操作**向缓冲区中释放资源
    - 消费者通过 **P 操作**向缓冲区申请资源
2. **empty**（初始值为 `n`）
    - 生产者通过 **P 操作**申请空闲缓冲区
    - 消费者通过 **V 操作**释放空闲缓冲区

```C++
semaphore mutex = 1;    // 互斥信号量
semaphore empty = n;    // 空闲区数量
semaphore full = 0;     // 产品数量
producer(){
    while(1){
        ...         // 生产产品
        P(empty);   // 消耗一个空闲区
        P(mutex);   // 互斥进入
        ...         // 把产品放入缓冲区，临界操作
        V(mutex);   // 互斥退出
        V(full);    // 增加一个产品
    }
}

consumer(){
    while(1){
        P(full);    // 申请一个资源
        P(mutex);   // 互斥进入
        ...         // 拿产品
        V(mutex);   // 互斥退出
        V(empty);   // 释放一个空闲区
        ...         // 使用产品
    }
}
```

P 操作中，**互斥操作一定要在同步操作之后**，否则可能出现死锁的问题。V 操作的顺序可以**交换**。

### 多生产者-多消费者问题
这里的多指的是多种**类型**的生产者和多种**类型**的消费者。
- **生产者进程**：可以往缓冲区中写入数据；
- **消费者进程**：可以从缓冲区中拿取数据；
- **缓冲区**：初始为空、大小为 `n` 的临界资源，各进程必须**互斥访问**（设置**互斥信号量** `mutex`）。

这个问题的**同步关系**比单生产者-消费者问题更复杂一些，消费者 A 在生产者 A 生产完之后才能拿资源；消费者 B 在生产者 B 生产完之后才能拿资源；只有盘子为空时生产者们才能放资源。

因此在这个问题中，我们采用三个（取决于有几种生产者-消费者）**同步信号量**来保证执行顺序，避免出现覆盖问题。

1. **fullA**（初始值为 `0`）
    - 生产者A通过 **V 操作**向缓冲区中释放资源
    - 消费者A通过 **P 操作**向缓冲区申请资源
2. **fullB**（初始值为 `0`）
    - 生产者B通过 **V 操作**向缓冲区中释放资源
    - 消费者B通过 **P 操作**向缓冲区申请资源
3. **empty**（初始值为 `n`）
    - 生产者通过 **P 操作**申请空闲缓冲区
    - 消费者通过 **V 操作**释放空闲缓冲区

```C++
semaphore mutex = 1;    // 互斥信号量
semaphore empty = n;    // 空闲区数量
semaphore fullA = 0;    // A 产品数量
semaphore fullB = 0;    // B 产品数量
producerA(){
    while(1){
        ...         // 生产产品
        P(empty);   // 消耗一个空闲区
        P(mutex);   // 互斥进入
        ...         // 把产品放入缓冲区，临界操作
        V(mutex);   // 互斥退出
        V(fullA);    // 增加一个产品
    }
}
consumerA(){
    while(1){
        P(fullA);    // 申请一个资源
        P(mutex);   // 互斥进入
        ...         // 拿产品
        V(mutex);   // 互斥退出
        V(empty);   // 释放一个空闲区
        ...         // 使用产品
    }
}
producerB(){
    while(1){
        ...         // 生产产品
        P(empty);   // 消耗一个空闲区
        P(mutex);   // 互斥进入
        ...         // 把产品放入缓冲区，临界操作
        V(mutex);   // 互斥退出
        V(fullB);    // 增加一个产品
    }
}

consumerB(){
    while(1){
        P(fullB);    // 申请一个资源
        P(mutex);   // 互斥进入
        ...         // 拿产品
        V(mutex);   // 互斥退出
        V(empty);   // 释放一个空闲区
        ...         // 使用产品
    }
}
```

### 吸烟者问题
- **吸烟者进程**：不停地卷烟并吸烟，卷烟需要**烟草**、**纸**和**胶水**（不同的资源）。不同的吸烟者进程手上有一种不同的原材料。吸烟完成后发送信号提醒供应者进货；
- **供应者进程**：无限量提供三种材料，每次提供两种材料（资源组合，满足其中一位吸烟者），**轮流**（通过 `while` 循环实现）满足所有吸烟者；
- **缓冲区**：初始为空、大小为 `n` 的临界资源，各进程必须**互斥访问**（设置**互斥信号量** `mutex`）。

这个问题同样存在同步关系，即：
1. 供应者提供了特定类型的材料后，某一吸烟者才能开始吸烟。
2. 吸烟者发出完成信号后供应者才能提供香烟。

因此在这个问题中，我们采用三个（取决于有几种生产者-消费者）**同步信号量**来保证执行顺序，避免出现覆盖问题。

1. **fullA**（初始值为 `0`）
    - 供应者A通过 **V 操作**向缓冲区中提供资源组合A
    - 吸烟者A通过 **P 操作**向缓冲区申请资源组合A
2. **fullB**（初始值为 `0`）
    - 供应者B通过 **V 操作**向缓冲区中释放资源组合B
    - 吸烟者B通过 **P 操作**向缓冲区申请资源组合B
3. **empty**（初始值为 `n`）
    - 供应者通过 **P 操作**申请空闲缓冲区
    - 吸烟者通过 **V 操作**释放空闲缓冲区

在代码层面，吸烟者问题和多生产者-消费者问题非常类似，除了供应者通过 `while` 循环不断供应之外。当 `n` = 1 时，可以不设置互斥锁。

### 读者写者问题
- **读者进程**：不停地读共享文件，允许多个读者在**写操作完成后**同时读共享文件；
- **写者进程**：不停地写共享文件，同一时间只允许**一个**写者进行写操作；
- **共享文件**：由数据记录组成，写进程需要**互斥访问**（设置**互斥信号量** `mutex`），读进程在读的时候写进程无法修改文件。

对于这个问题，我们可以设置一个变量 `count` 维护当前有几个进程正在读文件。如果是第一个读者则对文件**加锁**。

```C++
semaphore mutex = 1;
int count = 0;
semaphore reader;   // 保证对count变量实现互斥访问
// 写者
writer(){
    while(1){
        P(mutex);   // 写之前加锁
        ...         // 写
        V(mutex);   // 写完解锁
    }
}
// 读者
reader(){
    while(1){
        P(reader);      // 保护count
        if(count == 0)  // 第一个写者
            P(mutex);   // 读之前加锁
        count++；
        V(reader);      // 操作完成，取消保护count
        ...             // 读文件
        P(reader);      // 保护count
        count--;
        if(count == 0)  // 最后一个读者
            V(mutex);   // 全读完了解锁
        V(reader);      // 操作完成，取消保护count
    }
}
```

在读者-写者问题中，只要存在读进程，写进程就会被一直阻塞等待，甚至可能**饿死**。由此可见，在这种情形下**读进程具有更高的优先级**。如果要实现**读写公平**，则需额外再设置一个信号量 `w` 用于阻塞进程：

```C++
semaphore mutex = 1;
int count = 0;
semaphore reader = 1;   // 保证对count变量实现互斥访问
semaphore w = 1;        // 用于实现写优先
// 写者
writer(){
    while(1){
        P(w);
        P(mutex);   // 写之前加锁
        ...         // 写
        V(mutex);   // 写完解锁
        V(w);
    }
}
// 读者
reader(){
    while(1){
        P(w);           // 如果接下来发生进程切换，读进程会因为没有w信号量而被阻塞，直到读进程执行 V(w) 操作
        P(reader);      // 保护count
        if(count == 0)  // 第一个写者
            P(mutex);   // 读之前加锁
        count++；
        V(reader);      // 操作完成，取消保护count
        V(w);
        ...             // 读文件
        P(reader);      // 保护count
        count--;
        if(count == 0)  // 最后一个读者
            V(mutex);   // 全读完了解锁
        V(reader);      // 操作完成，取消保护count
    }
}
```

### 哲学家进餐问题
<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA4aefcdc6543a0f84d9251568ba91748d.png" width=350 />

- **哲学家**：哲学家吃饭需要两根筷子，其左手边和右手边各有一支，需要两支筷子都能用（一根一根拿起）才能吃饭，如果筷子已经在其他人手上则需等待，吃完后放下筷子；
- **筷子**：资源。

对于这个问题，哲学家与左右邻居之间的筷子的访问是**互斥关系**，不存在同步关系，核心在于**避免死锁**。我们可以设置一个信号量数组 `chopstick[5] = {1, 1, 1, 1, 1}` 用于实现对五支筷子的互斥访问，将哲学家按照从 `0` 到 `4` 进行编号，哲学家左边的筷子是 `i`，右边的是 `(i + 1) % 5`。

为了避免**死锁**，我们可以做出一些限制，例如：
1. 最多允许四个哲学家同时进餐（这样保证留出一根筷子，允许一位哲学家完成进餐操作）
2. 要求奇数的哲学家先拿左边的筷子，偶数的哲学家先拿右边的筷子。这个规则可以保证两个相邻的奇偶号哲学家只有一个能拿起第一根筷子，另一个会被**阻塞**。
3. 只有当哲学家左右两根筷子都能用时才能吃饭。这个规则需要一个额外的信号量 `mutex` 保护左右检查。但由于 `mutex` 的存在，同时只能有一个哲学家吃饭。

```C++
semaphore chopstick[5] = {1, 1, 1, 1, 1};   // 声明方式
```

## 管程
PV 操作具有一定的复杂性，有没有办法来帮助程序员更好的处理进程间的同步与互斥呢？聪明的计算机学家在 Pascall 语言中首次提出了管程的概念。

**什么是管程？**
管程类似一个“**类**”，由这些部分组成：
1. 局部于管程的**共享数据结构**声明；
2. 对该数据结构进行操作的**一组过程**（可以理解成函数）；
3. 对于局部于管程的共享数据**设置初始值**的语句；
4. 管程有一个**名字**。

---

**管程的基本特征**
1. 局部于管程的共享数据（私有的）只能被局部于管程的过程（函数）所访问；
2. 一个进程只有通过调用管程内的过程才能进入管程访问共享数据；
3. **每次只允许一个进程在管程内执行某个内部过程**。

<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VAe7d8bb3cd7eb2242e2a4c023b5b406a7.png" width=400 />

# 死锁
## 什么是死锁
**什么是死锁？**

进程都占有一个资源，同时又在等待另一个人手里的资源，即发生**死锁**。
在并发环境下，各进程竞争资源而造成的一种**互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进**的现象，就是死锁。如果死锁没有被外力干涉解除，这些进程都将**无法向前推进**。

---

**死锁、饥饿、死循环的区别**

这三者都是程序的异常状态：
- **死锁**：各进程（**至少两个**）互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的状态。
- **饥饿**：由于长期得不到想要的资源，某进程（可能只有**一个**）无法向前推进的现象。
- **死循环**：某进程执行过程中一直跳不出某个循环的现象，有时是因为程序bug导致的，有时是故意设计的。

---

**死锁产生的必要条件**

产生死锁必须满足以下四个条件，只要其中**任意一个条件不成立**，死锁就不会发生：
1. **互斥**：资源只能互斥地访问，同一时间只有一个进程可以占用资源；
2. **不剥夺**：进程在使用完资源之前，其他进程不能强行剥夺资源，只能由进程**主动释放资源**。
3. **请求和保持**：进程在保持资源不放的同时还在请求新的资源。
4. **循环等待**：存在一种进程的**循环等待链条**，链条中每个进程已获得的资源同时被下一个进程所请求。循环等待是死锁的**必要不充分条件**。

---

**什么时候会发生死锁**
1. **对系统资源的竞争**：系统资源是不可剥夺的。
2. **进程推进顺序非法**：导致出现互相占有资源、互相请求资源。
3. **信号量使用不当**：例如先执行同步信号量的 P 操作，再执行互斥信号量的 P 操作。

## 预防死锁
预防死锁指的是破坏死锁发生的四个条件中的一个或几个，是一种**静态策略**。

- **破坏互斥条件**
    - **思想**：把只能互斥使用的资源改造成**允许共享使用**，这样设备就不会进入死锁状态，例如 **SPOOLing** 技术。相当于暂时保管了两个想要使用互斥设备的进程，让它们按顺序使用。
    - **缺点**：很多时候**无法破坏互斥条件**。
- **破坏不剥夺条件**
    - **思想**：当进程请求新资源失败时，进程必须立即释放所有持有的资源（主动释放），等之后再申请。也可以由系统（考虑到优先级）强行剥夺而非主动。
    - **缺点**：
        1. 实现起来比较复杂。
        2. 如果要强行释放资源有可能造成进程之前的工作失效，只适用于像 CPU 这样的**易于保存和恢复状态**的资源。
        3. 频繁释放和申请会**增加系统开销**。
        4. 如果一个进程一直得不到资源，可能会导致**饥饿**。
- **破坏请求和保持条件**
    - **思想**：进程**一次性申请完全部**所需的资源，在资源未满足前不允许运行，一旦运行后资源就归该进程所有，不再请求其他临界资源。
    - **缺点**：有的资源只需要使用很短的时间，但被某个进程一直占用，导致**系统资源利用率降低**，也可能会导致饥饿。
- **破坏循环等待条件**
    - **思想**：
        1. 给系统资源**编号**，规定各个进程必须**按照编号递增的顺序请求资源**，同类资源（编号相同的资源）一次性申请完。
        2. 一个进程已占有小编号资源时才能申请大编号资源，有大编号资源的进程不能逆向申请小编号的资源，从而避免循环等待的现象。
    - **缺点**：
        1. 不方便为新设备编号。
        2. 进程实际使用资源的顺序可能和编号递增顺序不一致，导致资源浪费。
        3. 因为必须按照编号递增的顺序申请资源，因此用户编程很麻烦。

## 避免死锁
用某种方式防止系统进入不安全状态，从而避免死锁。其中最著名的方式就是**银行家算法**，是一种**动态策略**。

**什么是安全序列**

所谓的**安全序列**，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要找出一个安全序列（可以存在**多个**），系统就是**安全状态**。

---

**什么是系统的不安全状态**

如果系统找不出任何一个安全序列，系统就进入了**不安全状态**，这意味着之后所有的进程都可能无法顺利执行。当然，如果有系统提前归还的资源，那**系统也有可能重新回到安全状态**。
系统处于安全状态则**一定不会**发生死锁；系统处于不安全状态则**有可能**发生死锁。

---

**银行家算法**
<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA0a7663497d3f04cd295423d0827e341b.png" width=400 />

**核心思想**：在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。
一般来说，题目会给出上图的表格，表示进程**需要多少资源**、**已经分配了多少资源**，判断是否能找到一个安全序列。在这类问题中，银行家算法要做的事就是找到能满足当前剩余资源的进程（例如上表的 `P1` 和 `P3`），逐步地将进程加入安全序列，直到所有进程执行完（也有可能无法执行）。

## 检测和解除
**死锁的检测**
为了能对系统是否已经发生了死锁进行检测，必须：
1. 用某种**数据结构**来保存资源的请求和分配信息。
    - 可以采用**资源分配图**，利用**进程节点**（对应一个进程）、**资源节点**（对应一类资源）、进程-资源**边**（表示进程想申请几个资源）、资源-进程**边**（表示已经为进程分配了多少资源）
2. 提供**一种算法**（看能不能消除所有边），利用上述信息检测系统是否进入了死锁状态。

如何通过资源分配图检测是否存在死锁呢？可以通过以下算法：
1. 在资源分配图中，找出既不阻塞又不是孤点的进程 `Pi`(即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。如下图中，R1没有空闲资源，R2有一个空闲资源。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源)。消去它所有的请求边和分配变，使之称为孤立的结点。在下图中P1 是满足这一条件的进程结点，于是将P1的所有边消去。
2. 进程 Pi所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。在下图中，P2就满足这样的条件。根据第一条中的方法进行一系列简化后，若能消去所有的边，则称该图是**可完全简化**的。
3. 如果不可简化，则系统会发生死锁，这被称为**死锁定理**。

---

**死锁的解除**

解除死锁的主要方法有：
1. **资源剥夺法**：挂起（暂时放到边上）某些死锁进程并**抢占它的资源**，将这些资源分配给其他的死锁进程。该方法需要注意防止挂起的进程长时间得不到资源而**饥饿**。
2. **撤销进程法（终止进程法）**：强制撤销部分甚至所有死锁进程，剥夺它们的资源。这种方法虽然简单，但可能导致一些执行了很长时间的进程功亏一篑。
3. **进程回退法**：让一个或多个死锁进程回退到足以避免死锁的地步。这要求系统记录进程的历史信息，设置**还原点**。

那么应该如何决定撤销/回退哪个进程呢？可以从以下几个维度考虑：
- **进程优先级**：优先解除低优先级的进程。
- **已经执行了多长时间**：优先解除已经执行时间短的。
- **还要多久能完成**：优先解除剩余时间长的。
- **已经使用了多少资源**：优先解除资源占用多的。
- **进程是交互式的还是批处理的**：优先解除批处理的进程。