---
layout: post
title: 操作系统-3-内存管理
date: 2025-02-02 14:00:23
tags:
hidden: true
---

# 什么是内存
内存可以用来**存放数据**。程序执行前需要先把数据放到**内存**中此能被 CPU 处理，这是因为从外存读写数据很**慢**，而放到内存中可以大大提升读写速度，从而缓和 CPU 与硬盘之间的速度矛盾。

在多道程序并发环境下，系统中可能会有很多程序并发执行，如何区分各个进程把数据存放到内存中的什么地方了呢？内存中存在一个一个**存储单元**，内存通过编号（**地址**）来实现存储单元标识。

{% note info **一个存储单元可以存放多少数据？** %}
这取决于计算机的**编址方式**。
- **按字节编址**：可以存储 1 **字节**（1B），即 8 个二进制位。
- **按字编址**：可以存储 1 **字**，字的大小取决于计算机的**字长**。
{% endnote %}

{% note info **存储单位** %}
1KB = $2^{10}$
1MB = $2^{20}$
1GB = $2^{30}$
{% endnote %}

# 内存管理
内存管理主要做三件事：
1. 内存空间的**分配与回收**
2. 操作系统需要提供某种技术从逻辑上**对内存空间进行扩充**（虚拟内存）
3. 提供**地址转换**功能，负责程序的**逻辑地址**与**物理地址**的转换。
    - **绝对装入**：编译时产生**绝对地址**，适合单道程序。
    - **可重定位装入**：装入时装入程序将逻辑地址转换为物理地址，适合早期多道批处理系统。
    - **动态运行时装入**：运行时将逻辑地址转换为物理地址，需要设置**重定位寄存器**，适合现代操作系统。
4. **内存保护**：不同的进程只能访问各自的内存空间，可以采取以下两种方法：
    - 在 CPU 中设置一对**上、下限寄存器**，其中存放了进程的**上、下限内存地址**。进程的指令要访问某个地址时，CPU 检查其是否越界。
    - 采用**重定位地址寄存器**（**基址寄存器**，记录了起始物理地址）和**界地址寄存器**（**限长寄存器**，记录了最大逻辑地址，即 内存长度）进行越界检查。

## 内存空间的分配与回收
### 连续分配
**单一连续分配**
<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA3a0e273aab601beff2f9cd7adb7e3ec2.png" width=220 />

单一连续分配模式下，内存中**只能有一道用户程序**（**单一**），用户程序独占整个用户空间（所以是**连续**的）。在这种分配方式中，内存被分成了**系统区**和**用户区**两个部分。

- 系统区通常位于内存的低地址部分，用于存放操作系统的相关数据；
- 用户区用于存放用户进程的数据。


**优点**：实现**简单**、无**外部碎片**，不一定需要采用内存保护，适合早期个人操作系统（如 MS-DOS）。

**缺点**：只能用于单用户、单任务的操作系统，有**内部碎片**，存储器利用率**极低**。

{% note info **什么是内存碎片** %}
分配给某进程的内存区域中，如果有些部分没有用上（是空闲的），这就是内部碎片。
{% endnote %}

---

**固定分区分配**
<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VAb4de1bb60883e80e9399b8574cb41ebb.png" width=340 />

固定分区分配技术是为支持多道程序系统而诞生的，允许在内存中装入不会相互干扰的多道程序。该技术将整个**用户空间**划分成若干个**固定大小的分区**（各个分区的大小可以相等也可以不相等），在每个分区中**只装入一道作业**。

> 各个分区大小相同很适合**控制多个相同对象的场合**，但缺乏灵活性；分区大小不同增加了灵活性，可以满足不同大小的进程需求。

操作系统需要建立**分区说明表**来实现各个分区的分配与回收，每个表项对应一个分区，记录了**分区大小**、**起始地址**、**分配状态**等，通常按照分区大小排列。

**优点**：实现**简单**，无**外部碎片**。

**缺点**：当用户程序太大时，可能所有分区都无法满足需求、可能产生**内部碎片**，内存利用率**低**。

---

**动态分区分配**
<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA68c9af34b09af17177e284250e1e80f6.png" width=220 />

动态分区分配又叫**可变分区分配**，该技术**不会预先划分内存分区**，而是在进程装入内存时根据进程的大小**动态地建立分区**，使分区的大小正好适合进程的需要，因此系统分区的大小和数目是动态变化的。

动态分区分配采用**空闲分区表**或**空闲分区链**记录分区信息：
- **空闲分区表**：类似分区说明表，记录了分区大小、起始地址、分配状态和分区编号。
- **空闲分区链**：采用**双向链表**的方式，在每个分区的起始部分和末尾部分设置前驱和后驱指针。分区的起始部分可以记录分区大小等信息。

把一个新作业装入内存时，需按照一定的**动态分区分配算法**进行分配：

1. **首次适应算法**（First Fit）
    - **思想**：每次从低地址开始查找，找到**第一个**能满足大小的空闲分区。
    - **实现**：空闲分区以**地址递增**的次序排列，分配时从表（或链）中找到第一个满足大小的空闲分区即可。
    - **缺点**：**低地址部分**可能出现很多小的空闲分区，查找时需要经过这些分区，增加了查找的开销。
2. **邻近适应算法**（Next Fit）
    - **思想**：为了解决首次适应算法的问题，每次都从**上次查找结束的位置**开始检索。
    - **实现**：空闲分区以**地址递增**的次序排列（可排成一个**循环链表**），分配时从表（或链）中上次查找结束的位置开始找到第一个满足大小的空闲分区即可。
    - **缺点**：相较于首次适应算法，高地址部分的大分区难以被保留，导致最后可能无大分区可用。
3. **最佳适应算法**（Bet Fit）
    - **思想**：该算法期望留下更大的连续空闲区，因此分配时优先使用**更小的空闲区**。
    - **实现**：空闲分区以**容量递增**的次序排列，分配时从表（或链）中找到第一个满足大小的空闲分区即可。
    - **缺点**：会留下越来越多很小、难以利用的内存块，产生**外部碎片**。
4. **最坏适应算法**（Worst Fit）
    - **思想**：为了解决最佳适应算法产生的外部碎片问题，分配时优先使用**更大的空闲区**。
    - **实现**：空闲分区以**容量递减**的次序排列，分配时从表（或链）中找到第一个满足大小的空闲分区即可。
    - **缺点**：虽然最坏适应算法可以让分配后留下的空闲区更大（更可用），但这种方式会导致较大的**连续空闲区被迅速用完**，导致大进程到来时没有内存分区可用。

该技术没有**内部碎片**，但可能会导致**外部碎片**产生。

{% note info **什么是外部碎片** %}
外部碎片指的是内存中某些空闲分区太小（太碎了，和碎片一样）而难以利用的情况。操作系统可以通过**紧凑**技术，将内存分区挪位成连续分区来解决外部碎片。
{% endnote %}

### 非连续分配
非连续分配的“非连续”指的是进程数据以离散的方式装入内存中。

#### 基本分页存储管理
<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA00f57c306b3cce2c27d655c80b3304b5.png" width=170 />

**原理**
    - 分页存储将内存空间分成一个个**大小相等的分区**，每个分区就是一个**页框**（也叫**页帧**、**物理页面**），代表了一个内存块 / 物理块。每个页框有一个编号（即**页框号**），从 `0` 开始。
    - 分页存储将进程的**逻辑地址空间**也分为与页框大小相等的一个个部分，每个部分成为一个**页**（或**页面**），通过**页号**来编号，从 `0` 开始。
    - 操作系统**以页框为单位**为各个进程分配内存空间，进程的每个**页面分别放入一个页框**中。换句话说，进程的页面与内存的页框有**一一对应**的关系。
    - 操作系统为每个进程建立了一个**页表**（存放在 PCB 里），用于记录每个页面存放在哪个页框里。页面**不必连续存放**，可以放到不相邻的页框里。虽然页面是离散的，但各个页面内部的数据是连续的。
        - 如果我们知道**物理内存大小**和**页面大小**，我们就可以知道内存中可以划分出多少个页面（例如 $2^{20}-1$ 个）。这样的话我们就需要 20 bit 来表示内存块号，换算成字节为 3 B。

<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VAdc7e5761ff6752716a5e33289a7ee654.png" />

另外，如果每个页面大小是 $2^k$ B，用二进制数表示逻辑地址，则一个逻辑地址的二进制数的末尾 $k$ 位即**页内偏移量**，其余部分是**页号**。

<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA9880d1a3eb86c9d3acbca33b87dffa40.png" />

---

**基本地址变换机构**

**基本地址变换机构**即用于实现基本分页存储管理中**逻辑地址到物理地址转换的一组硬件机构**。基本地址变换机构可以借助进程的**页表**进行转换。

- **原理**：操作系统会设置一个**页表寄存器**（PTR），该寄存器存放了**页表在内存中的起始地址 `F`** 和**页表长度 `M`**。进程未执行时，**页表起始地址**和**页表长度**被放在进程的 PCB 里，进程被调度之后存放到 PRT 中。
    1. 根据逻辑地址计算出**页号**、**页内偏移量**；
    2. 判断页号是否越界，如果越界触发**内中断**；
    3. 查询页表，找到页号对应的页表项，确定页面存放的**内存块号**（页框号）；
    4. 用内存块号和页内偏移量得到实际的**物理地址**；
    5. 访问目标内存单元。

<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA3621ff84941b9d8a06d7a8912ea2fe45.png" />
<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA7dd059bd8d6867ce2c47835c1c885a3e.png" />

---

**具有快表的地址变换机构**

这里的**快表**指的不是对链表提速的特殊数据结构，而是**联想寄存器**（TLB）。快表是一种**访问速度比内存快很多的高速缓存**（高速缓存被集成在 CPU 内，因此不属于内存），用来存放**最近访问过的页表项的副本**，可以加快地址变换的速度。与此对应，内存中的页表被称为**慢表**。进程切换时，快表的内容会被**清空**（因为对于每个进程来说，它们对应的内存空间是不同的，进程是资源划分的基本单位）。

具有快表的地址变换机构流程图如下：

<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VAbfa1be8ae41b4b0e56991bedd6a86307.png" />
<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA4dd7eaa867dd53de998e4265ee6be095.png" />

由于**局部性原理**，快表的命中率通常可以达到 90% 以上。
    - **时间局部性**：如果执行了程序中的某条指令，那么不久后这条指令很有可能被再次执行；如果某个数据被访问过，那么不久后该数据很可能再被访问。
    - **空间局部性**：一旦程序访问了某个存储单元，在不久之后其附近的存储单元也很有可能被访问（因为很多数据在内存中是连续存放的）。

---

**两级页表**

单级页表可能存在以下两个问题：
1. 一个页面大小 4kb 的用户进程最多有 $2^{20}$ 页，需要 10 个页框才能装得下整个页表，这样的连续空间对内存来说有点难。
2. 进程在一段时间内可能只需要访问几个页面就可以正常工作了，没有比喻让整个页表常驻内存。
由此，引出了**两级页表**的优化。两级页表将页表项离散地存储到内存块中（各级页表的大小不能超过一个页面），再通过建立一张索引表（**页目录表** / **外层页表** / **顶层页表**）来查找各个页表项。

多级页表也有一个很明显的缺点，那就是**访存次数增多**，浪费时间。

多级页表划分计算题：

<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VAe0a0768dfc66fc11e570a93e15c5fb18.png" />

#### 基本分段存储管理
分段式存储管理类似分页式存储管理，但他们离散分配时使用的基本单位不同。分页使用的是“页”和“页表”，而分段使用的是“段”和“段表”。相较于分页，分段管理更容易实现**信息的共享和保护**。

- **段**：程序按照**自身逻辑**（例如一个函数）划分出来的地址空间，每个段都有一个**段名**和**段号**（例如 main），使用户编程更方便。段在内存中占据**连续的内存空间**，各个段可以**不相邻**。每个段记录了**段号**和**段内地址偏移**的表。
    - 段号决定了每个进程可以分为多少个段
    - 段内地址位数决定了每个段的最大长度。
- **段表**：由段表项组成的一张表，每个段表项记录了该段在内存中的**段号**、**段长**和**起始地址**（基址）。

分段存储管理的内存地址查找流程如下：

<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VAdead1973deffbd285056e17b7b7cbf38.png" />

#### 段页式存储管理
**段页式存储管理**实际上就是分页式管理和分段式管理的结合。回顾分页式管理和分段式管理，我们可以总结出它们的优缺点：
- **分页式管理**
    - **优点**：内存空间利用率高，不会产生外部碎片。
    - **缺点**：不方便按照逻辑模块实现信息的共享和保护。
- **分段式管理**
    - **优点**：很方便按照逻辑模块实现信息的共享和保护。
    - **缺点**：如果段长过大，分配连续空间可能很不方便。分段式管理也可能会产生外部碎片。

二者基本是处在对立面，你的优点即我的缺点，你的缺点即我的优点。既然如此，为什么不将二者合二为一呢？

1. 将进程按逻辑模块分段（例如 main 函数）
2. 将各段分页（例如每个页面 4kb）
3. 将页面装入内存块中

可见，在段页式管理中，内存是先分段再分页的，逻辑地址的结构由**段号**、**页号**和**页内地址偏移量**组成。
- 段号位数决定每个进程可以分为几段
- 页号位数决定每个段最大能有几页
- 页内偏移量决定了页面大小、内存块的大小

在索引的管理上，段页式管理也是通过一张表实现的。表中的每项对应一个**段表项**，其中包含了**段号**、**页表长度**、**页表存放块号**（一张页表的起始地址）组成。各个段表项长度相同。一个段表可以对应多张页表（因为一个段表项就可能对应一张独立的页表）。

段页式管理的逻辑地址转换流程如下所示：

<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA93e8a3158993b938a17c1c7fe0c10a57.png" />

## 虚拟内存

### 请求分页管理方式

### 页面置换算法

### 页面分配策略

### 内存映射文件