---
layout: post
title: 操作系统-3-内存管理
date: 2025-02-02 14:00:23
tags:
hidden: true
---

# 什么是内存
内存可以用来**存放数据**。程序执行前需要先把数据放到**内存**中此能被 CPU 处理，这是因为从外存读写数据很**慢**，而放到内存中可以大大提升读写速度，从而缓和 CPU 与硬盘之间的速度矛盾。

在多道程序并发环境下，系统中可能会有很多程序并发执行，如何区分各个进程把数据存放到内存中的什么地方了呢？内存中存在一个一个**存储单元**，内存通过编号（**地址**）来实现存储单元标识。

{% note info **一个存储单元可以存放多少数据？** %}
这取决于计算机的**编址方式**。
- **按字节编址**：可以存储 1 **字节**（1B），即 8 个二进制位。
- **按字编址**：可以存储 1 **字**，字的大小取决于计算机的**字长**。
{% endnote %}

{% note info **存储单位** %}
1KB = $2^{10}$
1MB = $2^{20}$
1GB = $2^{30}$
{% endnote %}

# 内存管理
内存管理主要做三件事：
1. 内存空间的**分配与回收**
2. 操作系统需要提供某种技术从逻辑上**对内存空间进行扩充**（虚拟内存）
3. 提供**地址转换**功能，负责程序的**逻辑地址**与**物理地址**的转换。
    - **绝对装入**：编译时产生**绝对地址**，适合单道程序。
    - **可重定位装入**：装入时装入程序将逻辑地址转换为物理地址，适合早期多道批处理系统。
    - **动态运行时装入**：运行时将逻辑地址转换为物理地址，需要设置**重定位寄存器**，适合现代操作系统。
4. **内存保护**：不同的进程只能访问各自的内存空间，可以采取以下两种方法：
    - 在 CPU 中设置一对**上、下限寄存器**，其中存放了进程的**上、下限内存地址**。进程的指令要访问某个地址时，CPU 检查其是否越界。
    - 采用**重定位地址寄存器**（**基址寄存器**，记录了起始物理地址）和**界地址寄存器**（**限长寄存器**，记录了最大逻辑地址，即 内存长度）进行越界检查。

## 内存空间的分配与回收
### 连续分配
**单一连续分配**
<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA3a0e273aab601beff2f9cd7adb7e3ec2.png" width=220 />

单一连续分配模式下，内存中**只能有一道用户程序**（**单一**），用户程序独占整个用户空间（所以是**连续**的）。在这种分配方式中，内存被分成了**系统区**和**用户区**两个部分。

- 系统区通常位于内存的低地址部分，用于存放操作系统的相关数据；
- 用户区用于存放用户进程的数据。


**优点**：实现**简单**、无**外部碎片**，不一定需要采用内存保护，适合早期个人操作系统（如 MS-DOS）。

**缺点**：只能用于单用户、单任务的操作系统，有**内部碎片**，存储器利用率**极低**。

{% note info **什么是内存碎片** %}
分配给某进程的内存区域中，如果有些部分没有用上（是空闲的），这就是内部碎片。
{% endnote %}

---

**固定分区分配**
<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VAb4de1bb60883e80e9399b8574cb41ebb.png" width=340 />

固定分区分配技术是为支持多道程序系统而诞生的，允许在内存中装入不会相互干扰的多道程序。该技术将整个**用户空间**划分成若干个**固定大小的分区**（各个分区的大小可以相等也可以不相等），在每个分区中**只装入一道作业**。

> 各个分区大小相同很适合**控制多个相同对象的场合**，但缺乏灵活性；分区大小不同增加了灵活性，可以满足不同大小的进程需求。

操作系统需要建立**分区说明表**来实现各个分区的分配与回收，每个表项对应一个分区，记录了**分区大小**、**起始地址**、**分配状态**等，通常按照分区大小排列。

**优点**：实现**简单**，无**外部碎片**。

**缺点**：当用户程序太大时，可能所有分区都无法满足需求、可能产生**内部碎片**，内存利用率**低**。

---

**动态分区分配**
<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA68c9af34b09af17177e284250e1e80f6.png" width=220 />

动态分区分配又叫**可变分区分配**，该技术**不会预先划分内存分区**，而是在进程装入内存时根据进程的大小**动态地建立分区**，使分区的大小正好适合进程的需要，因此系统分区的大小和数目是动态变化的。

动态分区分配采用**空闲分区表**或**空闲分区链**记录分区信息：
- **空闲分区表**：类似分区说明表，记录了分区大小、起始地址、分配状态和分区编号。
- **空闲分区链**：采用**双向链表**的方式，在每个分区的起始部分和末尾部分设置前驱和后驱指针。分区的起始部分可以记录分区大小等信息。

把一个新作业装入内存时，需按照一定的**动态分区分配算法**进行分配：

1. **首次适应算法**（First Fit）
    - **思想**：每次从低地址开始查找，找到**第一个**能满足大小的空闲分区。
    - **实现**：空闲分区以**地址递增**的次序排列，分配时从表（或链）中找到第一个满足大小的空闲分区即可。
    - **缺点**：**低地址部分**可能出现很多小的空闲分区，查找时需要经过这些分区，增加了查找的开销。
2. **邻近适应算法**（Next Fit）
    - **思想**：为了解决首次适应算法的问题，每次都从**上次查找结束的位置**开始检索。
    - **实现**：空闲分区以**地址递增**的次序排列（可排成一个**循环链表**），分配时从表（或链）中上次查找结束的位置开始找到第一个满足大小的空闲分区即可。
    - **缺点**：相较于首次适应算法，高地址部分的大分区难以被保留，导致最后可能无大分区可用。
3. **最佳适应算法**（Bet Fit）
    - **思想**：该算法期望留下更大的连续空闲区，因此分配时优先使用**更小的空闲区**。
    - **实现**：空闲分区以**容量递增**的次序排列，分配时从表（或链）中找到第一个满足大小的空闲分区即可。
    - **缺点**：会留下越来越多很小、难以利用的内存块，产生**外部碎片**。
4. **最坏适应算法**（Worst Fit）
    - **思想**：为了解决最佳适应算法产生的外部碎片问题，分配时优先使用**更大的空闲区**。
    - **实现**：空闲分区以**容量递减**的次序排列，分配时从表（或链）中找到第一个满足大小的空闲分区即可。
    - **缺点**：虽然最坏适应算法可以让分配后留下的空闲区更大（更可用），但这种方式会导致较大的**连续空闲区被迅速用完**，导致大进程到来时没有内存分区可用。

该技术没有**内部碎片**，但可能会导致**外部碎片**产生。

{% note info **什么是外部碎片** %}
外部碎片指的是内存中某些空闲分区太小（太碎了，和碎片一样）而难以利用的情况。操作系统可以通过**紧凑**技术，将内存分区挪位成连续分区来解决外部碎片。
{% endnote %}

### 非连续分配
非连续分配的“非连续”指的是进程数据以离散的方式装入内存中。

#### 基本分页存储管理
<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA00f57c306b3cce2c27d655c80b3304b5.png" width=170 />

**原理**
    - 分页存储将内存空间分成一个个**大小相等的分区**，每个分区就是一个**页框**（也叫**页帧**、**物理页面**），代表了一个内存块 / 物理块。每个页框有一个编号（即**页框号**），从 `0` 开始。
    - 分页存储将进程的**逻辑地址空间**也分为与页框大小相等的一个个部分，每个部分成为一个**页**（或**页面**），通过**页号**来编号，从 `0` 开始。
    - 操作系统**以页框为单位**为各个进程分配内存空间，进程的每个**页面分别放入一个页框**中。换句话说，进程的页面与内存的页框有**一一对应**的关系。
    - 操作系统为每个进程建立了一个**页表**（存放在 PCB 里），用于记录每个页面存放在哪个页框里。页面**不必连续存放**，可以放到不相邻的页框里。虽然页面是离散的，但各个页面内部的数据是连续的。
        - 如果我们知道**物理内存大小**和**页面大小**，我们就可以知道内存中可以划分出多少个页面（例如 $2^{20}-1$ 个）。这样的话我们就需要 20 bit 来表示内存块号，换算成字节为 3 B。

<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VAdc7e5761ff6752716a5e33289a7ee654.png" />

另外，如果每个页面大小是 $2^k$ B，用二进制数表示逻辑地址，则一个逻辑地址的二进制数的末尾 $k$ 位即**页内偏移量**，其余部分是**页号**。

<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA9880d1a3eb86c9d3acbca33b87dffa40.png" />

---

**基本地址变换机构**

**基本地址变换机构**即用于实现基本分页存储管理中**逻辑地址到物理地址转换的一组硬件机构**。基本地址变换机构可以借助进程的**页表**进行转换。

- **原理**：操作系统会设置一个**页表寄存器**（PTR），该寄存器存放了**页表在内存中的起始地址 `F`** 和**页表长度 `M`**。进程未执行时，**页表起始地址**和**页表长度**被放在进程的 PCB 里，进程被调度之后存放到 PRT 中。
    1. 根据逻辑地址计算出**页号**、**页内偏移量**；
    2. 判断页号是否越界，如果越界触发**内中断**；
    3. 查询页表，找到页号对应的页表项，确定页面存放的**内存块号**（页框号）；
    4. 用内存块号和页内偏移量得到实际的**物理地址**；
    5. 访问目标内存单元。

<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA3621ff84941b9d8a06d7a8912ea2fe45.png" />
<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA7dd059bd8d6867ce2c47835c1c885a3e.png" />

--

**具有快表的地址变换机构**


---

**两级页表**



#### 基本分段存储管理**



#### 段页式存储管理**









## 虚拟内存

### 请求分页管理方式

### 页面置换算法

### 页面分配策略

### 内存映射文件