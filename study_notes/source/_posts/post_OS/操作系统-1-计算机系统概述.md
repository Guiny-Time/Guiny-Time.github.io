---
layout: post
title: 操作系统-1-计算机系统概述
date: 2024-12-04 19:52:19
tags:
categories: 操作系统
hidden: true
---

# 什么是操作系统
## 功能与概念

操作系统（OS）是**控制和管理整个计算机接口的硬件和软件资源**，合理地组织调度计算机的**工作**和**资源分配**，提供给用户和其他软件方便的**接口和环境**，是计算机系统中最基本的**系统软件**，即：

1. 操作系统是系统资源的管理者
<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA6d6218c725d2b41a528d32229b96cf1c.png" width=400 />

2. 向上层（用户、应用程序）提供方便易用的服务
硬件只能接收和处理二进制，这对一般的应用程序来说并不友好。操作系统的存在将这些硬件功能封装成了更用户友好的接口（例如GUI或cmd），用户只需要调用这些接口就可以实现与底层硬件的交互。可以说OS是一个大型中间件。
> **联机命令接口、脱机命令接口与程序接口**
联机命令接口就是我们常在cmd中使用的交互式命令，特点为用户发送一句命令，系统处理后用户再发送一条。命令行追求的是**交互性**。
脱机命令接口就是批处理（.bat文件），开发者将一系列命令写进文件，系统直接执行这一系列文件。批处理追求的是**效率**、**资源利用率**和**吞吐量**。
程序接口就是**系统调用**（System Call）/广义指令，**只能在程序代码中间接使用**（普通用户无法接触）。

3. 操作系统是最接近硬件的**软件**
操作系统可以实现对硬件机器的拓展，通过将CPU、内存、磁盘、显示器、键鼠等硬件合理地组织起来，让各种硬件互相协调配合，实现更多复杂功能（例如文件系统等）。

<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA7ed21391f51586bfeaacb4ba2d55b587.png" alt="操作系统的位置" width=250/>

## 操作系统的四个特征

<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA610a04be64a92c024ba26f0ae37e0ec4.png" width=300 />

操作系统的四个特征是并发、共享、虚拟和异步，其中**并发和共享是两个最基本的特征**。

### 并发
- **并发**：指两个或多个程序在统一时间间隔内发生。这些程序宏观上是同时运行的，但微观上是交替运行的。操作系统是伴随“**多道程序技术**”出现的，因此操作系统和并发是一起诞生的，并发是操作系统的基本特征之一。
- **并行**：指两个或多个程序在同一时刻同时执行。对于多核CPU来说并行是可能的，但单核CPU只能并发执行。

{% note info **多道程序技术的基本特征** %}
如果没有多道程序并发，一般的顺序程序具有以下四个特征：
1. 顺序性
2. 封闭性（上面两个特性是所有顺序程序具有的特征）
3. 程序执行结果的确定性（幂等性）
4. 程序执行结果的可再现性（鲁棒性）

在引入多道程序并发之后，多个程序互相争抢、交替使用CPU资源（这体现了**制约性**），顺序性和封闭性便失去了。由于分配的不确定，3和4也不存在。
因此，多道程序并发的基本特征是**制约性**。
{% endnote %}

<img src="https://www.itbaizhan.com/wiki/imgs/image-20211204095202680.png" width=450 />

### 共享
共享即**资源共享**，指系统中的资源可供内存中多个并发执行的进程共同使用。
- **互斥共享**：一个时间段内只允许一个进程访问该资源（加了锁），例如QQ和微信只有一个进程能使用摄像头。
- **同时共享**：一个时间段内允许多个进程同时访问该资源，例如游戏和音乐播放器两个进程都能播放音乐。

并发和共享是相辅相成的，失去其中之一另一方就没有了意义，因此二者为OS最基本的两个特征。

### 虚拟
虚拟指的是**虚拟内存**，与物理内存概念相对。一个电脑的内存可能不大，却能同时运行远超内存的应用，这是利用了虚拟的**空分复用技术**。
并发是“**时分复用技术**”的体现，虚拟依托并发实现。

### 异步
异步指的是在多道程序环境下允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底而是走走停停的（以不可知的速度向前推进），这就是异步性。
从上文可以看出，异步依托并发实现。

## 操作系统的分类
### 批处理
1. **单道批处理系统**
在打孔卡的时代，每个程序员都是通过纸带将程序提交给计算机执行的，计算机执行完之后再将结果打到纸带上返回给操作人员。每个人都需要等待纸带，这造成了大量的浪费。

通过引入**外围机+磁带**，多个程序员都可以将纸带提交到外围机上，外围机将程序提前存到磁带里，再由**监督程序**（操作系统的雏形）控制磁带与计算机进行输出/输入交互。

<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA80261b7c3c64916b1630d2cb4d6cbf0c.png" alt="单道批处理系统" />

虽然提升了执行速度和资源利用率，但内存中**仅能运行一道程序**，只有该程序运行结束之后才能调入下一个程序，CPU 有大量时间都在等待 I/O 完成，资源利用率依然很低。
<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA52a113b91fffe96e9cd89c139eeb7d7f.png" />

2. **多道批处理系统**
每次可以**往内存中读入多道程序**，支持程序**并发**运行，进一步提升资源利用率。但此时计算机依然没有人机交互功能，用户无法调试自己的程序，也无法在程序执行过程中输入。
<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA6c9e09f32824a95d78006e1e40e09a48.png" />

### 分时操作系统
计算机以**时间片**为单位**轮流为各个用户/作业服务**，各个用户可以通过终端与计算机进行**交互**。在这个模式下，用户的请求可以被即时响应，这解决了**人机交互**的问题，同时允许多个用户同时使用一台计算机，并且用户对操作系统的操作相互独立，感受不到别人的存在。

不过，分时操作系统**不能优先处理一些紧急任务**，因为操作系统对每个用户/作用都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性。

<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA437e791d4d99012b05b172578d767561.png" />

### 实时操作系统
实时操作系统能够**优先响应紧急任务**，某些紧急的任务不需要时间片排队。在这种模式下，操作系统接收到外部信号之后及时进行处理，并且要**在严格的时限内处理完事件**（硬实时操作系统）。实时操作系统的主要特点是**及时性**和**可靠性**。

一些对时限没有特别严格的要求的实时操作系统被称为**软实时操作系统**。

### 分布式操作系统
系统中的各台计算机地位相同，**任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务**。分布式操作系统的主要特点是**分布性**和**并行性**。

# 操作系统的运行机制
<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA35caacb78813ed90f1dedb011e6f6ab6.png" width=400/>

- **程序**：
    - **内核程序**：内核程序组成了操作系统内核（Kernel），是OS最核心、最必不可少的部分，也是最接近硬件的部分。
    - **应用程序**：一般来说，作为开发者我们写的都是应用程序，是运行在操作系统之上的。

- **指令**：CPU能识别和处理的最基本的命令（二进制机器码）。高级语言（例如C）经过编译器处理后会被翻译成机器指令。
    - **特权指令**：一些影响重大的指令，只允许管理者（操作系统的内核程序）使用。
        - 开关中断
        - 写时钟
        - I/O
        - 写程序状态字寄存器（PSW）
        - 清除整个内存
    - **非特权指令**：大家都能用的指令，例如加法指令、减法指令。
        - 存取数
        - 读时钟
        - 加减乘除
        - 寄存器清零
        - 压栈弹栈
        - 跳转
        - 系统调用（trap）

- **CPU状态**：处理器所处的状态，与**程序状态字寄存器**（PSW）有关，为1时处于内核态、为0时处于用户态。从内核态转变为用户态是通过内核程序的**特权指令**实现的；用户态转变为内核态发现在应用程序**中断**的时候（处理中断的程序是内核程序）。
    - **内核态/管态**：正在运行内核程序，可以执行特权指令。
    - **用户态/目态**：正在运行应用程序，只能执行非特权指令。

## 中断和异常
一般来说中断指**外中断**（狭义的中断），异常指**内中断**（广义的中断）。其中的关系如下：

<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VAc6399b805a9a0e366214f36415d2c3fc.png" />

> 注意：中断向量指的是中断处理程序的入口地址。中断向量地址指的是中断向量的地址。
外中断会回到被中断指令的下一条继续执行，而内中断会回到被中断指令继续执行。

## 系统调用
前文中提到过，系统调用是一类能在**应用程序**中使用的指令。现代高级语言一般将系统调用封装到了一系列接口中（例如C的库函数），在调用库函数 `malloc` 时就根据分配内存的大小（128k）在底层使用了系统调用 `brk` 或 `mmap`。由此可见，**系统调用比库函数更底层**。并不是所有库函数都调用了系统调用。
一些资源是互斥共享资源（例如存储分配、I/O操作、文件管理等），多个用户进程想使用该类资源时必须通过系统调用向内核发出请求，由内核对各个请求进行协调处理，避免并发运行时产生错误，确保系统的**稳定性**和**安全性**。

<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA70525c71b44f9e7e50503467105a8b38.png" width=450 />

{% note info **系统调用的过程** %}
在应用程序中，如果想要执行系统调用，会经过以下几个步骤：
1. 向CPU发送一条或多条**传参指令**，参数可能指明了系统调用的类型，或是其他内容
2. 向CPU发送**陷入指令**（即trap/访管指令，是非特权指令），触发内中断而中断应用程序，从用户态转变为内核态
3. 执行系统**调用入口程序**（内核程序），即处理陷入指令的中断指令，处理寄存器中的参数，决定使用哪个系统调用程序
4. 调用入口程序调用**对应的系统调用程序**，根据参数处理相关逻辑
5. 通过特权指令回到用户态，恢复执行用户程序中剩下的其他指令
{% endnote %}

# 操作系统体系结构
操作系统的体系结构，也就是操作系统的**内核**应当如何设计的。内核是操作系统最基本、最核心的部分，实现操作系统内核功能的程序就是**内核程序**。常见的内核程序包括：

- **时钟管理**：实现计时功能，涉及硬件处理。
- **中断处理**：负责实现中断机制，涉及硬件处理。
- **原语**：这类程序具有**原子性**（例如 C++ 中 share_ptr 引用计数的加减），无法被中断，是**最接近硬件**的内核程序。
- **对系统资源进行管理的功能**：包括**进程管理**、**储存器管理**、**设备管理**，更多是对数据结构的操作，不会涉及到硬件。

内核有五种设计模式，我们了解一下最常见的大内核与微内核即可：

<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA12d6d6ab27433419f6e87028b9d5e4ff.png" width=400 />

{% note info **大内核与微内核** %}
大内核与微内核的区别是什么呢？关于内核程序，其实我们可以大致分成两类，即：

1. 与硬件操作紧密相关的时钟管理、中断处理与原语
2. 与资源管理相关的几个管理功能

如果我们把管理算进内核中，那么这种架构下内核就被称为**大内核**。如果不算进去（被运行在**用户态**），那么这种架构下的内核就被称作**微内核**。

微内核的CPU状态转换（用户态->内核态或内核态->用户态）会更加频繁，会降低系统性能。
{% endnote %}

# 操作系统引导（Boot）
什么是操作系统引导？简单来说就是一个帮助操作系统在开机时运行在电脑上的**引导程序**（Boot）。boot 是被存放在磁盘的**主引导记录区**（MBR）上的（除了存放 boot 之外还有**磁盘分区表**），独立与磁盘分区之外。

操作系统被安装在 C 盘（系统盘），C 盘中有两个比较特殊的区域：**引导记录**（PBR）和**根目录**（一打开 C 盘看到的内容）。计算机的主存由**只读存储器**（ROM）和**随机存储器**（RAM）组成，在 ROM 中存放了**基本输入输出系统**（BIOS），包含了**ROM引导程序**（自举程序）。 

<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VAeef80d16c042b727961e907a4f0ea860.png" width=500 />

在电脑启动时，会经过以下步骤：
1. CPU 在主存的 ROM 中找到 **ROM 引导程序**并执行，进行**硬件自检**
2. ROM 引导程序将**磁盘引导程序**读入 RAM。CPU 执行**磁盘引导程序**，根据**分区表**找到 C盘
3. 读入 C 盘的**引导记录（PBR）**到 RAM
4. CPU 执行 C 盘根目录下的**启动管理程序**，完成操作系统初始化

# 虚拟机
现在有一个问题：两个进程运行在同一个操作系统上时可能会因为**竞争条件**而导致潜在的隐患（死锁等），该怎么办呢？

很直观的一个想法是将两个进程分别运行在两台不同的物理机器上，这样两个进程就不可能相互影响了。但一个物理机器只能运行一个进程，这样对于物理硬件资源来说是极大的浪费。另一种思路是采用**虚拟机**（Virtual Machine，VM），将不同的进程运行在不同的虚拟操作系统上。

虚拟机是通过**虚拟化**技术，将一台物理机器虚拟化成多台虚拟机，每个虚拟机都可以独立运行一个操作系统。虚拟机通过**虚拟机管理程序**（VM Monitor / Hypervisor）管理虚拟机，分为下图中的两类：

<img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VAb5dc3ec49eab21ac84da62a9fa3c5b72.png" alt="两种类型的VM" />

- **第一类VMM**
直接运行在硬件上的，将硬件资源划分为多个部分（例如 CPU 时间片划分），供不同的虚拟机使用。不同的虚拟机可以安装各自的操作系统，进而运行不同的进程。
在这类 VMM 中，只有虚拟机管理程序是运行在内核态的，虚拟机本身是运行在用户态的，那么虚拟机的操作系统想要执行特权指令该怎么办呢？该请求会被 VMM 截获，由 VMM 执行后返回给上层的操作系统。

- **第二类VMM**
运行在宿主操作系统上，比如我们在自己的操作系统上安装了 VirtualBox 软件，就可以通过软件执行一个或多个操作系统。