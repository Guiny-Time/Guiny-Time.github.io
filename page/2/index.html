<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>几/何/冰/川 - 时间的旅者，无痕的过客</title><meta name="author" content="时光"><meta name="copyright" content="时光"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="时间的旅者，无痕的过客">
<meta property="og:type" content="website">
<meta property="og:title" content="几&#x2F;何&#x2F;冰&#x2F;川">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="几&#x2F;何&#x2F;冰&#x2F;川">
<meta property="og:description" content="时间的旅者，无痕的过客">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/head.jpg">
<meta property="article:author" content="时光">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/head.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/page/2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 时光","link":"链接: ","source":"来源: 几/何/冰/川","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '几/何/冰/川',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2025-02-10 12:22:20'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mycss.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><canvas id="universe" ></canvas><link rel="stylesheet" href="/css/fish.css"><link rel="stylesheet" href="/css/wave.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/CodeByZach/pace/themes/green/pace-theme-flash.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/CodeByZach/pace/themes/blue/pace-theme-fill-left.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">107</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-hubspot"></i><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/cats/time/"><i class="fa-fw far fa-hourglass"></i><span> Time</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fab fa-connectdevelop"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 内容</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/next/"><i class="fa-fw fas fa-feather"></i><span> 笔记</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-hamburger"></i><span> 图片</span></a></li></ul></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url('/img/head_page.png')"><nav id="nav"><span id="blog-info"><a href="/" title="几/何/冰/川"><span class="site-name">几/何/冰/川</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-hubspot"></i><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/cats/time/"><i class="fa-fw far fa-hourglass"></i><span> Time</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fab fa-connectdevelop"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 内容</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/next/"><i class="fa-fw fas fa-feather"></i><span> 笔记</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-hamburger"></i><span> 图片</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">几/何/冰/川</h1><div id="site-subtitle"><span id="subtitle"></span></div><div id="site_social_icons"><a class="social-icon" href="https://github.com/Guiny-Time" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:guinytime@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="post_cover left"><a href="/2024/07/21/%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5/%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5-%E5%B8%A7%E5%90%8C%E6%AD%A5/" title="网络同步-帧同步"><img class="post-bg" src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VAb49acb50f9dd74e2ce25c1154c36804a.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="网络同步-帧同步"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/07/21/%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5/%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5-%E5%B8%A7%E5%90%8C%E6%AD%A5/" title="网络同步-帧同步">网络同步-帧同步</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-07-20T16:00:00.000Z" title="发表于 2024-07-21 00:00:00">2024-07-21</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5/">网络同步</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/">游戏编程</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/">经验分享</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C/">网络</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5/">网络同步</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%B8%A7%E5%90%8C%E6%AD%A5/">帧同步</a></span></div><div class="content">什么是帧同步？
古典帧同步
古典帧同步又叫Lockstep Synchronization（锁步同步），其一大特色在于当一个人未同步完成时，其他人都必须等待直到其同步完成，然后再执行下一帧的同步。

上图有两个客户端。客户端 B 的网络比较差，A 和 B 都在 T0 时间点向服务器发送了用户输入，A 的请求在 T1 到达服务端，B 的请求在 T2 到达服务端，前面我们提到，服务器需要收集“所有用户”的请求后才开始工作，因此需要到 T2 时间点才开始生成 frame。
因为 Client B 比较慢，我们“惩罚”了所有的玩家。而且为了服务器能正常工作，即使客户端没有产生任何指令也需要往服务器发送心跳包，这造成了流量开销。锁步同步可以用在确实需要玩家等待的回合制游戏或者对延迟不敏感的慢节奏游戏。

帧同步就对应于我们在上文中说的同步用户的输入的操作、或者这些操作所产生的一系列事件，保证所有人在每一帧上都获得相同的输入，执行相同的逻辑，最后得到一致的表现和结果。之所以被称之为“帧”同步，是因为帧同步是以固定频率（比如60Hz）同步玩家的下一帧的操作的。从中我们也能看出，帧同步包含了两个同步， ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2024/07/19/%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5/%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5/" title="网络同步-基本概念介绍"><img class="post-bg" src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA615419c5b83e4781e089aeb58a330391.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="网络同步-基本概念介绍"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/07/19/%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5/%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5/" title="网络同步-基本概念介绍">网络同步-基本概念介绍</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-07-18T16:00:00.000Z" title="发表于 2024-07-19 00:00:00">2024-07-19</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5/">网络同步</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/">游戏编程</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/">经验分享</a></span></div><div class="content">什么是网络同步
网络同步是指通过网络将数据从一个系统或节点传输到另一个系统或节点，并保持两者之间的数据一致性。换句话说，游戏中的网络同步就是把我的状态同步给远程玩家看到的“我”的镜像，使双方在屏幕上看到的效果是一致（或接近一致）的。
在常见的多人联机游戏（例如下棋、格斗、fps等等）中，网络同步是非常重要的一项需求。游戏中的玩家需要时时刻刻了解其他玩家的状态或者行为，才能辅助自己做出下一步决策（例如是否开枪等）。
如何知道其他玩家的状态，又如何让其他玩家知道我的状态呢？这时候就需要网络同步技术了。
同步设计目标
同步设计主要有两个目标，即 一致性 和 及时性 。一致性指多个客户端看到的效果是一致的，而及时性指能否及时完成网络同步。在实际工程中我们往往很难同时满足一致性和及时性，这是因为网络延迟始终存在，客户端在接收到最新状态前只能对其他玩家镜像的状态进行预测（通常会采用一些客户端障眼法，例如插值）。
在 一致性 和 及时性 这两个核心目标下，我们可以拆解出三个子设计要素（公平、体验和开销），根据实际情况进行优先级权衡。一般来说用户体验是位于首位的。
公平性


确定
操作具有幂等性，即 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2024/02/11/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/2024GGJ%F0%9F%8C%8F-CluckCluck%E5%A4%8D%E7%9B%98%E2%80%94%E2%80%94%E9%85%8D%E7%BD%AE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="2024GGJ🌏 - CluckCluck复盘——配置表的实现"><img class="post-bg" src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VAcf0538525ce9dc3d4b37bf124f74df47.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2024GGJ🌏 - CluckCluck复盘——配置表的实现"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/02/11/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/2024GGJ%F0%9F%8C%8F-CluckCluck%E5%A4%8D%E7%9B%98%E2%80%94%E2%80%94%E9%85%8D%E7%BD%AE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="2024GGJ🌏 - CluckCluck复盘——配置表的实现">2024GGJ🌏 - CluckCluck复盘——配置表的实现</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-02-11T00:00:00.000Z" title="发表于 2024-02-11 08:00:00">2024-02-11</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/">项目复盘</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/">游戏编程</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/">经验分享</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/">项目复盘</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E9%85%8D%E7%BD%AE%E8%A1%A8/">配置表</a></span></div><div class="content">CluckCluck 的开发时间只有 48 小时，在这样短的开发时间内，作为程序的我们需要频繁对场景以及各类预制件做出修改，从避免提交冲突的角度考虑，我们没有办法让策划同学直接在Unity场景中配置道具的数据。
不过，我想到之前在 hll 学长的代码仓库里看到过配置表工具，结合实际开发中策划人员也是通过打表实现数据传递的，我决定在 CluckCluck 中使用这个功能，完美解决了策划的配置与调试可能影响到提交冲突的问题（好耶！


所以在本文中，我想剖析一下这个妙妙小工具，看一下它是怎么运作的。首先来看看工具的文件结构：
1234567891011配置表    |- Excels    |- Scripts        |- Plugins        |- Foods            |- FoodProps.cs            |- FoodsInfo.cs            |- Editor                |- FoodsInfo_Editor.cs        |- Weapons        |- BaswExcel.cs
Exce ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2024/02/01/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/2024GGJ%F0%9F%8C%8F%20-%20CluckCluck%E5%A4%8D%E7%9B%98%E2%80%94%E2%80%94%E6%96%B0%E8%BE%93%E5%85%A5%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%89%8B%E6%9F%84%E6%8E%A7%E5%88%B6/" title="2024GGJ🌏 - CluckCluck复盘——新输入系统与手柄控制"><img class="post-bg" src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA858c8347ff07ec951cb49ffb04eea56b.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2024GGJ🌏 - CluckCluck复盘——新输入系统与手柄控制"></a></div><div class="recent-post-info"><a class="article-title" href="/2024/02/01/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/2024GGJ%F0%9F%8C%8F%20-%20CluckCluck%E5%A4%8D%E7%9B%98%E2%80%94%E2%80%94%E6%96%B0%E8%BE%93%E5%85%A5%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%89%8B%E6%9F%84%E6%8E%A7%E5%88%B6/" title="2024GGJ🌏 - CluckCluck复盘——新输入系统与手柄控制">2024GGJ🌏 - CluckCluck复盘——新输入系统与手柄控制</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-02-01T00:00:00.000Z" title="发表于 2024-02-01 08:00:00">2024-02-01</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/">项目复盘</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/">游戏编程</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/">经验分享</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/Unity/">Unity</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/">项目复盘</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%96%B0%E8%BE%93%E5%85%A5%E7%B3%BB%E7%BB%9F/">新输入系统</a></span></div><div class="content">新输入系统(Input System)
Unity的新输入系统是一个基于事件的新系统，它在编辑器里提供了一个中间层（Input Action Asset），用户可以在其中自定义一系列玩家动作和其对应的操作。例如在CluckCluck中，我设定了移动（left joystick）、冲刺（B）、拾取道具（right trigger）三个控制：

完成操作设置之后，保存Input Action资产，在其检查器中可以点击生成对应的C#类，接下来就可以在代码中通过事件绑定的方法使用这些操作监听。

同屏双手柄（1p2p）
由于我们做的是一个比较欢脱的双人派对竞技游戏，这次jam还有一个重要的需求是同屏双手柄控制。我不想像懂哥一样用“PlayerController1.cs”和“PlayerController2.cs”来区分不同玩家（因为如果采取这种模式，如果玩家数量增多，需要维护的脚本就会变多），所以如何在一个脚本中为不同玩家绑定不同的控制器尤为重要。
首先是声明p1/p2，它们都用了同一套InputAction “Player2”（之所以是这个命名是因为Player1是键盘控制）。通过游戏对 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2023/10/02/%E6%B8%B8%E6%88%8F%E6%8A%80%E6%9C%AF/Mono-IL2CPP/" title="Mono &amp; IL2CPP"><img class="post-bg" src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA63f27977094652a0092e0ac3fe928047.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mono &amp; IL2CPP"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/10/02/%E6%B8%B8%E6%88%8F%E6%8A%80%E6%9C%AF/Mono-IL2CPP/" title="Mono &amp; IL2CPP">Mono &amp; IL2CPP</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-10-02T07:43:23.000Z" title="发表于 2023-10-02 15:43:23">2023-10-02</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8E%A2%E7%B4%A2%E5%8F%91%E7%8E%B0/">探索发现</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Unity/">Unity</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0/">跨平台</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/Mono/">Mono</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/IL2CPP/">IL2CPP</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%BC%96%E8%AF%91/">编译</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/C/">C#</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/C/">C++</a></span></div><div class="content">
1995 年，Java 编程语言横空出世，依托虚拟机（JVM）的 Java 打着“一次编写，到处运行”的跨平台旗号，迅速赢得了开发者的青睐，成为当今应用最广泛的十大编程语言之一。
Unity 同样做到了跨平台的特性，它允许开发者在完成游戏开发工作后将其打包发布到多达 27 个目标平台上（如上图所示）Unreal做得到吗。那么 Unity 是如何实现跨平台的操作呢？它也使用到了类似 JVM 的概念吗？这就要提到 Unity 的脚本后端处理（Scripting Backend）了。Unity 具有两个脚本后端：Mono 和 IL2CPP (Intermediate Language To C++)，它们各自使用不同的编译技术，也是今天本文探讨的主题。在正式开始之前先学习一下 .NET 是怎么被编译成目标平台的代码的：


编写 C# 代码
C# 编译器编译代码（在 Unity 中就是每次更改完代码之后漫长的进度条等待环节）后得到了中间语言（Intermediate Language Code，IL）。
IL 经过公共语言运行时（CLR）和即时编译器（JIT）的编译，得到目标平台的可执行程 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2023/09/17/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/Hold-ON%EF%BC%81%E5%A4%8D%E7%9B%98%EF%BC%9A%E7%89%A9%E7%90%86%E6%9D%90%E8%B4%A8/" title="Hold-ON！复盘：物理材质"><img class="post-bg" src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VAe462e0c2d0477ea89497c1938dac9b73.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hold-ON！复盘：物理材质"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/09/17/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/Hold-ON%EF%BC%81%E5%A4%8D%E7%9B%98%EF%BC%9A%E7%89%A9%E7%90%86%E6%9D%90%E8%B4%A8/" title="Hold-ON！复盘：物理材质">Hold-ON！复盘：物理材质</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-09-17T08:10:26.000Z" title="发表于 2023-09-17 16:10:26">2023-09-17</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%BC%95%E6%93%8E%E5%8A%9F%E8%83%BD/">引擎功能</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Unity/">Unity</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%89%A9%E7%90%86/">物理</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%89%A9%E7%90%86%E6%A8%A1%E6%8B%9F/">物理模拟</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%BC%95%E6%93%8E/">引擎</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%89%A9%E7%90%86%E6%9D%90%E8%B4%A8/">物理材质</a></span></div><div class="content">什么是物理材质


物理材质定义了刚体表面的弹性和摩擦力，包括以下几项：


Dynamic Friction（动摩擦）
在移动时使用的摩擦力，动摩擦将尝试在与另一个对象接触时减慢对象的速度。Dynamic Friction 通常为 0 到 1 之间的值。

值为 0 时表面就像冰一样滑
值为 1 将使对象迅速静止（除非用很大的力或重力推动对象）。



Static Friction（静摩擦）
当对象静止在表面上时使用的摩擦力，静摩擦力会阻止对象开始移动，如果向对象施加足够大的力，对象才会开始移动。Static Friction 通常为 0 到 1 之间的值。

值为 0 时表面就像冰一样滑
值为 1 时物体将很难移动。



Bounciness（弹性）
表面的弹性如何？值为 0 将不会反弹。值为 1 将在反弹时不产生任何能量损失，预计会有一些近似值，但可能只会给模拟增加少量能量。



除此之外，还有一个 Friction Combine 和 Bounce Combine。这两个“组合”表示了两个碰撞对象之间摩擦力/弹性的组合方式，Unity 将根据所选择的模式对两个物体施加相同 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2023/09/03/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/Hold-ON%EF%BC%81%E5%A4%8D%E7%9B%98%EF%BC%9A%E5%85%B3%E8%8A%82%E4%B8%8E%E9%93%B0%E9%93%BE/" title="Hold-ON！复盘：物理关节"><img class="post-bg" src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VAccd21636323a23cada9dee7080c2e223.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hold-ON！复盘：物理关节"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/09/03/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/Hold-ON%EF%BC%81%E5%A4%8D%E7%9B%98%EF%BC%9A%E5%85%B3%E8%8A%82%E4%B8%8E%E9%93%B0%E9%93%BE/" title="Hold-ON！复盘：物理关节">Hold-ON！复盘：物理关节</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-09-03T15:50:12.000Z" title="发表于 2023-09-03 23:50:12">2023-09-03</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%BC%95%E6%93%8E%E5%8A%9F%E8%83%BD/">引擎功能</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Unity/">Unity</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%89%A9%E7%90%86/">物理</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%89%A9%E7%90%86%E6%A8%A1%E6%8B%9F/">物理模拟</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%BC%95%E6%93%8E/">引擎</a></span></div><div class="content">我们经常在游戏中看到下面的 gif 里所展示的“可交互场景对象”。这样的对象的存在增添了场景的可交互性，让场景不那么死板，显得更有生气和灵性。除了下图展示的游戏 HUE 之外，GRIS、空洞骑士等游戏也大量使用了可交换场景对象。

这种可交互的场景对象是怎么实现的呢？这就要引出文章的主题：Joints（关节）了。
什么是关节
Joints（关节）是一种用于将两个刚体连接在一起的物理组件，通常用于模拟现实世界中的连接、约束或机械行为。例如，你可以用关节连接一个物体到另一个物体、固定到某个位置，或者模拟摆锤、弹簧等效果。
固定关节/Fixed

固定关节（Fixed Joint）将两个对象固定在相对位置，适合用来模拟焊接、粘合等固定效果。例如将一个箱子固定在某个位置、或者连接两个不会相对移动的物体（例如把粘土炸弹固定到某个移动对象上）。
可使用固定关节面板上的 Break Force 和 Break Torque 属性来设置关节强度的限制。如果这些值小于无穷大，并对该对象施加大于这些限制的力/扭矩，则其固定关节将被破坏并将摆脱其约束的束缚。

另外，固定关节的刚体类型也会影响到展示的效果， ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2023/08/28/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/Hold-ON%EF%BC%81%E5%A4%8D%E7%9B%98%EF%BC%9AUnity%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/" title="Hold-ON!复盘：Unity中的物理碰撞"><img class="post-bg" src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA4020ebaadd640a281069f2cc095befe8.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hold-ON!复盘：Unity中的物理碰撞"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/08/28/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/Hold-ON%EF%BC%81%E5%A4%8D%E7%9B%98%EF%BC%9AUnity%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/" title="Hold-ON!复盘：Unity中的物理碰撞">Hold-ON!复盘：Unity中的物理碰撞</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-08-28T15:39:15.000Z" title="发表于 2023-08-28 23:39:15">2023-08-28</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%BC%95%E6%93%8E%E5%8A%9F%E8%83%BD/">引擎功能</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Unity/">Unity</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%89%A9%E7%90%86/">物理</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%89%A9%E7%90%86%E6%A8%A1%E6%8B%9F/">物理模拟</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%BC%95%E6%93%8E/">引擎</a></span></div><div class="content">我们参加的 48 小时 jam，第三届《益·游未尽》的比赛作品——《Hold-ON!》在比赛截至前平安上线 itch 平台了，欢迎大家前来试玩！
Hold on- h5 version by Guinyの时光
在这次的项目中，我和另一位程序大量使用到了 Unity 的物理系统，其中包括通过力驱使角色移动、玩家之间的碰撞、触发器检测等，我想借此机会在复盘文章中好好聊一聊 Unity 的物理系统，以及物理系统在实际项目中的一些应用。
Unity 中的物理模拟包括碰撞检测、力学模拟、刚体运动和关节（铰链等）等等。Unity 的物理引擎按照对象类型分为两种实现：

对于 3D 对象的物理系统是基于 NVIDIA 的实时开源物理引擎 PhysX 实现的。
对于 2D 对象的物理系统是基于开源的物理引擎 Box2D 实现的。

如果是 Unity6 的面向数据（DOTS，即 Unity 的 ECS 框架）方案，则采用 Unity Physics 包，在本文中不多做讨论。
刚体物理
在 Unity 3D 中，物理系统有两个很基本的组件：Collider（碰撞体）和 Rigidbody（刚体）。希望产 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2023/07/20/%E6%B8%B8%E6%88%8F%E6%8A%80%E6%9C%AF/UGUI/UnityUI%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8EUI%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AUGUI%E4%BC%98%E5%8C%96/" title="UnityUI程序设计与UI性能优化（五）：UGUI性能优化指南"><img class="post-bg" src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA1fc5ff9e9083059d3dab93de58d27b40.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="UnityUI程序设计与UI性能优化（五）：UGUI性能优化指南"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/07/20/%E6%B8%B8%E6%88%8F%E6%8A%80%E6%9C%AF/UGUI/UnityUI%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8EUI%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AUGUI%E4%BC%98%E5%8C%96/" title="UnityUI程序设计与UI性能优化（五）：UGUI性能优化指南">UnityUI程序设计与UI性能优化（五）：UGUI性能优化指南</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-07-20T11:23:22.046Z" title="发表于 2023-07-20 19:23:22">2023-07-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%BC%95%E6%93%8E%E5%8A%9F%E8%83%BD/">引擎功能</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Unity/">Unity</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E4%BC%98%E5%8C%96/">优化</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/UI/">UI</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/UGUI/">UGUI</a></span></div><div class="content">UGUI是一个很强大的系统，通过它我们可以拼出多姿多彩的UI界面，让玩家更好的与游戏UI进行交互。但作为开发者，我们也需要注意UGUI中潜在的性能优化问题，防止游戏因为 drawcall 过多、频繁 rebatch / rebuild 而造成发热和卡顿（特别是对于低端机型来说）。



性能瓶颈
硬件影响
典型场景
CPU耗时参考




过度绘制
GPU负载
半透明元素叠加
每层增加0.5-1ms


批次破碎
DrawCall激增
动态列表滚动
100元素≈30DC


布局重建
主线程卡顿
LayoutGroup嵌套使用
嵌套3层≈15ms



那么该怎么对 UI 进行优化呢？我们优化的主要目的就是减少绘制调用（drawcall）和布局重建的次数。绘制调用发生在 CPU 与 GPU 中间，当 CPU 打包好渲染数据（例如顶点、纹理、材质等）之后，就会发起一次绘制调用，将这些信息打包到显存以通知 GPU 进行绘制。也就是说，有多少个绘制调用，CPU 就需要向 GPU 发送多少次通知。drawcall 太高，意味着有频繁地改变渲染状态，这是很慢的操作（相对于GPU执行其内部的渲染流 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2023/07/15/%E6%B8%B8%E6%88%8F%E6%8A%80%E6%9C%AF/UGUI/UnityUI%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8EUI%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AUGUI%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6/" title="UnityUI程序设计与UI性能优化（四）：UGUI的点击事件"><img class="post-bg" src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VAa198651e59fd8df47130a8f8b489dbc5.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="UnityUI程序设计与UI性能优化（四）：UGUI的点击事件"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/07/15/%E6%B8%B8%E6%88%8F%E6%8A%80%E6%9C%AF/UGUI/UnityUI%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8EUI%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AUGUI%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6/" title="UnityUI程序设计与UI性能优化（四）：UGUI的点击事件">UnityUI程序设计与UI性能优化（四）：UGUI的点击事件</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-07-15T08:41:18.000Z" title="发表于 2023-07-15 16:41:18">2023-07-15</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%BC%95%E6%93%8E%E5%8A%9F%E8%83%BD/">引擎功能</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Unity/">Unity</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/UI/">UI</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/UGUI/">UGUI</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%BA%90%E7%A0%81/">源码</a></span></div><div class="content">
在 Unity 的 UI 系统中，Button 是最常见的可交互组件之一（除此之外还有 Slider、Toggle、Input Field、Scroll Bar、Drop Down），其点击事件不仅是开发者构建用户交互的基础，更是一个复杂而精巧的功能模块。本文将从 UGUI 的源码层面出发，全面剖析 Button 点击事件的实现原理，理解其设计思路与内部逻辑。

按钮点击的触发流程
相信每个介绍 UGUI 的新手视频都会讲到 Button 的点击事件。在 Unity 中，如果我们想为一个按钮添加事件有两种实现方式，一种是直接在检查器上为该按钮绑定事件:

另一种是通过代码为按钮的 onClick 加上方法监听:
123GetComponent&lt;Button&gt;().onClick.AddListener(() =&gt; &#123;     ...//按钮点击的处理逻辑&#125;);
这两者是等价的。让我们沿着 onClick 的调用链一步一步看看是怎么回事吧。
Button：Press -&gt; OnPointerClick
我们来看看 Button 的源码吧！在  ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2023/07/11/%E6%B8%B8%E6%88%8F%E6%8A%80%E6%9C%AF/UGUI/UnityUI%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8EUI%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="UnityUI程序设计与UI性能优化（三）：UGUI的渲染流程"><img class="post-bg" src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA96d03380d5b9586247c6962d0c4f1351.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="UnityUI程序设计与UI性能优化（三）：UGUI的渲染流程"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/07/11/%E6%B8%B8%E6%88%8F%E6%8A%80%E6%9C%AF/UGUI/UnityUI%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8EUI%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="UnityUI程序设计与UI性能优化（三）：UGUI的渲染流程">UnityUI程序设计与UI性能优化（三）：UGUI的渲染流程</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-07-11T11:23:22.046Z" title="发表于 2023-07-11 19:23:22">2023-07-11</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%BC%95%E6%93%8E%E5%8A%9F%E8%83%BD/">引擎功能</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Unity/">Unity</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/UI/">UI</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/UGUI/">UGUI</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%BA%90%E7%A0%81/">源码</a></span></div><div class="content">UGUI的渲染过程
Unity中渲染的物体都是由网格(Mesh)构成的，而网格的绘制单元是图元(点、线、三角面)。在 Unity 中渲染一个 2D 或 3D 对象时，需要由 CPU 提起一个 draw call（绘制调用），经过一个完整的渲染管线流程，经由 GPU 处理最后输出像素到屏幕上。那么对于 UGUI 元素（例如Image）来说是不是也是一样的呢？

绘制一个 UI，简而言之就是绘制 UI 的形状与图元：

生成 mesh：mesh 由顶点和三角形组成，顶点里包括 UV 坐标、顶点颜色。
渲染图元：将纹理渲染到 mesh 上。

我们将以绘制一张 Image 为例，学习 UGUI 的渲染过程。

可以看到，新建一个 Image 对象，默认挂载了Rect Transform、Canvas Renderer 和 Image 三个组件。Image 的源码位于 Runtime/UI/Core/Image.cs，这个文件有 1000 多行，初见感觉挺吓人的，但其实大部分都是注释。Image 继承自 MaskableGraphic（同样继承自此抽象类的还有 RawImage 和 Text， ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2023/07/03/%E6%B8%B8%E6%88%8F%E6%8A%80%E6%9C%AF/UGUI/UnityUI%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8EUI%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AUI%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" title="UnityUI程序设计与UI性能优化（二）：UI系统的程序设计"><img class="post-bg" src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA63dffaa3b1762d6e793af5c10eb3503e.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="UnityUI程序设计与UI性能优化（二）：UI系统的程序设计"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/07/03/%E6%B8%B8%E6%88%8F%E6%8A%80%E6%9C%AF/UGUI/UnityUI%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8EUI%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AUI%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" title="UnityUI程序设计与UI性能优化（二）：UI系统的程序设计">UnityUI程序设计与UI性能优化（二）：UI系统的程序设计</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-07-03T13:51:22.046Z" title="发表于 2023-07-03 21:51:22">2023-07-03</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%BC%95%E6%93%8E%E5%8A%9F%E8%83%BD/">引擎功能</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E8%AE%BE%E8%AE%A1/">设计</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/Unity/">Unity</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%A1%86%E6%9E%B6/">框架</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/UI/">UI</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%B3%BB%E7%BB%9F/">系统</a></span></div><div class="content">聊完了什么是 UGUI，现在可以看看作为开发者的我们应该如何设计 UI 系统的整体框架了。我在大二的时候曾经基于栈写过一个 UIManager ，原理很简单：一层一层打开的 UI 面板天然符合栈的数据结构思想，所以通过一个栈来维护打开的面板就可以了。这个模块由于和 hhl 学长的 UI 模块重复了所以没有合并进仓库，当然我的想法也并没有考虑到太多商业化场景中的复杂情况，因此在这里就不详细展开让大家见笑了。
本篇文章将聊聊 hhl 学长的 UI 模块和更商业化项目中的 UI 模块的设计思路。
ProjectBase-UI分析
学长的代码在 github 仓库里，我对其中的UI部分拆开做了一张思维导图：

整个 UI 管理器是一个单例的管理器，可以通过 UIManager 开启或关闭面板，也可以通过 UIManager 查找指定的开启的面板并调用其中 BasePanel 的方法。单例很好用，但它也存在增加耦合的风险，具体可以看我之前写的关于单例模式的文章。
这个模块用起来很方便，但问题也很明显，比如说 UIManager 中隐藏面板的地方：
1234567public void HideP ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2023/06/30/%E6%B8%B8%E6%88%8F%E6%8A%80%E6%9C%AF/UGUI/UnityUI%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8EUI%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" title="UnityUI程序设计与UI性能优化（一）：基本概念"><img class="post-bg" src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VAa2bc4a06555293dfd21c7343d47b81cd.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="UnityUI程序设计与UI性能优化（一）：基本概念"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/06/30/%E6%B8%B8%E6%88%8F%E6%8A%80%E6%9C%AF/UGUI/UnityUI%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8EUI%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" title="UnityUI程序设计与UI性能优化（一）：基本概念">UnityUI程序设计与UI性能优化（一）：基本概念</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-06-30T00:00:00.000Z" title="发表于 2023-06-30 08:00:00">2023-06-30</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%BC%95%E6%93%8E%E5%8A%9F%E8%83%BD/">引擎功能</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Unity/">Unity</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/UI/">UI</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/UGUI/">UGUI</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/NGUI/">NGUI</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/FGUI/">FGUI</a></span></div><div class="content">常见UI框架
NGUI、UGUI、FGUI，这些“GUI”都是什么？GUI 通常指 graphic user interface（图形用户接口），是指采用图形方式显示的计算机操作用户界面。在这篇文章中我将简单介绍一下这几个常见名词，而在之后的章节中，笔者将从 UGUI 源码剖析、UI 框架的程序设计以及 UGUI 性能优化三个方面详细展开。
UGUI (Unity Graphic User Interface)
这是我们最常听说的 GUI，也是 Unity 内置的用户界面系统，从 Unity 4.6 版本开始推出，可以在Github上找到它的开源仓库。UGUI 以 Canvas 为核心，提供了丰富的 UI 组件（比如我们常用的button、slicer、text等）和可视化编辑工具，操作简单直观。


优点

Unity 原生的 GUI 系统，和 Unity 的其他模块（例如事件、渲染、动画）深度集成，并且由官方更新和维护。
社区中存在大量的教程和文档。



缺点

由于 Canvas 的重绘机制（特别是复杂或动态的 UI 元素）可能导致性能瓶颈，这部分会在 UI 性能优化的章节详细 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2023/06/24/%E8%AF%AD%E8%A8%80/C-map%E4%B8%8EC-dictionary%E7%9A%84%E5%BC%82%E5%90%8C/" title="两个经典的容器：C++ map与C# Dictionary"><img class="post-bg" src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA8d81e896161ab15cab746636a9345e1f.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="两个经典的容器：C++ map与C# Dictionary"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/06/24/%E8%AF%AD%E8%A8%80/C-map%E4%B8%8EC-dictionary%E7%9A%84%E5%BC%82%E5%90%8C/" title="两个经典的容器：C++ map与C# Dictionary">两个经典的容器：C++ map与C# Dictionary</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-06-24T09:12:24.000Z" title="发表于 2023-06-24 17:12:24">2023-06-24</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AF%AD%E8%A8%80/">语言</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/C/">C#</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/C/">C++</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/map/">map</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/hashmap/">hashmap</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/">语言基础</a></span></div><div class="content">为什么要单独说说map和Dictionary呢？因为这两个容器非常经典也很常使用到。对于一个开发者来说，了解它们如何实现是有必要的，官方文档中对二者的定义如下：
map用于存储和检索集合中的数据，此集合中的每个元素均为包含数据值和排序键的元素对，大小可变。
键的值是唯一的，用于自动排序数据。可以直接更改映射中的元素值。键值是常量，不能更改。
必须先删除与旧元素关联的键值，才能为新元素插入新键值。
map是可逆的，因为提供了双向迭代器来访问其元素。
12345template &lt;class Key,    class Type,    class Traits = less&lt;Key&gt;,    class Allocator=allocator&lt;pair &lt;const Key, Type&gt;&gt;&gt;class map;
其中Traits代表了自动排序的规则（默认为less），Allocator则是一种表示存储的分配器对象的类型（默认对，pair）。

dictionary表示键和值的集合，是一个泛型集合，它以不特定的顺序存储键值对。
字典不能包含重 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2023/05/27/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/A-%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/" title="寻星之路复盘——A*寻路算法及其优化"><img class="post-bg" src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VAc994a550b4f8c69b5b9d97c82b9669a9.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="寻星之路复盘——A*寻路算法及其优化"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/05/27/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/A-%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/" title="寻星之路复盘——A*寻路算法及其优化">寻星之路复盘——A*寻路算法及其优化</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-05-27T12:42:17.000Z" title="发表于 2023-05-27 20:42:17">2023-05-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/">项目复盘</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/">游戏编程</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/">经验分享</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/Unity/">Unity</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/">项目复盘</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/">寻路算法</a></span></div><div class="content">
论文答辩、送审等七七八八的事情终于结束了，相关评审也告一段落。感谢王宝土老师和学校电脑店的大力相助，毕设《寻星之路》demo终于是有惊无险地完成了它的使命。说实话我对这个作品可能不是太满意，因为它比我最开始设想的“三个章节、25个关卡、精妙绝伦的故事”相差甚远，仅两个月的独立开发时间，构思就浪费了小半个月，可叹。
在毕业答辩的技术部分中，占比相当大的就是接下来要介绍的 A* 了（另一部分是行为树，可以看看我的上一篇文章）。作为毕设的复盘，我将在这篇文章里聊聊我是怎么实现A*的，以及A*可以有哪方面的一些优化。
什么是A*？
A*是一种启发式搜索算法，是一种在平面上有多个节点的路径，求出最低通过成本的算法。该算法综合了最良优先搜索和 Dijkstra 算法的优点：在进行启发式搜索提高算法效率的同时，可以保证找到一条最优路径。
Dijkstra算法
Dijkstra算法使用类似广度优先搜索的方法解决赋权图（只能用在权重为正的图中）中的单源最短路径问题，其思想如下：

从源节点（起点）出发，寻找它与图中所有其它节点之间的最短路径。
记录当前已知的最短路径，并在寻找到更短的路径时更新。
一旦 ...</div></div></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fas fa-chevron-left fa-fw"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/#content-inner">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/#content-inner">5</a><a class="extend next" rel="next" href="/page/3/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">时光</div><div class="author-info__description">时间的旅者，无痕的过客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">107</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Guiny-Time"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Guiny-Time" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:guinytime@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎光临时光的博客！有关于本博客的详细信息请见<b>“关于”</b>。<br>本博客的访问方式：<a target="_blank" rel="noopener" href="https://cattyhouse-guiny.xyz/">https://cattyhouse-guiny.xyz/</a> <br><a target="_blank" rel="noopener" href="https://guiny-time.github.io/">https://guiny-time.github.io/</a></div></div><div class="sticky_layout"><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">62</div></div><div class="webinfo-item"><div class="item-name">本站总字数 :</div><div class="item-count">158.4k</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2025-02-10T04:22:19.296Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><script type="text/javascript" src="//rf.revolvermaps.com/0/0/2.js?i=5znsjgfcazv&amp;m=1&amp;s=130&amp;c=ff0000&amp;t=1" async="async"></script></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By 时光</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="translateLink" type="button" title="简繁转换">2</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>window.typedJSFn = {
  init: (str) => {
    window.typed = new Typed('#subtitle', Object.assign({
      strings: str,
      startDelay: 300,
      typeSpeed: 150,
      loop: true,
      backSpeed: 50,
    }, null))
  },
  run: (subtitleType) => {
    if (false) {
      if (typeof Typed === 'function') {
        subtitleType()
      } else {
        getScript('https://cdn.jsdelivr.net/npm/typed.js/dist/typed.umd.min.js').then(subtitleType)
      }
    } else {
      subtitleType()
    }
  }
}
</script><script>function subtitleType () {
  if (false) {
    typedJSFn.init(["时间的旅者，无痕的过客"])
  } else {
    document.getElementById("subtitle").textContent = '时间的旅者，无痕的过客'
  }
}
typedJSFn.run(subtitleType)</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'forest'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    btf.addModeChange('mermaid', () => {
      window.runMermaid()
    })

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script><script defer data-pjax src="https://gcore.jsdelivr.net/gh/xiabo2/CDN@latest/fishes.js"></script><script src="/js/universe.js"></script><div class="aplayer no-destroy" data-id="7263032154" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false" data-lrcType="-1"> </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>