<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>几/何/冰/川 - 时间的旅者，无痕的过客</title><meta name="author" content="时光"><meta name="copyright" content="时光"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="时间的旅者，无痕的过客">
<meta property="og:type" content="website">
<meta property="og:title" content="几&#x2F;何&#x2F;冰&#x2F;川">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="几&#x2F;何&#x2F;冰&#x2F;川">
<meta property="og:description" content="时间的旅者，无痕的过客">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/head.jpg">
<meta property="article:author" content="时光">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/head.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/page/2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 时光","link":"链接: ","source":"来源: 几/何/冰/川","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '几/何/冰/川',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2025-02-24 21:19:01'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mycss.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><canvas id="universe" ></canvas><link rel="stylesheet" href="/css/fish.css"><link rel="stylesheet" href="/css/wave.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/CodeByZach/pace/themes/green/pace-theme-flash.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.css"/><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/CodeByZach/pace/themes/blue/pace-theme-fill-left.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">65</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">116</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-hubspot"></i><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/cats/time/"><i class="fa-fw far fa-hourglass"></i><span> Time</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fab fa-connectdevelop"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 内容</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/next/"><i class="fa-fw fas fa-feather"></i><span> 笔记</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-hamburger"></i><span> 图片</span></a></li></ul></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url('/img/head_page.png')"><nav id="nav"><span id="blog-info"><a href="/" title="几/何/冰/川"><span class="site-name">几/何/冰/川</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-hubspot"></i><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/cats/time/"><i class="fa-fw far fa-hourglass"></i><span> Time</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fab fa-connectdevelop"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 内容</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/next/"><i class="fa-fw fas fa-feather"></i><span> 笔记</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-hamburger"></i><span> 图片</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">几/何/冰/川</h1><div id="site-subtitle"><span id="subtitle"></span></div><div id="site_social_icons"><a class="social-icon" href="https://github.com/Guiny-Time" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:guinytime@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="post_cover left"><a href="/2023/09/17/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/Hold-ON%EF%BC%81%E5%A4%8D%E7%9B%98%EF%BC%9A%E7%89%A9%E7%90%86%E6%9D%90%E8%B4%A8/" title="Hold-ON！复盘：物理材质"><img class="post-bg" src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VAe462e0c2d0477ea89497c1938dac9b73.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hold-ON！复盘：物理材质"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/09/17/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/Hold-ON%EF%BC%81%E5%A4%8D%E7%9B%98%EF%BC%9A%E7%89%A9%E7%90%86%E6%9D%90%E8%B4%A8/" title="Hold-ON！复盘：物理材质">Hold-ON！复盘：物理材质</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-09-17T08:10:26.000Z" title="发表于 2023-09-17 16:10:26">2023-09-17</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%BC%95%E6%93%8E%E5%8A%9F%E8%83%BD/">引擎功能</a></span><span class="article-meta tags"><span class="article-meta-separator"> </span><br><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Unity/">Unity</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%89%A9%E7%90%86/">物理</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%89%A9%E7%90%86%E6%A8%A1%E6%8B%9F/">物理模拟</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%BC%95%E6%93%8E/">引擎</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%89%A9%E7%90%86%E6%9D%90%E8%B4%A8/">物理材质</a></span></div><div class="content">什么是物理材质

物理材质定义了刚体表面的弹性和摩擦力，包括以下几项：

Dynamic Friction（动摩擦）在移动时使用的摩擦力，动摩擦将尝试在与另一个对象接触时减慢对象的速度。Dynamic Friction 通常为 0 到 1 之间的值。

值为 0 时表面就像冰一样滑
值为 1 将使对象迅速静止（除非用很大的力或重力推动对象）。


Static Friction（静摩擦）当对象静止在表面上时使用的摩擦力，静摩擦力会阻止对象开始移动，如果向对象施加足够大的力，对象才会开始移动。Static Friction 通常为 0 到 1 之间的值。

值为 0 时表面就像冰一样滑
值为 1 时物体将很难移动。


Bounciness（弹性）表面的弹性如何？值为 0 将不会反弹。值为 1 将在反弹时不产生任何能量损失，预计会有一些近似值，但可能只会给模拟增加少量能量。



除此之外，还有一个 Friction Combine 和 Bounce Combine。这两个“组合”表示了两个碰撞对象之间摩擦力/弹性的组合方式，Unity 将根据所选择的模式对两个物体施加相同的弹性和摩擦力 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2023/09/03/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/Hold-ON%EF%BC%81%E5%A4%8D%E7%9B%98%EF%BC%9A%E5%85%B3%E8%8A%82%E4%B8%8E%E9%93%B0%E9%93%BE/" title="Hold-ON！复盘：物理关节"><img class="post-bg" src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VAccd21636323a23cada9dee7080c2e223.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hold-ON！复盘：物理关节"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/09/03/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/Hold-ON%EF%BC%81%E5%A4%8D%E7%9B%98%EF%BC%9A%E5%85%B3%E8%8A%82%E4%B8%8E%E9%93%B0%E9%93%BE/" title="Hold-ON！复盘：物理关节">Hold-ON！复盘：物理关节</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-09-03T15:50:12.000Z" title="发表于 2023-09-03 23:50:12">2023-09-03</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%BC%95%E6%93%8E%E5%8A%9F%E8%83%BD/">引擎功能</a></span><span class="article-meta tags"><span class="article-meta-separator"> </span><br><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Unity/">Unity</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%89%A9%E7%90%86/">物理</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%89%A9%E7%90%86%E6%A8%A1%E6%8B%9F/">物理模拟</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%BC%95%E6%93%8E/">引擎</a></span></div><div class="content">我们经常在游戏中看到下面的 gif 里所展示的“可交互场景对象”。这样的对象的存在增添了场景的可交互性，让场景不那么死板，显得更有生气和灵性。除了下图展示的游戏 HUE 之外，GRIS、空洞骑士等游戏也大量使用了可交换场景对象。

这种可交互的场景对象是怎么实现的呢？这就要引出文章的主题：Joints（关节）了。
什么是关节Joints（关节）是一种用于将两个刚体连接在一起的物理组件，通常用于模拟现实世界中的连接、约束或机械行为。例如，你可以用关节连接一个物体到另一个物体、固定到某个位置，或者模拟摆锤、弹簧等效果。
固定关节/Fixed
固定关节（Fixed Joint）将两个对象固定在相对位置，适合用来模拟焊接、粘合等固定效果。例如将一个箱子固定在某个位置、或者连接两个不会相对移动的物体（例如把粘土炸弹固定到某个移动对象上）。
可使用固定关节面板上的 Break Force 和 Break Torque 属性来设置关节强度的限制。如果这些值小于无穷大，并对该对象施加大于这些限制的力/扭矩，则其固定关节将被破坏并将摆脱其约束的束缚。

另外，固定关节的刚体类型也会影响到展示的效果，例如 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2023/08/28/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/Hold-ON%EF%BC%81%E5%A4%8D%E7%9B%98%EF%BC%9AUnity%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/" title="Hold-ON!复盘：Unity中的物理碰撞"><img class="post-bg" src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA4020ebaadd640a281069f2cc095befe8.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hold-ON!复盘：Unity中的物理碰撞"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/08/28/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/Hold-ON%EF%BC%81%E5%A4%8D%E7%9B%98%EF%BC%9AUnity%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/" title="Hold-ON!复盘：Unity中的物理碰撞">Hold-ON!复盘：Unity中的物理碰撞</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-08-28T15:39:15.000Z" title="发表于 2023-08-28 23:39:15">2023-08-28</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%BC%95%E6%93%8E%E5%8A%9F%E8%83%BD/">引擎功能</a></span><span class="article-meta tags"><span class="article-meta-separator"> </span><br><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Unity/">Unity</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%89%A9%E7%90%86/">物理</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%89%A9%E7%90%86%E6%A8%A1%E6%8B%9F/">物理模拟</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%BC%95%E6%93%8E/">引擎</a></span></div><div class="content">我们参加的 48 小时 jam，第三届《益·游未尽》的比赛作品——《Hold-ON!》在比赛截至前平安上线 itch 平台了，欢迎大家前来试玩！
Hold on- h5 version by Guinyの时光

在这次的项目中，我和另一位程序大量使用到了 Unity 的物理系统，其中包括通过力驱使角色移动、玩家之间的碰撞、触发器检测等，我想借此机会在复盘文章中好好聊一聊 Unity 的物理系统，以及物理系统在实际项目中的一些应用。 
Unity 中的物理模拟包括碰撞检测、力学模拟、刚体运动和关节（铰链等）等等。Unity 的物理引擎按照对象类型分为两种实现：

对于 3D 对象的物理系统是基于 NVIDIA 的实时开源物理引擎 PhysX 实现的。
对于 2D 对象的物理系统是基于开源的物理引擎 Box2D 实现的。 

如果是 Unity6 的面向数据（DOTS，即 Unity 的 ECS 框架）方案，则采用 Unity Physics 包，在本文中不多做讨论。
刚体物理在 Unity 3D 中，物理系统有两个很基本的组件：Collider（碰撞体）和 Rigidbody（刚体）。希 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2023/07/20/%E6%B8%B8%E6%88%8F%E6%8A%80%E6%9C%AF/UGUI/UnityUI%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8EUI%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AUGUI%E4%BC%98%E5%8C%96/" title="UnityUI程序设计与UI性能优化（五）：UGUI性能优化指南"><img class="post-bg" src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA1fc5ff9e9083059d3dab93de58d27b40.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="UnityUI程序设计与UI性能优化（五）：UGUI性能优化指南"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/07/20/%E6%B8%B8%E6%88%8F%E6%8A%80%E6%9C%AF/UGUI/UnityUI%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8EUI%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AUGUI%E4%BC%98%E5%8C%96/" title="UnityUI程序设计与UI性能优化（五）：UGUI性能优化指南">UnityUI程序设计与UI性能优化（五）：UGUI性能优化指南</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-07-20T11:23:22.046Z" title="发表于 2023-07-20 19:23:22">2023-07-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%BC%95%E6%93%8E%E5%8A%9F%E8%83%BD/">引擎功能</a></span><span class="article-meta tags"><span class="article-meta-separator"> </span><br><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Unity/">Unity</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E4%BC%98%E5%8C%96/">优化</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/UI/">UI</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/UGUI/">UGUI</a></span></div><div class="content">UGUI是一个很强大的系统，通过它我们可以拼出多姿多彩的UI界面，让玩家更好的与游戏UI进行交互。但作为开发者，我们也需要注意UGUI中潜在的性能优化问题，防止游戏因为 drawcall 过多、频繁 rebatch / rebuild 而造成发热和卡顿（特别是对于低端机型来说）。




性能瓶颈
硬件影响
典型场景
CPU耗时参考




过度绘制
GPU负载
半透明元素叠加
每层增加0.5-1ms


批次破碎
DrawCall激增
动态列表滚动
100元素≈30DC


布局重建
主线程卡顿
LayoutGroup嵌套使用
嵌套3层≈15ms




那么该怎么对 UI 进行优化呢？我们优化的主要目的就是减少绘制调用（drawcall）和布局重建的次数。绘制调用发生在 CPU 与 GPU 中间，当 CPU 打包好渲染数据（例如顶点、纹理、材质等）之后，就会发起一次绘制调用，将这些信息打包到显存以通知 GPU 进行绘制。也就是说，有多少个绘制调用，CPU 就需要向 GPU 发送多少次通知。drawcall 太高，意味着有频繁地改变渲染状态，这是很慢的操作（相对于GPU执行其内部的渲 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2023/07/15/%E6%B8%B8%E6%88%8F%E6%8A%80%E6%9C%AF/UGUI/UnityUI%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8EUI%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AUGUI%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6/" title="UnityUI程序设计与UI性能优化（四）：UGUI的点击事件"><img class="post-bg" src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VAa198651e59fd8df47130a8f8b489dbc5.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="UnityUI程序设计与UI性能优化（四）：UGUI的点击事件"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/07/15/%E6%B8%B8%E6%88%8F%E6%8A%80%E6%9C%AF/UGUI/UnityUI%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8EUI%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AUGUI%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6/" title="UnityUI程序设计与UI性能优化（四）：UGUI的点击事件">UnityUI程序设计与UI性能优化（四）：UGUI的点击事件</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-07-15T08:41:18.000Z" title="发表于 2023-07-15 16:41:18">2023-07-15</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%BC%95%E6%93%8E%E5%8A%9F%E8%83%BD/">引擎功能</a></span><span class="article-meta tags"><span class="article-meta-separator"> </span><br><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Unity/">Unity</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/UI/">UI</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/UGUI/">UGUI</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%BA%90%E7%A0%81/">源码</a></span></div><div class="content">
在 Unity 的 UI 系统中，Button 是最常见的可交互组件之一（除此之外还有 Slider、Toggle、Input Field、Scroll Bar、Drop Down），其点击事件不仅是开发者构建用户交互的基础，更是一个复杂而精巧的功能模块。本文将从 UGUI 的源码层面出发，全面剖析 Button 点击事件的实现原理，理解其设计思路与内部逻辑。

按钮点击的触发流程相信每个介绍 UGUI 的新手视频都会讲到 Button 的点击事件。在 Unity 中，如果我们想为一个按钮添加事件有两种实现方式，一种是直接在检查器上为该按钮绑定事件:

另一种是通过代码为按钮的 onClick 加上方法监听:
123GetComponent&lt;Button&gt;().onClick.AddListener(() =&gt; &#123;     ...//按钮点击的处理逻辑&#125;);
这两者是等价的。让我们沿着 onClick 的调用链一步一步看看是怎么回事吧。
Button：Press -&gt; OnPointerClick我们来看看 Button 的源码吧！在 UG ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2023/07/11/%E6%B8%B8%E6%88%8F%E6%8A%80%E6%9C%AF/UGUI/UnityUI%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8EUI%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="UnityUI程序设计与UI性能优化（三）：UGUI的渲染流程"><img class="post-bg" src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA96d03380d5b9586247c6962d0c4f1351.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="UnityUI程序设计与UI性能优化（三）：UGUI的渲染流程"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/07/11/%E6%B8%B8%E6%88%8F%E6%8A%80%E6%9C%AF/UGUI/UnityUI%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8EUI%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="UnityUI程序设计与UI性能优化（三）：UGUI的渲染流程">UnityUI程序设计与UI性能优化（三）：UGUI的渲染流程</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-07-11T11:23:22.046Z" title="发表于 2023-07-11 19:23:22">2023-07-11</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%BC%95%E6%93%8E%E5%8A%9F%E8%83%BD/">引擎功能</a></span><span class="article-meta tags"><span class="article-meta-separator"> </span><br><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Unity/">Unity</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/UI/">UI</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/UGUI/">UGUI</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%BA%90%E7%A0%81/">源码</a></span></div><div class="content">UGUI的渲染过程Unity中渲染的物体都是由网格(Mesh)构成的，而网格的绘制单元是图元(点、线、三角面)。在 Unity 中渲染一个 2D 或 3D 对象时，需要由 CPU 提起一个 draw call（绘制调用），经过一个完整的渲染管线流程，经由 GPU 处理最后输出像素到屏幕上。那么对于 UGUI 元素（例如Image）来说是不是也是一样的呢？

绘制一个 UI，简而言之就是绘制 UI 的形状与图元：

生成 mesh：mesh 由顶点和三角形组成，顶点里包括 UV 坐标、顶点颜色。
渲染图元：将纹理渲染到 mesh 上。

我们将以绘制一张 Image 为例，学习 UGUI 的渲染过程。

可以看到，新建一个 Image 对象，默认挂载了Rect Transform、Canvas Renderer 和 Image 三个组件。Image 的源码位于 Runtime/UI/Core/Image.cs，这个文件有 1000 多行，初见感觉挺吓人的，但其实大部分都是注释。Image 继承自 MaskableGraphic（同样继承自此抽象类的还有 RawImage 和 Text，顾 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2023/07/03/%E6%B8%B8%E6%88%8F%E6%8A%80%E6%9C%AF/UGUI/UnityUI%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8EUI%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AUI%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" title="UnityUI程序设计与UI性能优化（二）：UI系统的程序设计"><img class="post-bg" src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA63dffaa3b1762d6e793af5c10eb3503e.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="UnityUI程序设计与UI性能优化（二）：UI系统的程序设计"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/07/03/%E6%B8%B8%E6%88%8F%E6%8A%80%E6%9C%AF/UGUI/UnityUI%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8EUI%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AUI%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" title="UnityUI程序设计与UI性能优化（二）：UI系统的程序设计">UnityUI程序设计与UI性能优化（二）：UI系统的程序设计</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-07-03T13:51:22.046Z" title="发表于 2023-07-03 21:51:22">2023-07-03</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%BC%95%E6%93%8E%E5%8A%9F%E8%83%BD/">引擎功能</a></span><span class="article-meta tags"><span class="article-meta-separator"> </span><br><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E8%AE%BE%E8%AE%A1/">设计</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/Unity/">Unity</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%A1%86%E6%9E%B6/">框架</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/UI/">UI</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%B3%BB%E7%BB%9F/">系统</a></span></div><div class="content">聊完了什么是 UGUI，现在可以看看作为开发者的我们应该如何设计 UI 系统的整体框架了。我在大二的时候曾经基于栈写过一个 UIManager ，原理很简单：一层一层打开的 UI 面板天然符合栈的数据结构思想，所以通过一个栈来维护打开的面板就可以了。这个模块由于和 hhl 学长的 UI 模块重复了所以没有合并进仓库，当然我的想法也并没有考虑到太多商业化场景中的复杂情况，因此在这里就不详细展开让大家见笑了。
本篇文章将聊聊 hhl 学长的 UI 模块和更商业化项目中的 UI 模块的设计思路。
ProjectBase-UI分析学长的代码在 github 仓库里，我对其中的UI部分拆开做了一张思维导图：

整个 UI 管理器是一个单例的管理器，可以通过 UIManager 开启或关闭面板，也可以通过 UIManager 查找指定的开启的面板并调用其中 BasePanel 的方法。单例很好用，但它也存在增加耦合的风险，具体可以看我之前写的关于单例模式的文章。
这个模块用起来很方便，但问题也很明显，比如说 UIManager 中隐藏面板的地方：1234567public void HidePan ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2023/06/30/%E6%B8%B8%E6%88%8F%E6%8A%80%E6%9C%AF/UGUI/UnityUI%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8EUI%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" title="UnityUI程序设计与UI性能优化（一）：基本概念"><img class="post-bg" src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VAa2bc4a06555293dfd21c7343d47b81cd.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="UnityUI程序设计与UI性能优化（一）：基本概念"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/06/30/%E6%B8%B8%E6%88%8F%E6%8A%80%E6%9C%AF/UGUI/UnityUI%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8EUI%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" title="UnityUI程序设计与UI性能优化（一）：基本概念">UnityUI程序设计与UI性能优化（一）：基本概念</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-06-30T00:00:00.000Z" title="发表于 2023-06-30 08:00:00">2023-06-30</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%BC%95%E6%93%8E%E5%8A%9F%E8%83%BD/">引擎功能</a></span><span class="article-meta tags"><span class="article-meta-separator"> </span><br><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Unity/">Unity</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/UI/">UI</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/UGUI/">UGUI</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/NGUI/">NGUI</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/FGUI/">FGUI</a></span></div><div class="content">常见UI框架NGUI、UGUI、FGUI，这些“GUI”都是什么？GUI 通常指 graphic user interface（图形用户接口），是指采用图形方式显示的计算机操作用户界面。在这篇文章中我将简单介绍一下这几个常见名词，而在之后的章节中，笔者将从 UGUI 源码剖析、UI 框架的程序设计以及 UGUI 性能优化三个方面详细展开。
UGUI (Unity Graphic User Interface)这是我们最常听说的 GUI，也是 Unity 内置的用户界面系统，从 Unity 4.6 版本开始推出，可以在Github上找到它的开源仓库。UGUI 以 Canvas 为核心，提供了丰富的 UI 组件（比如我们常用的button、slicer、text等）和可视化编辑工具，操作简单直观。

优点

Unity 原生的 GUI 系统，和 Unity 的其他模块（例如事件、渲染、动画）深度集成，并且由官方更新和维护。
社区中存在大量的教程和文档。


缺点

由于 Canvas 的重绘机制（特别是复杂或动态的 UI 元素）可能导致性能瓶颈，这部分会在 UI 性能优化的章节详细展开。
 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2023/06/24/%E8%AF%AD%E8%A8%80/C-map%E4%B8%8EC-dictionary%E7%9A%84%E5%BC%82%E5%90%8C/" title="两个经典的容器：C++ map与C# Dictionary"><img class="post-bg" src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA8d81e896161ab15cab746636a9345e1f.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="两个经典的容器：C++ map与C# Dictionary"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/06/24/%E8%AF%AD%E8%A8%80/C-map%E4%B8%8EC-dictionary%E7%9A%84%E5%BC%82%E5%90%8C/" title="两个经典的容器：C++ map与C# Dictionary">两个经典的容器：C++ map与C# Dictionary</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-06-24T09:12:24.000Z" title="发表于 2023-06-24 17:12:24">2023-06-24</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AF%AD%E8%A8%80/">语言</a></span><span class="article-meta tags"><span class="article-meta-separator"> </span><br><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/C/">C#</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/C/">C++</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/map/">map</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/hashmap/">hashmap</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/">语言基础</a></span></div><div class="content">为什么要单独说说map和Dictionary呢？因为这两个容器非常经典也很常使用到。对于一个开发者来说，了解它们如何实现是有必要的，官方文档中对二者的定义如下：
map用于存储和检索集合中的数据，此集合中的每个元素均为包含数据值和排序键的元素对，大小可变。键的值是唯一的，用于自动排序数据。可以直接更改映射中的元素值。键值是常量，不能更改。必须先删除与旧元素关联的键值，才能为新元素插入新键值。map是可逆的，因为提供了双向迭代器来访问其元素。
12345template &lt;class Key,    class Type,    class Traits = less&lt;Key&gt;,    class Allocator=allocator&lt;pair &lt;const Key, Type&gt;&gt;&gt;class map;
其中Traits代表了自动排序的规则（默认为less），Allocator则是一种表示存储的分配器对象的类型（默认对，pair）。

dictionary表示键和值的集合，是一个泛型集合，它以不特定的顺序存储键值对。字典不能包含重复键 或 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2023/05/27/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/A-%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/" title="寻星之路复盘——A*寻路算法及其优化"><img class="post-bg" src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VAc994a550b4f8c69b5b9d97c82b9669a9.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="寻星之路复盘——A*寻路算法及其优化"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/05/27/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/A-%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/" title="寻星之路复盘——A*寻路算法及其优化">寻星之路复盘——A*寻路算法及其优化</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-05-27T12:42:17.000Z" title="发表于 2023-05-27 20:42:17">2023-05-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/">项目复盘</a></span><span class="article-meta tags"><span class="article-meta-separator"> </span><br><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Unity/">Unity</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/">经验分享</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/">游戏编程</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/">项目复盘</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/">寻路算法</a></span></div><div class="content">
论文答辩、送审等七七八八的事情终于结束了，相关评审也告一段落。感谢王宝土老师和学校电脑店的大力相助，毕设《寻星之路》demo终于是有惊无险地完成了它的使命。说实话我对这个作品可能不是太满意，因为它比我最开始设想的“三个章节、25个关卡、精妙绝伦的故事”相差甚远，仅两个月的独立开发时间，构思就浪费了小半个月，可叹。
在毕业答辩的技术部分中，占比相当大的就是接下来要介绍的 A* 了（另一部分是行为树，可以看看我的上一篇文章）。作为毕设的复盘，我将在这篇文章里聊聊我是怎么实现A*的，以及A*可以有哪方面的一些优化。
什么是A*？A*是一种启发式搜索算法，是一种在平面上有多个节点的路径，求出最低通过成本的算法。该算法综合了最良优先搜索和 Dijkstra 算法的优点：在进行启发式搜索提高算法效率的同时，可以保证找到一条最优路径。
Dijkstra算法Dijkstra算法使用类似广度优先搜索的方法解决赋权图（只能用在权重为正的图中）中的单源最短路径问题，其思想如下：

从源节点（起点）出发，寻找它与图中所有其它节点之间的最短路径。
记录当前已知的最短路径，并在寻找到更短的路径时更新。
一旦找到 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2023/05/10/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/%E6%B8%B8%E6%88%8FAI-%E7%8A%B6%E6%80%81%E6%9C%BA%E4%B8%8E%E8%A1%8C%E4%B8%BA%E6%A0%91/" title="游戏AI-状态机与行为树"><img class="post-bg" src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA9bda383188cb8e39bd77a5e7736b7948.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="游戏AI-状态机与行为树"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/05/10/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/%E6%B8%B8%E6%88%8FAI-%E7%8A%B6%E6%80%81%E6%9C%BA%E4%B8%8E%E8%A1%8C%E4%B8%BA%E6%A0%91/" title="游戏AI-状态机与行为树">游戏AI-状态机与行为树</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-05-09T16:00:00.000Z" title="发表于 2023-05-10 00:00:00">2023-05-10</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/">项目复盘</a></span><span class="article-meta tags"><span class="article-meta-separator"> </span><br><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/AI/">AI</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%8A%B6%E6%80%81%E6%9C%BA/">状态机</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E8%A1%8C%E4%B8%BA%E6%A0%91/">行为树</a></span></div><div class="content">什么是游戏AI？游戏中，能模拟玩家行为、和玩家进行交互的游戏对象就可以被称作为游戏 AI。AI 可以观察环境、做出反应，并达到相应的目的。需要实现一个 AI，我们通常需要借助游戏引擎中的动画、物理、渲染，以及 AI 系统中的环境感知、寻路系统和 gameplay 来实现。常见的 AI 有 NPC、敌人、队友等，游戏 AI 存在的目的在于提升玩家的游戏代入感、增强玩家的心流体验。

动画：动画（如骨骼动画、帧动画、程序动画、morph动画、curve动画、顶点动画等）可以让 AI 看起来更真实，不那么生硬死板。
物理：提供真实世界的感知和反馈，为游戏 AI 增强效果，让 AI 有更丰富的感知和交互表现。物理引擎可以用于碰撞检测/事件触发、仿真（头发模拟、流体模拟等）、AI感知、场景查询等。
渲染：经过渲染引擎的渲染，游戏 AI 的形象才能最终显示在屏幕上。次世代渲染通过应用阶段、几何阶段（模型变换、视图变换、投影变换）、光栅化阶段实现最终效果。
环境感知：AI 能感受周围环境并根据环境做出相应的决策。环境感知主要是通过数据查询（例如 UE 中的 EQS，即环境场景查询）来实现的。我们可以 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2023/03/12/%E6%B8%B8%E6%88%8F%E6%8A%80%E6%9C%AF/Cinemachine%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/" title="Cinemachine基础学习"><img class="post-bg" src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA8ba9748cd63f7a972eae71287b91c644.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Cinemachine基础学习"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/03/12/%E6%B8%B8%E6%88%8F%E6%8A%80%E6%9C%AF/Cinemachine%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/" title="Cinemachine基础学习">Cinemachine基础学习</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-03-12T04:22:51.000Z" title="发表于 2023-03-12 12:22:51">2023-03-12</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%BC%95%E6%93%8E%E5%8A%9F%E8%83%BD/">引擎功能</a></span><span class="article-meta tags"><span class="article-meta-separator"> </span><br><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Cinemachine/">Cinemachine</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/Unity/">Unity</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%9B%B8%E6%9C%BA/">相机</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%8E%A7%E5%88%B6/">控制</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E8%A7%92%E8%89%B2/">角色</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/3C/">3C</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/">经验分享</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%BC%95%E6%93%8E%E5%8A%9F%E8%83%BD/">引擎功能</a></span></div><div class="content">
相机的控制与管理是游戏体验中相当重要的一部分，好的镜头语言能够让玩家更容易地进入心流，更好地体验游戏。相机属于游戏 3C 中的 Camera（另外两 C 分别是角色和控制），其地位不言而喻。在本文中，我将探索如何通过 Unity 的 Cinemachine 实现相机跟随的一系列功能。
Cinemachine 是 Unity 提供的高级相机系统，用于创建平滑、智能的摄像机跟随和过渡效果。Cinemachine 能够自动适应游戏场景，无需手动编写复杂的相机控制代码，让开发者专注于游戏玩法。要想在项目中使用 Cinemachine，需要从 Package Manager 中安装 Cinemachine 包。
导入 Cinemachine 包之后，在场景中创建一个虚拟相机，相机的视野立即产生了变化。观察视窗我们会发现游戏原本的主相机多出了一个图标，点开一看是一个名为“Cinemachine Brain”的组件造成的。自动添加了 Cinemachine Virtual Camera 脚本的虚拟相机和添加了 Cinemachine Brain 的主相机一起，组成了 Cinemachine 的基本 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2023/02/27/%E8%AF%AD%E8%A8%80/C-%E8%BF%9B%E9%98%B6%EF%BC%88%E5%9B%9B%EF%BC%89-%E4%BA%8B%E4%BB%B6/" title="C#进阶（四）-事件"><img class="post-bg" src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA694daa11e9bbd58f8a9deffbdbee5b84.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C#进阶（四）-事件"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/02/27/%E8%AF%AD%E8%A8%80/C-%E8%BF%9B%E9%98%B6%EF%BC%88%E5%9B%9B%EF%BC%89-%E4%BA%8B%E4%BB%B6/" title="C#进阶（四）-事件">C#进阶（四）-事件</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-02-27T04:23:36.000Z" title="发表于 2023-02-27 12:23:36">2023-02-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AF%AD%E8%A8%80/">语言</a></span><span class="article-meta tags"><span class="article-meta-separator"> </span><br><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/C/">C#</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/">语言基础</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%89%B9%E6%80%A7/">特性</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E4%BA%8B%E4%BB%B6/">事件</a></span></div><div class="content">什么是事件？event 是C#的一个关键字，是对于委托的一种更安全的封装方式（只能作为成员存在于类/接口或结构体中），这使得被 event 关键字修饰的委托只能在声明它的类中被调用。
1234// 定义一个委托类型，用于事件处理程序public delegate void NotifyEventHandler(object sender, EventArgs e);// 用event修饰委托实例public event NotifyEventHandler _processCompleted;
你一定好奇这里 objrct 类型的 sender 和 EventArgs 类型的 e 分别是什么。其实从命名上也可以看出来，EventArgs 表示事件参数（EventArguments）的类的基类，它可以用来记录事件传递的额外信息（例如触发的时间、位置等等）。在实际使用中，开发者需要自行定义派生自 EventArgs 类的事件参数，例如：
123public class ButtonClickEventArgs : EventArgs &#123;    public string Time ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2023/02/23/%E8%AF%AD%E8%A8%80/C-%E8%BF%9B%E9%98%B6%EF%BC%88%E4%B8%89%EF%BC%89-%E5%A7%94%E6%89%98/" title="C#进阶（三）-委托"><img class="post-bg" src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VAd7b8b231ed9781bba1c0554bcf9d08a4.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C#进阶（三）-委托"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/02/23/%E8%AF%AD%E8%A8%80/C-%E8%BF%9B%E9%98%B6%EF%BC%88%E4%B8%89%EF%BC%89-%E5%A7%94%E6%89%98/" title="C#进阶（三）-委托">C#进阶（三）-委托</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-02-23T15:12:36.000Z" title="发表于 2023-02-23 23:12:36">2023-02-23</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AF%AD%E8%A8%80/">语言</a></span><span class="article-meta tags"><span class="article-meta-separator"> </span><br><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/C/">C#</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/">语言基础</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%89%B9%E6%80%A7/">特性</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%A7%94%E6%89%98/">委托</a></span></div><div class="content">什么是委托？委托（delegate）类似于C++中的函数指针，是类型化了的函数指针（一种可以存放特定参数/返回值类型方法的容器），可以作为参数一样被传递。
12345678910111213141516// 定义了一个返回值和参数为空的委托类型private delegate void MyDelegate();// 声明MyDelegate类型的一个委托private MyDelegate _myDelegate;public void Main()&#123;    // 为委托赋值方法    _myDelegate = Test;    // 调用委托    _myDelegate();&#125;// 挂载到委托上的函数，其参数和返回值需与委托一致，否则不会被感知public void Test()&#123;    Console.WriteLine(&quot;Test&quot;);&#125;
这时有人就会有疑问了：这和直接在 Main 中调用 Test 方法有什么区别呢？
1234567public void Main()&#123;    Test(); // 执行 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2023/02/17/%E8%AF%AD%E8%A8%80/C-%E8%BF%9B%E9%98%B6%EF%BC%88%E4%BA%8C%EF%BC%89-%E5%8F%8D%E5%B0%84/" title="C#进阶（二）-反射"><img class="post-bg" src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VAfe5b9f1fc358476fcf0edc84ea82ed93.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C#进阶（二）-反射"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/02/17/%E8%AF%AD%E8%A8%80/C-%E8%BF%9B%E9%98%B6%EF%BC%88%E4%BA%8C%EF%BC%89-%E5%8F%8D%E5%B0%84/" title="C#进阶（二）-反射">C#进阶（二）-反射</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-02-17T15:12:36.000Z" title="发表于 2023-02-17 23:12:36">2023-02-17</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AF%AD%E8%A8%80/">语言</a></span><span class="article-meta tags"><span class="article-meta-separator"> </span><br><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/C/">C#</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/">语言基础</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E5%8F%8D%E5%B0%84/">反射</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%89%B9%E6%80%A7/">特性</a></span></div><div class="content">什么是反射？反射（Reflection）指程序可以访问、检测和修改它本身或其他程序集状态或行为的一种能力。开发者可以使用反射动态地创建类型的实例，将类型绑定到现有对象，或从现有对象中获取类型，还可以调用类型的方法或访问其字段和属性。
换句话说，反射指的是程序在运行时可以查看其他程序集或自身的元数据。一个运行的程序查看本身或者其他元数据的行为就叫做反射。函数在执行时，通过反射可以得到其他程序集或自己程序集代码的各种信息（即元数据信息，包括类、函数、变量、对象等等），可以实例化它们、执行它们或操作它们。
反射可以在程序编译后获得信息，提高了程序的拓展性和灵活性。

程序运行时得到所有元数据，包括元数据的特性
程序运行时实例化对象、操作对象
程序运行时创建新对象，用这些对象执行任务



程序集程序集是由编译器编译得到的、供进一步编译执行的中间产物，在windows系统中一般表现为后缀为.dll（库文件）或.exe（可执行文件）的文件

元数据描述数据的数据，例如程序中的类、类中的函数、变量等信息就是程序的元数据。元数据保存在程序集中



反射语法TypeType类是类的信息类，也是实现反 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2023/02/13/%E8%AF%AD%E8%A8%80/C-%E9%97%AD%E5%8C%85/" title="C#进阶（一）-闭包"><img class="post-bg" src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA0431fbacc38d0fdf8123bab71d5622f0.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C#进阶（一）-闭包"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/02/13/%E8%AF%AD%E8%A8%80/C-%E9%97%AD%E5%8C%85/" title="C#进阶（一）-闭包">C#进阶（一）-闭包</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2023-02-13T12:07:22.000Z" title="发表于 2023-02-13 20:07:22">2023-02-13</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AF%AD%E8%A8%80/">语言</a></span><span class="article-meta tags"><span class="article-meta-separator"> </span><br><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/C/">C#</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/">语言基础</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%89%B9%E6%80%A7/">特性</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E9%97%AD%E5%8C%85/">闭包</a></span></div><div class="content">什么是闭包？C#中的闭包（Closure）指函数可以访问其定义作用域之外的变量（外部变量）。换句话说，一个闭包就是一个“捕获”或“携带”了其生成的环境中、所引用的自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。不止C#中存在闭包的特性，JS中也存在闭包。
C#闭包最常见的例子是在匿名函数（或Lambda表达式）中捕获自由变量，例如：
12345678910public static Action a;    public static void Main(string[] args) &#123;        for (int i = 0; i &lt; 5; i++) &#123;            a += () =&gt; &#123;                // 闭包捕获i                Console.WriteLine(i);            &#125;;         &#125;    a();&#125;

为什么输出全是 5 而不是 1, 2, 3, 4, 5 呢？那是因为for循 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2022/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E5%9F%BA%E4%BA%8EGerstner%20Wave%E7%AE%97%E6%B3%95%E7%9A%84%E6%B5%B7%E6%B4%8B%E5%AE%9E%E7%8E%B0/" title="基于Gerstner Wave算法的海洋实现"><img class="post-bg" src="/2022/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E5%9F%BA%E4%BA%8EGerstner%20Wave%E7%AE%97%E6%B3%95%E7%9A%84%E6%B5%B7%E6%B4%8B%E5%AE%9E%E7%8E%B0/S0eed0c9febdb4b9c820dd0ae82bfd6a3q.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于Gerstner Wave算法的海洋实现"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E5%9F%BA%E4%BA%8EGerstner%20Wave%E7%AE%97%E6%B3%95%E7%9A%84%E6%B5%B7%E6%B4%8B%E5%AE%9E%E7%8E%B0/" title="基于Gerstner Wave算法的海洋实现">基于Gerstner Wave算法的海洋实现</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-09-29T08:20:39.263Z" title="发表于 2022-09-29 16:20:39">2022-09-29</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/">效果实现</a></span><span class="article-meta tags"><span class="article-meta-separator"> </span><br><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Unity/">Unity</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/demo/">demo</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/ShaderLab/">ShaderLab</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/shader/">shader</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%B0%B4%E4%BD%93/">水体</a></span></div><div class="content">介绍Sin Wave的局限在引入Gerstner Wave之前，人们更多使用正弦波来模拟海浪，因为正弦波天生具有类似海浪的形状。但它的局限也很明显，那就是波峰过于圆润，纵然有办法通过代数方法约束波峰的形状，但效果还是无法达到预期的尖锐。

什么是Gerstner WaveGerstner Wave是Sin Wave的后继者，到现在也是一种常用的用来模拟海洋波浪的算法。他的历史其实已经很古老了，可以追溯到1986年。相比于快速傅里叶变换(FFT)，Gerstner Wave方法的开销更小，效果也很真实，因此被更多的应用与游戏领域（FFT更适合影视行业，因为它的效果更好但开销更大）。Gerstner Wave的公式如下：
P(x,y,t) = \begin{pmatrix}x + \sum({Q_{i}A_{i} * D_{i}.x * \cos(\omega_{i} D_{i}(x,y) + \varphi t}))  \\y + \sum({Q_{i}A_{i} * D_{i}.y * \cos(\omega_{i} D_{i}(x,y) + \varphi t}))  \\\sum( ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2022/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E6%B0%B4%E9%9D%A2%E3%80%81%E6%B3%A2%E6%B5%AA%E5%92%8C%E7%99%BD%E6%B2%AB/" title="水面、波浪、白沫和焦散"><img class="post-bg" src="/2022/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E6%B0%B4%E9%9D%A2%E3%80%81%E6%B3%A2%E6%B5%AA%E5%92%8C%E7%99%BD%E6%B2%AB/Scf892eeb5b6b48d882948552f796fcd6T.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="水面、波浪、白沫和焦散"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E6%B0%B4%E9%9D%A2%E3%80%81%E6%B3%A2%E6%B5%AA%E5%92%8C%E7%99%BD%E6%B2%AB/" title="水面、波浪、白沫和焦散">水面、波浪、白沫和焦散</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-09-13T08:20:39.263Z" title="发表于 2022-09-13 16:20:39">2022-09-13</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/">效果实现</a></span><span class="article-meta tags"><span class="article-meta-separator"> </span><br><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Unity/">Unity</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/demo/">demo</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/ShaderLab/">ShaderLab</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/shader/">shader</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E6%B0%B4%E4%BD%93/">水体</a></span></div><div class="content">介绍与准备我最近打算开始做毕设项目的场景啦XD！这个项目的名字叫元素宇宙(Elemental Universe)，是一个化学元素拟人世界观下的小宇宙的故事，目前只有我一个人在做，第一步是搭场景。主场景打算用polyBrush磨出来，其中有一些湖泊和海洋。海洋部分我打算用GerstnerWave的方法来做，湖泊部分采用本文所介绍的方法（当然，还有很多可以改进的地方。有改进的部分会在“更新说明”里提及）。
废话交代完了，现在正式开始吧：
首先，准备一个细分好的平面（因为我们需要一定数量的顶点）作为水面。在这个项目中我使用的是：

演示模型来自Sketchfab，使用遵守CC版权协议。如下预览所示，模型原本的水面只是一块普通的、smooth值几乎设置为1的水平面：
     Little Pond & fish  by  Kenny Kwok.  on Sketchfab

波浪波浪的基本原理是顶点动画，通过修改水面顶点y值(高度)实现，这也是为什么前文提到我们需要一块顶点数比较多的面，越多的顶点意味着越高的波浪精细程度。
我们现在希望的事情是：水面能够上下波动形成波浪。对于湖泊这样较为波澜 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2022/05/02/%E8%AF%AD%E8%A8%80/Lua%E5%AE%9E%E7%8E%B0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" title="Lua实现面向对象"><img class="post-bg" src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA1f5eddee1c38fb6231591d40df4d29f2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Lua实现面向对象"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/05/02/%E8%AF%AD%E8%A8%80/Lua%E5%AE%9E%E7%8E%B0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" title="Lua实现面向对象">Lua实现面向对象</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-05-02T03:22:42.000Z" title="发表于 2022-05-02 11:22:42">2022-05-02</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AF%AD%E8%A8%80/">语言</a></span><span class="article-meta tags"><span class="article-meta-separator"> </span><br><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Lua/">Lua</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/">语言基础</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a></span></div><div class="content">最近在实习，接到的第一个任务是用公司的自研引擎制作一款抖音特效《宅家舞蹈秀》并于五一期间上线抖音。目前特效已经上线了，不过数据不是很好看，希望之后能被推起来吧orz。
说到自研引擎，给我的感觉和 Unity 一类的游戏引擎很像，只不过有些功能开发的不是很成熟（或者说健全），会有一些偶发的诡异的bug（例如粒子播放失败）。虽然存在些许问题，但这款引擎的功能足够满足抖音小游戏/抖音特效这样轻量级的开发了。

自研引擎所使用的编程语言是Lua。Lua是一个灵活且轻量的脚本语言，在实际的游戏开发工作流中，可以用它结合xLua框架来实现游戏的热更新，也可以直接用Lua开发游戏（特别是一些早期的小游戏）。Lua本身并没有提供面向对象的特性，当游戏系统变得复杂时我们该怎么办呢？
在现代游戏编程中，我们会采用具有面向对象特性的语言（例如Java、C#、C++）来开发游戏。面向对象有三个特性，分别是：

封装：就是把对象的属性和行为（数据）结合为一个独立的整体，并尽可能隐藏对象的内部实现细节
继承：从已有的类中派生出新的类称为子类，子类继承父类的数据属性和行为，并能根据自己的需求扩展出新的行为，可以提高 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2022/02/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E8%B4%B4%E5%9C%B0%E9%9B%BE%E6%95%88%E5%AE%9E%E7%8E%B0/" title="贴地雾效实现"><img class="post-bg" src="/2022/02/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E8%B4%B4%E5%9C%B0%E9%9B%BE%E6%95%88%E5%AE%9E%E7%8E%B0/20220207004948.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="贴地雾效实现"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/02/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E8%B4%B4%E5%9C%B0%E9%9B%BE%E6%95%88%E5%AE%9E%E7%8E%B0/" title="贴地雾效实现">贴地雾效实现</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-02-07T08:20:39.263Z" title="发表于 2022-02-07 16:20:39">2022-02-07</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/">效果实现</a></span><span class="article-meta tags"><span class="article-meta-separator"> </span><br><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Unity/">Unity</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/demo/">demo</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/ShaderLab/">ShaderLab</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/shader/">shader</a></span></div><div class="content">&emsp;&emsp;接上篇文章画的饼，这回我打算试着实现一下雾效，我们最终的目标就是实现类似下图的效果。当然，纪念碑谷中的不怎么被雾影响的方块和浸泡在雾气中的方块使用的应该是两种shader，他们不会混在一起。但如果我们要实现的是一个可以移动的场景呢？使用我想在纪念碑谷的静态贴地雾效上加点东西，即：当摄像机移动时，雾的范围会随着摄像机的移动而移动，始终做到远处模糊、近处清晰的效果。

思路其实我们实现纪念碑谷中的这种雾效的思路和全局渐变非常类似。总结一下，主要有以下两点需求：

离摄像机越远，雾气越浓，具体表现在物体整体与雾气的颜色相融
离摄像机越近，雾气越轻，具体表现在雾气很浅，几乎消失

&emsp;&emsp;即，离相机较远的物体如下左所示；离相机较近的物体如下右所示：
 
&emsp;&emsp;我们可以调整地平线（渐变中心位置）的值来实现这个效果。当一个物体离摄像机较近时，它的渐变中心也较低；反之则较高。
实现变量我们需要这么几个变量：

渐变纹理
主色调
雾的颜色
雾的浓度

12345678Properties&#123;    _RampTex(&quot;渐变纹理 ...</div></div></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fas fa-chevron-left fa-fw"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/#content-inner">3</a><a class="page-number" href="/page/4/#content-inner">4</a><a class="extend next" rel="next" href="/page/3/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">时光</div><div class="author-info__description">时间的旅者，无痕的过客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">65</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">116</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Guiny-Time"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Guiny-Time" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:guinytime@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎光临时光的博客！有关于本博客的详细信息请见<b>“关于”</b>。<br>本博客的访问方式：<a target="_blank" rel="noopener" href="https://cattyhouse-guiny.xyz/">https://cattyhouse-guiny.xyz/</a> <br><a target="_blank" rel="noopener" href="https://guiny-time.github.io/">https://guiny-time.github.io/</a></div></div><div class="sticky_layout"><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/VR%E5%BC%80%E5%8F%91/"><span class="card-category-list-name">VR开发</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"><span class="card-category-list-name">年终总结</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E5%BC%95%E6%93%8E%E5%8A%9F%E8%83%BD/"><span class="card-category-list-name">引擎功能</span><span class="card-category-list-count">15</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%8E%A2%E7%B4%A2%E5%8F%91%E7%8E%B0/"><span class="card-category-list-name">探索发现</span><span class="card-category-list-count">5</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/"><span class="card-category-list-name">效果实现</span><span class="card-category-list-count">6</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5/"><span class="card-category-list-name">网络同步</span><span class="card-category-list-count">5</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"><span class="card-category-list-name">计算机图形学</span><span class="card-category-list-count">6</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="card-category-list-name">设计模式</span><span class="card-category-list-count">7</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E8%AF%AD%E8%A8%80/"><span class="card-category-list-name">语言</span><span class="card-category-list-count">7</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/"><span class="card-category-list-name">项目复盘</span><span class="card-category-list-count">10</span></a></li>
            </ul></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="fas fa-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/"><span class="card-archive-list-date">一月 2025</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/"><span class="card-archive-list-date">十二月 2024</span><span class="card-archive-list-count">18</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/"><span class="card-archive-list-date">十月 2023</span><span class="card-archive-list-count">17</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/"><span class="card-archive-list-date">九月 2022</span><span class="card-archive-list-count">14</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">65</div></div><div class="webinfo-item"><div class="item-name">本站总字数 :</div><div class="item-count">165.4k</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2025-02-24T13:19:00.962Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><script type="text/javascript" src="//rf.revolvermaps.com/0/0/2.js?i=5znsjgfcazv&amp;m=1&amp;s=130&amp;c=ff0000&amp;t=1" async="async"></script></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By 时光</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="translateLink" type="button" title="简繁转换">2</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>window.typedJSFn = {
  init: (str) => {
    window.typed = new Typed('#subtitle', Object.assign({
      strings: str,
      startDelay: 300,
      typeSpeed: 150,
      loop: true,
      backSpeed: 50,
    }, null))
  },
  run: (subtitleType) => {
    if (false) {
      if (typeof Typed === 'function') {
        subtitleType()
      } else {
        getScript('https://cdn.jsdelivr.net/npm/typed.js/dist/typed.umd.min.js').then(subtitleType)
      }
    } else {
      subtitleType()
    }
  }
}
</script><script>function subtitleType () {
  if (false) {
    typedJSFn.init(["时间的旅者，无痕的过客"])
  } else {
    document.getElementById("subtitle").textContent = '时间的旅者，无痕的过客'
  }
}
typedJSFn.run(subtitleType)</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'forest'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    btf.addModeChange('mermaid', () => {
      window.runMermaid()
    })

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script><script defer data-pjax src="https://gcore.jsdelivr.net/gh/xiabo2/CDN@latest/fishes.js"></script><script src="/js/universe.js"></script><div class="aplayer no-destroy" data-id="7263032154" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false" data-lrcType="-1"> </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>