<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2021/6/22~2021/6/27涩图精选</title>
      <link href="/2021/06/23/%E6%B6%A9%E5%9B%BE%E7%B2%BE%E9%80%892021-6-22-2021-6-27/"/>
      <url>/2021/06/23/%E6%B6%A9%E5%9B%BE%E7%B2%BE%E9%80%892021-6-22-2021-6-27/</url>
      
        <content type="html"><![CDATA[<div class="justified-gallery"><p><img src="https://pixiv.cat/90722077.jpg"><br><img src="https://pixiv.cat/90722496-1.jpg"><br><img src="https://pixiv.cat/90722496-2.jpg"><br><img src="https://pixiv.cat/90723037.jpg"><br><img src="https://pixiv.cat/90720400.jpg"><br><img src="https://pixiv.cat/90735078-1.jpg"><br><img src="https://pixiv.cat/90723314.jpg"><br><img src="https://pixiv.cat/90706174-1.jpg"><br><img src="https://pixiv.cat/90717242-1.jpg"><br><img src="https://pixiv.cat/90744594.jpg"><br><img src="https://pixiv.cat/90743600.jpg"><br><img src="https://pixiv.cat/90764569-1.jpg"><br><img src="https://pixiv.cat/90764569-5.jpg"><br><img src="https://pixiv.cat/90764569-6.jpg"><br><img src="https://pixiv.cat/90744418.jpg"><br><img src="https://pixiv.cat/90745314.jpg"><br><img src="https://pixiv.cat/90773916-2.jpg"><br><img src="https://pixiv.cat/90764367.jpg"><br><img src="https://pixiv.cat/90774580-1.jpg"><br><img src="https://pixiv.cat/90781328.jpg"><br><img src="https://pixiv.cat/90776365.jpg"><br><img src="https://pixiv.cat/90762508.jpg"><br><img src="https://pixiv.cat/90758280.jpg"><br><img src="https://pixiv.cat/90748222.jpg"><br><img src="https://pixiv.cat/90777509.jpg"><br><img src="https://pixiv.cat/90776393.jpg"><br><img src="https://pixiv.cat/.jpg"><br><img src="https://pixiv.cat/.jpg"><br><img src="https://pixiv.cat/.jpg"><br><img src="https://pixiv.cat/.jpg"><br><img src="https://pixiv.cat/.jpg"><br><img src="https://pixiv.cat/.jpg"><br><img src="https://pixiv.cat/.jpg"></p>          </div>]]></content>
      
      
      <categories>
          
          <category> 涩图 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>L11-项目管理</title>
      <link href="/2021/06/23/L11-%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
      <url>/2021/06/23/L11-%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="L11-项目管理"><a href="#L11-项目管理" class="headerlink" title="L11-项目管理"></a>L11-项目管理</h1><markdwon>  <details>    <summary><center>目标1：活动网图(Activity Network)</center></summary><p><strong>绘图步骤如下</strong></p><ul><li>制作活动表格</li><li>根据依赖性绘制活动网图</li></ul><h3 id="活动表格"><a href="#活动表格" class="headerlink" title="活动表格"></a>活动表格</h3><p>包含三列，从左往右分别是有序的任务代号(一般是T+数字)、工期(按天数计)、依赖性(需要在哪些任务完成的前提下才能开展这个任务)<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-25-10-29-07.png"></p><h3 id="活动网图"><a href="#活动网图" class="headerlink" title="活动网图"></a>活动网图</h3><p>你可以按照表格的顺序来画，之后再调整节点的位置使之更美观</p><ul><li>当一个节点不依赖任何节点时，它与Start节点直接相连</li><li>当一个节点依赖一个或多个节点时，它与所有依赖的节点相连</li></ul><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-25-10-31-37.png"></p><center>不依赖任何节点的节点</center><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-25-10-33-18.png"></p><center>依赖一个节点(上)与依赖两个节点(下)的节点</center><h3 id="我们可以用活动网图做什么？"><a href="#我们可以用活动网图做什么？" class="headerlink" title="我们可以用活动网图做什么？"></a>我们可以用活动网图做什么？</h3><p>我们可以用活动网图来找到**关键路径(Critical Path)**，即网图中最长的一条路径<br>关键路径不能存在延迟，一旦关键路径发生咕咕事件，整个项目的开发时间将会随之延长</p>  </details><markdwon>  <details>    <summary><center>目标2：活动时间线(Activity Timeline/ Bar Chart)</center></summary>![](https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-25-10-40-21.png)    挺顾名思义的，就是在能够反映时间的表格上将每个任务占用的时间、什么时候开始、什么时候结束表示在图上  </details><markdwon>  <details>    <summary><center>目标3：人员安排图(Staff Allocation)</center></summary><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-25-10-41-53.png"></p><pre><code>斜线表示的是兼任工作，指做了某个任务的一部分，而不是全部  </code></pre><p>还是挺顾名思义的，甚至和活动时间线图有点像，只是加上了表示每个员工的轴<br>人员安排图能直观展现出哪个员工在什么时候干了什么工作</p>  </details><h2 id="软件项目管理原则"><a href="#软件项目管理原则" class="headerlink" title="软件项目管理原则"></a>软件项目管理原则</h2><p>因为<strong>时间</strong>(Time)和<strong>预算</strong>(Budget)存在限制，所以我们需要对项目进行管理。一个项目管理成功的四个标准是：</p><ul><li>及时交付</li><li>成本在预算之内</li><li>满足客户期望</li><li>让整个开发团队开心(这东西最重要)</li></ul><blockquote><p>管理者的工作<br>管理者的工作主要有以下几点：</p><ul><li>写提案</li><li>项目计划</li><li>管理风险</li><li>估计成本</li><li>监控和审查项目</li><li>选择和评估人员</li><li>写报告/做报告</li></ul></blockquote><h3 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h3><p>通过提案来向甲方爸爸赢(pian)取合同。<br>提案主要描述项目目标以及项目将被如何执行，为什么选择我们而不是其他人…等等</p><h3 id="项目计划"><a href="#项目计划" class="headerlink" title="项目计划"></a>项目计划</h3><p>项目计划主要包括：<br>• 定义了可用资源(时间、预算、人员、工具)<br>• 将工作分解为更小的单元，并评估每个小单元的时间和资源需要<br>• 安排流程(时间表、组织员工工作)<br>• 跟踪进度(实时监控开发进度)<br>• 比较实际与计划的进度/支出(当出大问题的时候，需要重新规划项目路线)<br>• 减小任务间的依赖性<br>进度、成本和风险必须在项目中修改，项目计划通常集中于开发过程</p><h4 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h4><blockquote><p>活动(Activities)<br>活动指的是一个项目应该产生切实的产出，它允许项目经理评估进程<br>里程碑(Milestones)<br>指进度表上的点，让我们可以评估进展;<br>每个流程活动的终点，如下图所示<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-25-10-21-03.png"><br>可交付成果(Deliverables)<br>交付给客户的项目结果，例如安全报告。<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-25-10-17-57.png"></p></blockquote><h4 id="项目计划的难度"><a href="#项目计划的难度" class="headerlink" title="项目计划的难度"></a>项目计划的难度</h4><p>•评估很困难!<br>•生产率与员工数量不成比例<br>•将人添加到项目中会让它延迟(存在沟通问题)<br>•意外总是会发生的(墨菲定律！！)<br>•计划时要考虑到意外情况</p><h3 id="风险管理"><a href="#风险管理" class="headerlink" title="风险管理"></a>风险管理</h3><h4 id="什么是风险管理"><a href="#什么是风险管理" class="headerlink" title="什么是风险管理"></a>什么是风险管理</h4><ul><li>确定潜在风险、指定减小风险造成的负面影响的计划</li><li>风险是某些不利情况发生的可能性<blockquote><ul><li>项目风险(Project Risk)<br>影响项目进度和资源，如有同事离职，难以替代</li><li>产品风险(Product Risks)<br>影响正在开发的软件的质量或性能，例如，购买的组件不能按预期工作</li><li>商务风险(Business Risks)<br>影响生产软件的组织，例如竞争对手引入类似软件</li></ul></blockquote></li></ul><p>风险是可重叠的（大悲</p><h4 id="如何进行风险管理"><a href="#如何进行风险管理" class="headerlink" title="如何进行风险管理"></a>如何进行风险管理</h4><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-25-10-59-30.png"></p><ul><li><p>风险确认<br>确认项目/产品/商务风险</p></li><li><p>风险分析评估<br>评估风险的可能性和后果</p></li><li><p>风险计划<br>制定规避风险或最小化风险影响的计划</p><blockquote><p>制定风险管理策略<br>可能的策略:</p><ul><li>规避<br>避免风险发生的可能</li><li>最小化<br>降低风险的影响</li><li>突发计划<br>为最坏的情况做准备，并制定相应的策略(以防万一)</li></ul></blockquote></li><li><p>风险监测<br>定期检查风险，并制定降低风险和修订风险的计划</p></li></ul><h4 id="更多风险类型"><a href="#更多风险类型" class="headerlink" title="更多风险类型"></a>更多风险类型</h4><ul><li>技术风险<br>来自用于开发的软件、硬件上的风险</li><li>人员风险<br>与开发团队有关的风险</li><li>组织风险<br>来自项目/产品的组织环境的风险</li><li>工具风险<br>与用于开发系统的支持工具/软件相关的风险</li><li>需求风险<br>因客户需求变更而产生的风险</li><li>评估风险<br>对资源的错误估计带来的风险</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好的项目管理将带领项目走向成功<br>项目管理很难，因为软件是很抽象的<br>项目经理所有的估计和进度<br>计划和评估是迭代和连续的<br>里程碑是可预测的状态，其中产生了进度报告<br>项目计划包括制作展示活动、持续时间和人员配备的图形演示<br>风险管理识别风险并制定计划以控制风险</p></markdwon></markdwon></markdwon>]]></content>
      
      
      <categories>
          
          <category> 软件工程与软件过程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021/6/16~2021/6/21涩图精选</title>
      <link href="/2021/06/16/2021-6-16-2021-6-21%E6%B6%A9%E5%9B%BE%E7%B2%BE%E9%80%89/"/>
      <url>/2021/06/16/2021-6-16-2021-6-21%E6%B6%A9%E5%9B%BE%E7%B2%BE%E9%80%89/</url>
      
        <content type="html"><![CDATA[<div class="justified-gallery"><p><img src="https://pixiv.cat/90572331.jpg"><br><img src="https://pixiv.cat/90572417.jpg"><br><img src="https://pixiv.cat/90560804.jpg"><br><img src="https://pixiv.cat/90573029.jpg"><br><img src="https://pixiv.cat/90554488.jpg"><br><img src="https://pixiv.cat/90540403.jpg"><br><img src="https://pixiv.cat/90570547.jpg"><br><img src="https://pixiv.cat/90574125.jpg"><br><img src="https://pixiv.cat/90539913.jpg"><br><img src="https://pixiv.cat/90570532.jpg"><br><img src="https://pixiv.cat/90572919.jpg"><br><img src="https://pixiv.cat/90568354.jpg"><br><img src="https://pixiv.cat/90563359.jpg"><br><img src="https://pixiv.cat/90555862.jpg"><br><img src="https://pixiv.cat/90568079.jpg"><br><img src="https://pixiv.cat/90577000.jpg"><br><img src="https://pixiv.cat/90579376-2.jpg"><br><img src="https://pixiv.cat/90565427-1.jpg"><br><img src="https://pixiv.cat/90565427-3.jpg"><br><img src="https://pixiv.cat/90565427-4.jpg"><br><img src="https://pixiv.cat/90565427-15.jpg"><br><img src="https://pixiv.cat/90564100-3.jpg"><br><img src="https://pixiv.cat/90564100-10.jpg"><br><img src="https://pixiv.cat/90564100-12.jpg"><br><img src="https://pixiv.cat/90564100-18.jpg"><br><img src="https://pixiv.cat/90564100-30.jpg"><br><img src="https://pixiv.cat/90564100-31.jpg"><br><img src="https://pixiv.cat/90603692-5.jpg"><br><img src="https://pixiv.cat/90581839.jpg"><br><img src="https://pixiv.cat/90604060.jpg"><br><img src="https://pixiv.cat/90586736.jpg"><br><img src="https://pixiv.cat/90604070.jpg"><br><img src="https://pixiv.cat/90603764.jpg"><br><img src="https://pixiv.cat/90603920.jpg"><br><img src="https://pixiv.cat/90603074.jpg"><br><img src="https://pixiv.cat/90621846.jpg"><br><img src="https://pixiv.cat/90620174.jpg"><br><img src="https://pixiv.cat/90637238-2.jpg"><br><img src="https://pixiv.cat/90631073.jpg"><br><img src="https://pixiv.cat/90635284.jpg"><br><img src="https://pixiv.cat/90630182.jpg"><br><img src="https://pixiv.cat/90625250.jpg"><br><img src="https://pixiv.cat/90623902-1.jpg"><br><img src="https://pixiv.cat/90616435.jpg"><br><img src="https://pixiv.cat/90608386.jpg"><br><img src="https://pixiv.cat/90622904-1.jpg"><br><img src="https://pixiv.cat/90622904-2.jpg"><br><img src="https://pixiv.cat/90622904-3.jpg"><br><img src="https://pixiv.cat/90622904-4.jpg"><br><img src="https://pixiv.cat/90622904-5.jpg"><br><img src="https://pixiv.cat/90623860-1.jpg"><br><img src="https://pixiv.cat/90623860-2.jpg"><br><img src="https://pixiv.cat/90603005.jpg"><br><img src="https://pixiv.cat/90625415.jpg"><br><img src="https://pixiv.cat/90663217.jpg"><br><img src="https://pixiv.cat/90662892.jpg"><br><img src="https://pixiv.cat/90647268-1.jpg"><br><img src="https://pixiv.cat/90634700.jpg"><br><img src="https://pixiv.cat/90647771.jpg"><br><img src="https://pixiv.cat/90648189.jpg"><br><img src="https://pixiv.cat/90656844.jpg"><br><img src="https://pixiv.cat/90700083-1.jpg"><br><img src="https://pixiv.cat/90670244.jpg"><br><img src="https://pixiv.cat/90690039.jpg"><br><img src="https://pixiv.cat/90696501.jpg"><br><img src="https://pixiv.cat/90691661.jpg"><br><img src="https://pixiv.cat/90697625.jpg"><br><img src="https://pixiv.cat/90699081-1.jpg"><br><img src="https://pixiv.cat/90703588.jpg"><br><img src="https://pixiv.cat/90699068.jpg"><br><img src="https://pixiv.cat/90718201.jpg"><br><img src="https://pixiv.cat/90645158.jpg"><br><img src="https://pixiv.cat/90651148.jpg"><br><img src="https://pixiv.cat/90666326.jpg"><br><img src="https://pixiv.cat/90674307.jpg"><br><img src="https://pixiv.cat/90646043-1.jpg"><br><img src="https://pixiv.cat/90646043-2.jpg"><br><img src="https://pixiv.cat/90646043-4.jpg"><br><img src="https://pixiv.cat/90646043-5.jpg"><br><img src="https://pixiv.cat/90646043-13.jpg"><br><img src="https://pixiv.cat/90646043-17.jpg"><br><img src="https://pixiv.cat/90646043-18.jpg"><br><img src="https://pixiv.cat/90674668-1.jpg"><br><img src="https://pixiv.cat/90674668-2.jpg"><br><img src="https://pixiv.cat/90680263.jpg"><br><img src="https://pixiv.cat/90670677.jpg"><br><img src="https://pixiv.cat/90670271.jpg"></p>          </div>]]></content>
      
      
      <categories>
          
          <category> 涩图 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>L10-软件测试</title>
      <link href="/2021/06/14/L10-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
      <url>/2021/06/14/L10-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="L10-软件测试"><a href="#L10-软件测试" class="headerlink" title="L10-软件测试"></a>L10-软件测试</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="什么是软件测试"><a href="#什么是软件测试" class="headerlink" title="什么是软件测试"></a>什么是软件测试</h3><ul><li><strong>为什么要进行软件测试</strong><blockquote><p>软件测试的目的是<strong>一个程序做它想做的事，并在它投入使用之前发现程序缺陷</strong></p></blockquote></li><li><strong>如何进行软件测试</strong><blockquote><p>当您测试软件时，您<strong>使用人工数据执行程序</strong></p></blockquote></li><li><strong>通过软件测试，我们可以获得什么?</strong><blockquote><p>您可以检查测试运行的结果，以查找有关程序<strong>非功能属性的错误、异常或信息</strong></p></blockquote></li></ul><p>测试是更一般的<strong>软件验证和确认过程的一部分</strong></p><h3 id="软件测试的目标"><a href="#软件测试的目标" class="headerlink" title="软件测试的目标"></a>软件测试的目标</h3><ul><li>向开发人员和客户<strong>演示软件满足其需求</strong><blockquote><ul><li>对于定制软件<br>需求文档中的每个需求都应该至少有一个测试。</li><li>对于通用软件<br>应该对所有的系统特性进行测试，加上这些特性的组合，这些特性将合并到产品发布中</li></ul></blockquote></li><li><strong>发现软件</strong>不正确、不受欢迎的行为或不符合其规范<strong>的糟糕情况</strong><blockquote><p>缺陷测试关注的是根除不需要的系统行为，比如系统崩溃、与其他系统的不需要的交互、不正确的计算和数据损坏</p></blockquote></li></ul><h3 id="测试过程的目标"><a href="#测试过程的目标" class="headerlink" title="测试过程的目标"></a>测试过程的目标</h3><h4 id="验证测试-Validation-Testing"><a href="#验证测试-Validation-Testing" class="headerlink" title="验证测试(Validation Testing)"></a>验证测试(Validation Testing)</h4><ul><li>向开发人员和系统客户演示该软件满足其需求</li><li><strong>成功的测试表明该系统按预期运行</strong><h4 id="缺陷测试-Defect-Testing"><a href="#缺陷测试-Defect-Testing" class="headerlink" title="缺陷测试(Defect Testing)"></a>缺陷测试(Defect Testing)</h4></li><li>在软件的行为不正确或不符合其规范的地方<strong>发现错误或缺陷</strong></li><li><strong>成功的测试是使系统执行不正确</strong>，从而暴露系统中的缺陷的测试</li></ul><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-14-20-40-54.png" alt="程序测试中的输入-输出模型"></p><h3 id="验证与确认"><a href="#验证与确认" class="headerlink" title="验证与确认"></a>验证与确认</h3><h4 id="验证-Verification"><a href="#验证-Verification" class="headerlink" title="验证(Verification)"></a>验证(Verification)</h4><ul><li>关注“我们构建的产品是正确的吗?”的问题<blockquote><p>Are we building the product right?</p></blockquote></li><li>软件应符合其规格说明<h4 id="确认-Validation"><a href="#确认-Validation" class="headerlink" title="确认(Validation)"></a>确认(Validation)</h4></li><li>关注“我们是否构建了正确的产品?”的问题<blockquote><p>“Are we building the right product?”</p></blockquote></li><li>软件应该做用户真正需要的</li></ul><p>经过这两个测试(V &amp; V过程)，建立起对系统“符合目的”的信心</p><h3 id="检测与测试"><a href="#检测与测试" class="headerlink" title="检测与测试"></a>检测与测试</h3><h4 id="软件检查-Software-Inspections"><a href="#软件检查-Software-Inspections" class="headerlink" title="软件检查(Software Inspections)"></a>软件检查(Software Inspections)</h4><ul><li>对静态系统表示进行分析以发现问题**(静态验证)**</li><li>可以通过基于工具的文档和代码分析进行补充<h4 id="软件测试-Software-Testing"><a href="#软件测试-Software-Testing" class="headerlink" title="软件测试(Software Testing)"></a>软件测试(Software Testing)</h4></li><li>有关实践和观察产品行为**(动态验证)**</li><li>系统使用测试数据执行，并观察其操作行为<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4>检查和测试是互补的，而不是对立的验证技术<br>二者都应该在V &amp; V过程中使用</li><li>软件检查可以检查是否符合规格，但不符合客户的实际要求</li><li>软件检查不能检查非功能特征，如性能、可用性等</li></ul><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-14-20-41-38.png" alt="软件测试流程模型"></p><h3 id="测试的阶段"><a href="#测试的阶段" class="headerlink" title="测试的阶段"></a>测试的阶段</h3><ul><li>开发测试<br>在开发过程中测试系统以发现bug和缺陷</li><li>发布测试<br>由单独的测试团队在系统发布给用户之前测试系统的完整版本</li><li>用户测试<br>系统的用户或潜在用户在他们自己的环境中测试系统</li></ul><h2 id="测试-Testing-与捉虫-Debugging"><a href="#测试-Testing-与捉虫-Debugging" class="headerlink" title="测试(Testing)与捉虫(Debugging)"></a>测试(Testing)与捉虫(Debugging)</h2><p>缺陷测试和捉虫是不同的过程: </p><blockquote><p>缺陷测试涉及到确认错误的存在</p><ul><li>比较输入和输出</li><li>程序为什么不工作(废话因为有bug啊————</li><li>我要怎么打破我的程序(你需要一把锤子</li></ul><p>捉虫涉及到定位和修复这些错误</p><ul><li>研究是什么东西导致了错误发生</li><li>为什么代码不工作</li><li>我要如何修复我的程序</li><li>目标是搞出一个没有bug的美好程序</li><li>有系统地寻找bug</li></ul></blockquote><p>捉虫涉及到制定一个关于程序行为的假设，然后测试这些假设以找到系统错误</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h4 id="进行测试之前…"><a href="#进行测试之前…" class="headerlink" title="进行测试之前…"></a>进行测试之前…</h4><p>首先你需要确定你的代码能够运行，它不是意大利面怪</p><ul><li>不要有奇奇怪怪的语法错误</li><li>不要有奇奇怪怪的静态语义错误<br>其次你需要有一组预期的测试结果</li><li>一组输入</li><li>对输入组中的每个输入，都有一个对应的预期输出</li></ul><h3 id="捉虫"><a href="#捉虫" class="headerlink" title="捉虫"></a>捉虫</h3><h4 id="捉虫之道"><a href="#捉虫之道" class="headerlink" title="捉虫之道"></a>捉虫之道</h4><p>以下方法都可以通过调试工具(如调试编译器、动态调试辅助)加以补充</p><ul><li>暴力破解代码，直到bug被发现</li><li>回溯<br>比较适合小程序，回到没bug的上一版本，并进行对比</li><li>原因消除<br>假设是什么导致的错误，并输入测试数据来检查</li></ul><h4 id="捉虫时可能遇到的问题"><a href="#捉虫时可能遇到的问题" class="headerlink" title="捉虫时可能遇到的问题"></a>捉虫时可能遇到的问题</h4><ul><li>观察到的bug及其原因可能在地理上是分开的</li><li>观察到的bug可能随着另一个问题的修复而消失</li><li>bug的原因可能是难以追踪的人为错误</li><li>bug的原因可能是每个人都相信的假设</li><li>观察到的bug可能是间歇性的，因为系统或编译错误</li></ul><h4 id="debug有的时候要人命"><a href="#debug有的时候要人命" class="headerlink" title="debug有的时候要人命"></a>debug有的时候要人命</h4><ul><li>重新考虑假设<br>操作系统改变了吗?硬盘满了吗?这是闰年吗?</li><li>开始为您的系统编制文档<blockquote><p>提供一个全新的角度，并突出显示困惑的地方<br>确保注释和规范描述了代码</p></blockquote></li><li>寻求外界的帮助<br>个人的能力是有限的，我们每个人都会有盲点</li></ul><h3 id="我们需要做什么、不需要做什么？"><a href="#我们需要做什么、不需要做什么？" class="headerlink" title="我们需要做什么、不需要做什么？"></a>我们需要做什么、不需要做什么？</h3><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-14-21-13-24.png"></p><h2 id="软件质量"><a href="#软件质量" class="headerlink" title="软件质量"></a>软件质量</h2><p>软件开发伴随着风险。现代软件通常十分复杂，伴随着几千行的代码。用户需求可能十分模糊，此外ddl和预算也很搞开发团队心态。诸多因素可能导致软件质量下降，这对开发团队、公司名誉的损害是巨大的</p><h3 id="如何评价软件质量"><a href="#如何评价软件质量" class="headerlink" title="如何评价软件质量"></a>如何评价软件质量</h3><p>根据ISO91261软件工程标准，衡量一个软件的质量主要从以下六个方面入手：<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-14-21-17-51.png"></p><p>即：</p><ul><li>功能性<br>适用性、准确性、互操作性、合规性、安全性</li><li>可靠性<br>成熟、容错、可恢复性</li><li>可用性<br>易懂、易学性、可操作性</li><li>效率<br>时间行为，资源行为</li><li>可维护性<br>可分析性，易变性，稳定性，可测试性</li><li>可移植性<br>适应性，可安装性，一致性，可更换性</li></ul><h3 id="反映软件质量糟糕的一面"><a href="#反映软件质量糟糕的一面" class="headerlink" title="反映软件质量糟糕的一面"></a>反映软件质量糟糕的一面</h3><p>主要有三个要素：错误、故障和失败</p><ul><li><p>错误(Error)</p><blockquote><p>错误指的是软件开发人员所犯的错误。它们<strong>存在于程序员的头脑中</strong>，并可能导致软件中的一个或多个错误</p></blockquote></li><li><p>故障(Fault)</p><blockquote><p>故障<strong>由源代码中的错误代码组成</strong>，可能是一个或多个错误的产物。错误可能导致程序执行过程中的失败<br>故障类型</p><ul><li>算法类故障(占将近50%)<blockquote><p>算法故障是指当软件的某个单元在指定的算法下不能产生对应于给定输入的输出时发生的故障</p></blockquote></li><li>语法类故障</li><li>文档类故障</li><li>应力或过载类故障</li><li>容量和边界类故障</li><li>计算和精度类故障(占将近50%)<blockquote><p>当使用所选公式计算的结果不符合预期的精度或精度时，计算和精度故障就会发生</p></blockquote></li><li>吞吐量或性能类故障</li><li>恢复类故障</li><li>定时或协调类故障</li><li>标准和步骤类故障</li></ul></blockquote></li><li><p>失败(Failure)</p><blockquote><p>失败是<strong>故障的症状</strong>，由软件的不正确或不规范行为组成。错误可能一直隐藏着，直到满足了一组特定的条件，这些条件表明它们是软件执行中的一个失败<br>几种级别的失败如下：</p><ul><li><strong>导致系统崩溃</strong>，恢复时间很长;或者故障会导致功能和数据的丢失，没有任何变通方法</li><li><strong>导致功能或数据的丢失</strong>，但是有手动的变通方法来临时完成这些任务</li><li><strong>导致部分功能或数据丢失</strong>，用户可以用少量变通方法完成大部分任务</li><li><strong>导致表面上和轻微的不便</strong>，所有用户任务仍然可以完成</li></ul></blockquote></li></ul><h4 id="从故障到失败"><a href="#从故障到失败" class="headerlink" title="从故障到失败"></a>从故障到失败</h4><p>首先，程序员在敲代码的时候写错了什么东西，导致了故障产生(Fault)<br>当程序执行，故障开始传染<br>之后，传染进一步升级，并影响到程序本身<br>最后，传染造成了失败。不过需要注意的是，<strong>并不是每个传染最终都会造成失败，也不是每个故障都会产生传染</strong><br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-14-21-28-02.png"></p><h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><p><strong>测试理论的目标</strong><br>确定理想的测试——也就是说，确保软件在所有输入下都能工作所需的最小测试数据</p><h3 id="几种测试"><a href="#几种测试" class="headerlink" title="几种测试"></a>几种测试</h3><h4 id="单元测试-Unit-Testing"><a href="#单元测试-Unit-Testing" class="headerlink" title="单元测试(Unit Testing)"></a>单元测试(Unit Testing)</h4><ul><li>对软件的单个单元进行测试，以确保其正确工作。这可以是单个组件，也可以是复合组件</li><li>组件可以是方法、类或子系统。它可以是单个GUI组件(如按钮)或它们的集合(如窗口)</li><li>这利用了该单元的编程接口</li></ul><h4 id="集成测试-Integration-Testing"><a href="#集成测试-Integration-Testing" class="headerlink" title="集成测试(Integration Testing)"></a>集成测试(Integration Testing)</h4><ul><li>测试两个或更多单元，以确保它们正确地互操作</li><li>这可以使用编程接口或系统接口</li><li>是自顶向下，自底向上，还是采用“端到端用户功能”的方法(这啥玩意</li></ul><h4 id="系统测试-System-Testing"><a href="#系统测试-System-Testing" class="headerlink" title="系统测试(System Testing)"></a>系统测试(System Testing)</h4><ul><li>对整个软件系统进行测试，以确保它正确工作，满足/解决用户的需求/问题</li><li>本系统使用的系统界面可以是GUI、网络界面、web界面等…</li></ul><h4 id="收敛测试-Acceptance-Testing"><a href="#收敛测试-Acceptance-Testing" class="headerlink" title="收敛测试(Acceptance Testing)"></a>收敛测试(Acceptance Testing)</h4><ul><li>对整个软件系统进行测试，以确保其<strong>满足用户需求</strong></li><li>同样，这使用了系统接口</li></ul><h5 id="上述几种测试的直观联系"><a href="#上述几种测试的直观联系" class="headerlink" title="上述几种测试的直观联系"></a>上述几种测试的直观联系</h5><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-14-21-43-06.png"></p><h4 id="回归测试-Regression-Testing"><a href="#回归测试-Regression-Testing" class="headerlink" title="回归测试(Regression Testing)"></a>回归测试(Regression Testing)</h4><ul><li>在软件经历变更后确认或否认软件的功能</li><li>在发现并纠正bug时进行新的回归测试</li><li>确保您不会重新引入以前已修复的错误<blockquote><ul><li>保持严格的定期测试时间表</li><li>使用测试管理软件</li><li>对测试进行分类，以便理解</li><li>根据需要，例如客户的需求，确定测试的优先级</li></ul></blockquote></li></ul><h4 id="穷举调试-Exhaustive-Testing"><a href="#穷举调试-Exhaustive-Testing" class="headerlink" title="穷举调试(Exhaustive Testing)"></a>穷举调试(Exhaustive Testing)</h4><ul><li>这通常是不可行的，因为这将花费太长时间或需要太多内存空间</li><li>一个好的测试应该有很高的发现错误的可能性，而不是重复另一个测试，在测量什么方面是独立的，这样错误就不会相互隐藏，并且尽可能多地测试代码</li></ul><h3 id="黑盒测试与白盒测试"><a href="#黑盒测试与白盒测试" class="headerlink" title="黑盒测试与白盒测试"></a>黑盒测试与白盒测试</h3><h4 id="黑盒测试-功能测试"><a href="#黑盒测试-功能测试" class="headerlink" title="黑盒测试(功能测试)"></a>黑盒测试(功能测试)</h4><p>生成执行规范的输入值，并将实际输出与预期输出进行比较。我们不知道测试过程中代码内部发生了什么，只关注输入与输出</p><blockquote><p>完全基于程序规范，目的是<strong>验证程序满足规定的要求</strong><br>黑盒测试<strong>不会发现与额外功能相关的故障</strong>。这些都是遗漏的错误<br>黑盒测试提供了规范的覆盖率，但<strong>没有提供实现的全部覆盖率</strong>。也就是说，实现中的代码可能产生规范中没有说明的结果</p></blockquote><ol><li>根据规格进行测试。</li><li>使用基于规格说明的测试覆盖率标准。</li><li>开发来自规范的测试用例。</li><li>“锻炼”的规范。</li></ol><h5 id="包括"><a href="#包括" class="headerlink" title="包括"></a>包括</h5><ul><li>等价类测试<br>将输入数据划分出几个等价区域，并在每个区域中测试一个值</li><li>边界值测试<br>测试边界值</li><li>组合测试<br>测试输入数值的组合</li><li>随机测试<br>选取随机数进行测试<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-14-21-59-29.png"></li></ul><h4 id="白盒测试-结构测试"><a href="#白盒测试-结构测试" class="headerlink" title="白盒测试(结构测试)"></a>白盒测试(结构测试)</h4><p>生成执行实现的输入值，并将实际输出与预期输出进行比较。我们知道测试过程中每条代码上发生了什么，测试是根据代码的结构进行设计的</p><blockquote><p>使用软件的实现来派生测试。这些测试的目的是<strong>测试程序代码的某些方面</strong><br>白盒测试<strong>不会发现与缺失功能相关的故障</strong>。这些都是遗漏的错误<br>白盒测试<strong>提供了实现的覆盖率</strong>，而不是规范的覆盖率。也就是说，可能在规范中声明的行为在实现中没有代码</p></blockquote><ol><li>对实现进行测试</li><li>使用基于实现的测试覆盖标准</li><li>开发来自实现的测试用例。</li><li>“锻炼”的实现<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-14-22-02-28.png"></li></ol><h4 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h4><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-14-21-56-03.png"></p><h3 id="是不是应该结束测试了？"><a href="#是不是应该结束测试了？" class="headerlink" title="是不是应该结束测试了？"></a>是不是应该结束测试了？</h3><p>当满足以下三种情况的时候，我们可以考虑结束软件测试：</p><ul><li>预算角度：分配的时间或预算已过期</li><li>活动角度：软件通过了所有计划的测试</li><li>风险管理角度：预测的故障率满足某些质量标准</li></ul><h3 id="静态验证与动态检验"><a href="#静态验证与动态检验" class="headerlink" title="静态验证与动态检验"></a>静态验证与动态检验</h3><p>言简意骇一句话：静态验证不需要执行软件代码，而动态验证需要执行</p><h4 id="静态检验-Static-Verification"><a href="#静态检验-Static-Verification" class="headerlink" title="静态检验(Static Verification)"></a>静态检验(Static Verification)</h4><ul><li>静态验证(或静态分析)可以非常简单，就像让受过培训的人阅读代码并有经验来查找错误一样</li><li>它还可以采用一种数学方法，包括程序的符号执行</li><li>最后，它可以是一种正式的方法，包括规范和源代码之间转换的符号验证</li></ul><h4 id="动态检验-Dynamic-Verification"><a href="#动态检验-Dynamic-Verification" class="headerlink" title="动态检验(Dynamic Verification)"></a>动态检验(Dynamic Verification)</h4><ul><li>动态验证(或软件测试)通过执行程序来确认程序的运行</li><li>创建的测试用例指导选择合适的测试数据(由输入值和期望输出值组成)</li><li>输入值在执行期间作为程序的输入提供</li><li>从程序中收集实际输出，然后将它们与预期输出进行比较<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-14-21-55-14.png"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件工程与软件过程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021/6/10~2021/6/15涩图精选</title>
      <link href="/2021/06/10/6-10-6-15%E6%B6%A9%E5%9B%BE%E7%B2%BE%E9%80%89/"/>
      <url>/2021/06/10/6-10-6-15%E6%B6%A9%E5%9B%BE%E7%B2%BE%E9%80%89/</url>
      
        <content type="html"><![CDATA[<div class="justified-gallery"><p><img src="https://pixiv.cat/90406427-1.jpg"><br><img src="https://pixiv.cat/90406427-2.jpg"><br><img src="https://pixiv.cat/90424630-1.jpg"><br><img src="https://pixiv.cat/90424630-2.jpg"><br><img src="https://pixiv.cat/90424630-3.jpg"><br><img src="https://pixiv.cat/90414948.jpg"><br><img src="https://pixiv.cat/90429021.jpg"><br><img src="https://pixiv.cat/90440259.jpg"><br><img src="https://pixiv.cat/90415143-1.jpg"><br><img src="https://pixiv.cat/90415143-2.jpg"><br><img src="https://pixiv.cat/90415143-3.jpg"><br><img src="https://pixiv.cat/90409224.jpg"><br><img src="https://pixiv.cat/90434103.jpg"><br><img src="https://pixiv.cat/90412043.jpg"><br><img src="https://pixiv.cat/90424078.jpg"><br><img src="https://pixiv.cat/90411438.jpg"><br><img src="https://pixiv.cat/90407932.jpg"><br><img src="https://pixiv.cat/90436497-1.jpg"><br><img src="https://pixiv.cat/90424111.jpg"><br><img src="https://pixiv.cat/90433339.jpg"><br><img src="https://pixiv.cat/90402106.jpg"><br><img src="https://pixiv.cat/90414318.jpg"><br><img src="https://pixiv.cat/90422376-5.jpg"><br><img src="https://pixiv.cat/90422376-15.jpg"><br><img src="https://pixiv.cat/90422376-18.jpg"><br><img src="https://pixiv.cat/90422376-21.jpg"><br><img src="https://pixiv.cat/90402340.jpg"><br><img src="https://pixiv.cat/90446323.jpg"><br><img src="https://pixiv.cat/90454262-1.jpg"><br><img src="https://pixiv.cat/90457194.jpg"><br><img src="https://pixiv.cat/90458238.jpg"><br><img src="https://pixiv.cat/90450957.jpg"><br><img src="https://pixiv.cat/90471251.jpg"><br><img src="https://pixiv.cat/90472900-3.jpg"><br><img src="https://pixiv.cat/90472900-4.jpg"><br><img src="https://pixiv.cat/90472900-5.jpg"><br><img src="https://pixiv.cat/90472900-6.jpg"><br><img src="https://pixiv.cat/90472900-7.jpg"><br><img src="https://pixiv.cat/90472900-8.jpg"><br><img src="https://pixiv.cat/90472900-9.jpg"><br><img src="https://pixiv.cat/90472900-10.jpg"><br><img src="https://pixiv.cat/90479678.jpg"><br><img src="https://pixiv.cat/90445498-1.jpg"><br><img src="https://pixiv.cat/90479941.jpg"><br><img src="https://pixiv.cat/90495379.jpg"><br><img src="https://pixiv.cat/90465943-2.jpg"><br><img src="https://pixiv.cat/90489736.jpg"><br><img src="https://pixiv.cat/90486349.jpg"><br><img src="https://pixiv.cat/90495989.jpg"><br><img src="https://pixiv.cat/90481586.jpg"><br><img src="https://pixiv.cat/90486310.jpg"><br><img src="https://pixiv.cat/90494445-1.jpg"><br><img src="https://pixiv.cat/90494445-2.jpg"><br><img src="https://pixiv.cat/90486086.jpg"><br><img src="https://pixiv.cat/90481742.jpg"><br><img src="https://pixiv.cat/90484341.jpg"><br><img src="https://pixiv.cat/90486424.jpg"><br><img src="https://pixiv.cat/90512359-1.jpg"><br><img src="https://pixiv.cat/90516356.jpg"><br><img src="https://pixiv.cat/90512138.jpg"><br><img src="https://pixiv.cat/90510999.jpg"><br><img src="https://pixiv.cat/90516112.jpg"><br><img src="https://pixiv.cat/90492770.jpg"><br><img src="https://pixiv.cat/90513628.jpg"><br><img src="https://pixiv.cat/90523004.jpg"><br><img src="https://pixiv.cat/90518163.jpg"><br><img src="https://pixiv.cat/90506596.jpg"><br><img src="https://pixiv.cat/90507724.jpg"><br><img src="https://pixiv.cat/90501278.jpg"><br><img src="https://pixiv.cat/90528751.jpg"><br><img src="https://pixiv.cat/90523989.jpg"><br><img src="https://pixiv.cat/90527166.jpg"><br><img src="https://pixiv.cat/90511189.jpg"><br><img src="https://pixiv.cat/90509664.jpg"><br><img src="https://pixiv.cat/90544363.jpg"><br><img src="https://pixiv.cat/90539747.jpg"><br><img src="https://pixiv.cat/90550649-1.jpg"><br><img src="https://pixiv.cat/90529343.jpg"><br><img src="https://pixiv.cat/90528420-1.jpg"><br><img src="https://pixiv.cat/90528420-2.jpg"><br><img src="https://pixiv.cat/90526041-2.jpg"><br><img src="https://pixiv.cat/90526041-3.jpg"><br><img src="https://pixiv.cat/90526041-4.jpg"><br><img src="https://pixiv.cat/90526041-5.jpg"><br><img src="https://pixiv.cat/90548389.jpg"><br><img src="https://pixiv.cat/90528708.jpg"><br><img src="https://pixiv.cat/90550307-1.jpg"><br><img src="https://pixiv.cat/90540389.jpg"></p>          </div>]]></content>
      
      
      <categories>
          
          <category> 涩图 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>L9-UI/UX设计</title>
      <link href="/2021/06/08/L9-UI_UX%E8%AE%BE%E8%AE%A1/"/>
      <url>/2021/06/08/L9-UI_UX%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="L9-UI-UX设计"><a href="#L9-UI-UX设计" class="headerlink" title="L9-UI/UX设计"></a>L9-UI/UX设计</h1><p>这不是专业课知识吗）尚且可还行<br>虽然但是，我专业课也没好好学就是了（主要因为没考试，就水了</p><h2 id="为什么要进行设计？"><a href="#为什么要进行设计？" class="headerlink" title="为什么要进行设计？"></a>为什么要进行设计？</h2><p>设计关注事物如何工作，如何控制它们，以及人与技术之间互动的本质。如果做得好，结果是辉煌的，令人愉快的产品。<br>如果设计的不好，产品就无法使用，可能导致巨大的挫败感和愤怒。或者它们可能有用，但迫使我们按照产品的意愿行事，而不是按照我们的意愿行事</p><blockquote><ul><li>Design is concerned with how things work, how they are controlled, and the nature of the interaction between people and technology. When done well, the results are brilliant, pleasurable products.</li><li>When done badly, the products are unusable, leading to great frustration and irritation. Or they might be useable, but force us to behave the way the product wishes rather than as we wish</li></ul></blockquote><h3 id="设计前应考虑的一些事"><a href="#设计前应考虑的一些事" class="headerlink" title="设计前应考虑的一些事"></a>设计前应考虑的一些事</h3><ol><li>用户是谁？<br>不同的受众群体对UI的偏好可能有所不同</li><li>用户正在进行什么活动，交互发生在哪里(环境)？<br>使用认知走查来寻找潜在的交互问题</li><li>需要优化用户与产品的互动…以便他们匹配用户的活动和需求</li></ol><h2 id="良好的UI设计"><a href="#良好的UI设计" class="headerlink" title="良好的UI设计"></a>良好的UI设计</h2><p>计算机和界面应该功能齐全，易于使用，直观</p><h3 id="UI设计重点"><a href="#UI设计重点" class="headerlink" title="UI设计重点"></a>UI设计重点</h3><p>预测用户可能需要做什么，并确保界面具有易于访问、理解和使用的元素，以促进这些操作。UI汇集了来自交互设计、视觉设计和信息架构的概念<br>UI设计师眼里的用户智商.jpg) 总之你真的永远不知道用户会干什么</p><h3 id="执行鸿沟和评估鸿沟"><a href="#执行鸿沟和评估鸿沟" class="headerlink" title="执行鸿沟和评估鸿沟"></a>执行鸿沟和评估鸿沟</h3><ul><li>执行鸿沟(gulf of execution): 这是用户行动的意图和系统允许他们实现它的容易程度之间的鸿沟。</li><li>评估鸿沟(gulf of evaluation): 这是用户感知和解释他们所执行的行动是否成功的轻松程度。</li></ul><h3 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h3><ul><li>可见性<strong>Visibility</strong><br>用户需要知道所有的选项是什么，并直接知道如何访问它们</li><li>反馈<strong>Feedback</strong><br>每个操作需要一个反射。需要有一些指示，比如声音，移动的刻度盘，旋转的彩虹轮，总之就是用户的行动引起了一些东西的发生</li><li>功能可见性<strong>Affordance</strong><br>可见性是指事物的外观和使用方式之间的关系。对于设计师来说，这意味着一旦有人看到某样东西，他们就必须知道如何使用它</li><li>映射<strong>Mapping</strong><br>映射是控制和效果之间的关系。其理念是，通过优秀的设计，某些内容的控制将与它们所影响的内容非常相似</li></ul><p><strong>垂直滚动条</strong>是映射的一个很好的例子。它告诉你你在页面中的位置，当你向下拖动时，页面以相同的速度向下移动;控制和影响密切相关</p><ul><li>约束<strong>Constraints</strong><br>约束是指对交互或界面的限制。有些是非常明显和物理的，例如手机的屏幕大小</li><li>一致性<strong>Consistency</strong><br>每次同样的动作都会引起同样的反应</li></ul><h3 id="五大原则"><a href="#五大原则" class="headerlink" title="五大原则"></a>五大原则</h3><ul><li>用户熟悉度/用户友好度<br>界面应该基于面向用户的术语和概念，而不是计算机概念。<br>应该从左到右读取并输入数据</li><li>用户引导<br>应提供一些用户指南，如帮助系统、联机手册等</li><li>减少用户的内存负载<br>减少对短期记忆的需求，例如，用视觉线索来回忆过去的行为，而不是用户们必须用脑子去回忆它们<blockquote><p>例如，亚马逊(和许多其他电子商务网站)会向用户展示他们最近访问过的物品列表。这些列表帮助用户记住完成几天前开始的购买</p></blockquote></li><li>建立有意义的默认值<br>身高默认值为160而不是0或者-10086一类的</li><li>可恢复性(容错)<br>系统应该为用户错误提供一些弹性，并允许用户从错误中恢复。这可能包括撤销功能、确认破坏性操作、“软”删除等<br>如命令模式中的撤销支持、Unity删除文件之前的破坏性操作询问、Notable的删除缓冲</li></ul><h3 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h3><p>MVC模式指代<strong>模型-视图-控制器</strong>，其中视图展示在用户面前(也就是UI，用户接口，连接用户和软件)，当用户使用视图的时候，操作通过控制器最终施加在模型上，完成逻辑操作</p><h4 id="请注意！"><a href="#请注意！" class="headerlink" title="请注意！"></a>请注意！</h4><ul><li>用户界面设计在系统架构设计之后</li><li>在客户端为每个组件设计UI(或MVC架构模式中的视图)</li><li>系统用户通常通过界面而不是功能来判断一个系统(毕竟人类都是视觉动物，像我就觉得eclipse界面很丑)</li><li>糟糕的界面会导致用户犯错(误导用户)</li><li>糟糕的界面可能导致软件系统永远不会被使用(你根本不知道它在哪)</li></ul><h2 id="糟糕的UI设计"><a href="#糟糕的UI设计" class="headerlink" title="糟糕的UI设计"></a>糟糕的UI设计</h2><ul><li>缺乏一致性</li><li>没有指导/帮助</li><li>没有上下文敏感性</li><li>不良反应</li><li>不友好<blockquote><ul><li>Lack of consistency</li><li>Too much memorization No guidance / help</li><li>No context sensitivity</li><li>Poor response</li><li>Unfriendly </li></ul></blockquote></li></ul><h2 id="设计流程"><a href="#设计流程" class="headerlink" title="设计流程"></a>设计流程</h2><p>界面分析 -&gt; 界面设计 -&gt; 界面实现 -&gt; 界面验证 -&gt; 界面分析 -&gt; …</p><h3 id="界面分析-Interface-Analysis"><a href="#界面分析-Interface-Analysis" class="headerlink" title="界面分析(Interface Analysis)"></a>界面分析(Interface Analysis)</h3><p>界面分析意味着设计师理解将通过接口与系统交互的人(最终用户)之间的关系<br>•终端用户必须完成的任务<br>•作为界面一部分呈现的内容<br>•执行这些任务的环境</p><h3 id="界面设计-Interface-Design"><a href="#界面设计-Interface-Design" class="headerlink" title="界面设计(Interface Design)"></a>界面设计(Interface Design)</h3><ul><li>使用接口分析过程中开发的信息定义接口对象(GUI组件)和操作</li><li>定义导致用户界面状态改变的事件(用户动作)。模式化这类行为</li><li>描述每个界面状态，因为它将实际看向最终用户。</li><li>指示用户如何从界面提供的信息解释系统的状态。</li></ul><h3 id="界面实现-Interface-Construction"><a href="#界面实现-Interface-Construction" class="headerlink" title="界面实现(Interface Construction)"></a>界面实现(Interface Construction)</h3><ul><li>从一个能够评估使用场景的原型开始</li><li>继续使用开发工具来完成实现</li></ul><h3 id="界面验证-Interface-Design"><a href="#界面验证-Interface-Design" class="headerlink" title="界面验证(Interface Design)"></a>界面验证(Interface Design)</h3><p>验证界面是否满足以下几点：</p><ul><li>界面是否能够正确地实现每个用户任务，适应所有任务变化，并实现所有一般用户需求</li><li>界面是否易于使用和学习</li><li>用户是否接受界面作为他们工作中有用的工具</li></ul><h2 id="具体的设计点"><a href="#具体的设计点" class="headerlink" title="具体的设计点"></a>具体的设计点</h2><h3 id="交互类型"><a href="#交互类型" class="headerlink" title="交互类型"></a>交互类型</h3><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-08-16-33-32.png"><br>直接操作、菜单选择、表单填充、命令行、自然语言各自的优缺点</p><h3 id="信息展示"><a href="#信息展示" class="headerlink" title="信息展示"></a>信息展示</h3><p>需要考虑这么几个点：</p><ul><li>用户是否对精确的信息或数据关系感兴趣?<br>考虑到精度的选择，比如在图像渲染中选择高精度浮点数、中等还是低精度浮点数；选择float还是double</li><li>信息价值的变化有多快?更改必须立即说明吗?<br>实时更新/每十分钟更新数据等等</li><li>用户必须采取一些行动来响应变化吗?</li><li>是否有直接操作界面?</li><li>信息是文本还是数字?相对价值重要吗?</li></ul><h3 id="颜色选用"><a href="#颜色选用" class="headerlink" title="颜色选用"></a>颜色选用</h3><p>颜色为界面增加了额外的维度，可以帮助用户理解复杂的信息结构<br>颜色可以用来突出特殊事件</p><h4 id="颜色的常见错误"><a href="#颜色的常见错误" class="headerlink" title="颜色的常见错误"></a>颜色的常见错误</h4><ul><li>丑陋的颜色(滥用对比色等等)</li><li>表达意义时颜色选择不当(用红色表示正确、绿色表示错误等等)</li><li>显示器过度使用色彩(使整个界面花里胡哨)</li></ul><h3 id="GUI组件"><a href="#GUI组件" class="headerlink" title="GUI组件"></a>GUI组件</h3><h4 id="移动应用UI"><a href="#移动应用UI" class="headerlink" title="移动应用UI"></a>移动应用UI</h4><p>主界面<br>次要界面：对话框、tab文件夹、下拉菜单<br>表单、菜单栏、工具栏、滚动栏、状态栏、文本框、复选框、单选按钮、命令按钮等</p><h4 id="web应用UI"><a href="#web应用UI" class="headerlink" title="web应用UI"></a>web应用UI</h4><p>主界面等等<br>导航设计：考虑导航的逻辑，这样用户就不会迷失在网页的“超空间”中</p><h3 id="评估设计"><a href="#评估设计" class="headerlink" title="评估设计"></a>评估设计</h3><ul><li>学习速度<br>用户学习和使用系统/产品的速度</li><li>操作速度<br>系统对用户操作响应的速度</li><li>容错率<br>系统对用户错误操作的容忍度如何</li><li>恢复程度<br>系统从用户的错误操作中恢复出来的能力如何</li><li>适应性<br>系统与某一模型关联的紧密程度</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>•界面设计应该以用户为中心。界面应该具有逻辑性和一致性，并帮助用户从错误中恢复<br>•交互风格包括直接操作，菜单系统，表单填写，命令语言和自然语言<br>•图形显示应用于显示趋势和近似值。当精度要求时，数字显示<br>颜色的使用要有节制和一致性<br>•系统应该提供在线帮助<br>•错误消息应该是积极的而不是消极的<br>•应提供一系列不同类型的用户文档<br>•理想情况下，用户界面应该根据可用性规范进行评估</p><hr><h2 id="UX设计-用户体验设计"><a href="#UX设计-用户体验设计" class="headerlink" title="UX设计(用户体验设计)"></a>UX设计(用户体验设计)</h2><p>UX是跨学科的，结合了设计、人机交互、市场、经济学等等<br>用户体验(缩写为UX)是一个人与系统交互时的感觉。要想你的产品成功，不管它的功能有多好，用户必须享受使用和浏览它<br>HCI：人机交互(Human-Computer Interaction)</p><h3 id="需求层级"><a href="#需求层级" class="headerlink" title="需求层级"></a>需求层级</h3><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-08-17-01-11.png" style="float: right; display: inline;"><p>最基本的需求从金字塔的底部开始，直到金字塔顶端的最高需求。<br>如果基本需求没有得到满足，就很难找到满足更高需求的欲望和动力。</p><ul><li>用户体验金字塔的基本需求是功能和信息。</li><li>更高的需求是美学和可用性</li></ul><h4 id="功能与信息"><a href="#功能与信息" class="headerlink" title="功能与信息"></a>功能与信息</h4><p>需求金字塔的底层，同时也是UX必须满足的两个基本要求</p><h5 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h5><p>当接口能够正常工作而不中断时，这种需求就得到了满足<br>接口几乎没有bug，所有点击的内容都会带用户去他们想去的地方<br>为了开始处理你的界面的功能，你必须知道你的<strong>界面将执行什么任务</strong>以及<strong>它们将如何完成</strong></p><h5 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h5><p>为了有意义和有价值的用户体验，信息必须是:</p><ul><li>有用的:你的内容应该是原创的，满足需求。</li><li>可用的:网站必须易于使用。</li><li>可取的:图像、身份、品牌和其他设计元素被用来唤起情感和欣赏。内容需要可导航和可定位的现场和非现场</li><li>可访问的:内容需要残疾人可访问</li><li>可信的:用户必须信任和相信你告诉他们的</li></ul><h4 id="美观与易用"><a href="#美观与易用" class="headerlink" title="美观与易用"></a>美观与易用</h4><p>需求金字塔的高层，界面需要一个独特的，友好的和专业的外观，使它从人群中<strong>脱颖而出</strong></p><h5 id="美观"><a href="#美观" class="headerlink" title="美观"></a>美观</h5><p>好的美学是让用户记住界面的东西。它甚至可以帮助你在用户中创建一个忠实的追随者<br>通过检查外观，用户应该了解你的界面的价值和个性</p><h5 id="易用性"><a href="#易用性" class="headerlink" title="易用性"></a>易用性</h5><p>当大多数人谈到用户体验时，他们指的是可用性，这是用户体验层次的最高需求。</p><ul><li><p>高易用性可以提高用户的工作效率。</p></li><li><p>具有高可用性的界面允许用户快速准确地完成任务。</p><blockquote><p>然而，大多数界面很少能充分发挥可用性。这是因为大多数界面都有很多任务，总有一些任务用户会在上面犯错误。<br>为了充分满足这一需求，有必要分析用户在界面中完成每项任务所需的准确性和速度,这需要:</p><ul><li>把界面放在用户面前，观察他们的行为。</li><li>还需要批判性的设计思维，提出澄清和简化用户流程的解决方案。</li></ul></blockquote></li><li><p>当用户能够持续快速地完成每项任务而不出错时，界面就满足了其可用性需求。</p><blockquote><p>在这点上，用户体验可以总结为“用户是否拥有尽可能愉快的体验?”</p></blockquote></li></ul><h3 id="UX测试"><a href="#UX测试" class="headerlink" title="UX测试"></a>UX测试</h3><h4 id="A-B测试"><a href="#A-B测试" class="headerlink" title="A/B测试"></a>A/B测试</h4><p>A/B测试软件——将一个网站的流量分成两个相等的部分。一组查看版本A，另一组查看版本b。每个版本的转换率和跳出率等统计数据都会被跟踪</p><h3 id="UX的限制和困难"><a href="#UX的限制和困难" class="headerlink" title="UX的限制和困难"></a>UX的限制和困难</h3><ul><li>无法设计出一个适合所有人的、理想的用户体验设计，必须做出一些妥协</li><li>难以客观地衡量UX的有效性</li><li>传统的网页评估指标，如“页面浏览量”，不能用来评估用户体验设计的有效性</li><li>UX设计师不一定具有技术背景，这可能会导致他们与开发者在设计建议上产生矛盾</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件工程与软件过程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端布局要义</title>
      <link href="/2021/06/06/%E5%89%8D%E7%AB%AF%E5%B8%83%E5%B1%80%E8%A6%81%E4%B9%89/"/>
      <url>/2021/06/06/%E5%89%8D%E7%AB%AF%E5%B8%83%E5%B1%80%E8%A6%81%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h2 id="问题剖析"><a href="#问题剖析" class="headerlink" title="问题剖析"></a>问题剖析</h2><p>最近写web实验的时候经常遇到一个头疼的事情，也就是我发现自己不知道怎么实现页面上一些图片错落有致的布局形式。想想应该用的是div这些东西卡好位置之后再填充图片和文字进去，但是对div怎么卡位置还有点模糊。<br>总的来说就是摸鱼太久了啦。</p><h2 id="布局基本概念"><a href="#布局基本概念" class="headerlink" title="布局基本概念"></a>布局基本概念</h2><h3 id="两大工具-div与span"><a href="#两大工具-div与span" class="headerlink" title="两大工具: div与span"></a>两大工具: div与span</h3><p><strong>div-块级元素</strong><br></p><blockquote><p>&lt;div&gt; 元素是块级元素，它可用于组合其他 HTML 元素的容器,没有特定的含义。</p><ul><li>属于块级元素，浏览器会在其前后显示折行。</li><li>如果与 CSS 一同使用，&lt;div&gt; 元素可用于对大的内容块设置样式属性。</li></ul></blockquote><p>&lt;div&gt; 元素的常见的用途是文档布局。它取代了使用表格定义布局的老式方法。使用 &lt;table&gt; 元素进行文档布局不是表格的正确用法, &lt;table&gt; 元素的作用是显示表格化的数据。</p><p><strong>span-内联元素</strong><br></p><blockquote><p>&lt;span&gt; 元素是内联元素，可用作文本的容器，没有特定的含义。</p></blockquote><p>当与 CSS 一同使用时，&lt;span&gt; 元素可用于为某一部分特定的文本设置样式属性。</p><h2 id="网站布局"><a href="#网站布局" class="headerlink" title="网站布局"></a>网站布局</h2><h3 id="良好的布局习惯"><a href="#良好的布局习惯" class="headerlink" title="良好的布局习惯"></a>良好的布局习惯</h3><p>良好的布局习惯中，我们一般用&lt;header&gt;、 &lt;footer&gt;、 &lt;section&gt;等标签划分每个页面逻辑的代码块。<br><strong>注意</strong><br>这些标签类似&lt;div&gt; 和 &lt;span&gt; ，其实都没有实际的含义，只是用于划开一个区域</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;section1&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--something--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是页脚<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用CSS划分区域"><a href="#使用CSS划分区域" class="headerlink" title="使用CSS划分区域"></a>使用CSS划分区域</h3><p>当我们用div分好区块，我们只是在布局逻辑的层面上划分好了区块而已。当我们真的要调整这些区块的位置时，就需要使用CSS。</p><h4 id="盒子模型-box-model"><a href="#盒子模型-box-model" class="headerlink" title="盒子模型(box model)"></a>盒子模型(box model)</h4><ul><li>所有的html元素都可以看作一个盒子</li><li>每个html元素有内边距、外边距、边框和内容物<blockquote><ul><li>Margin(外边距) - 清除边框外的区域，外边距是透明的。<blockquote><p>margin没有颜色，完全透明<br>margin可以单独改变元素的上下左右边距，也可以一次改变所有的属性<br>margin并不是用来布局的 (虽然他一定程度上确实可以，但是调margin并不会让一个块级元素变成内联)</p></blockquote></li><li>Border(边框) - 围绕在内边距和内容外的边框。</li><li>Padding(内边距) - 清除内容周围的区域，内边距是透明的。<blockquote><p>padding定义元素边框与元素内容之间的空间，即上下左右的内边距<br>当元素的 padding（填充）内边距被清除时，所释放的区域将会受到元素背景颜色的填充</p></blockquote></li><li>Content(内容) - 盒子的内容，显示文本和图像。</li></ul></blockquote></li></ul><p>盒子模型的作用在于如何调整内容物的位置等等</p><h4 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h4><p>我们用定位来调整div元素的位置。定位有五种：</p><ul><li>static<br>静态定位即没有定位，遵循正常的文档流对象。<br>元素不会受到 top, bottom, left, right影响。</li><li>relative<br>相对定位元素的定位是<strong>相对其正常位置</strong>。<br>相对正常的位置指的是在静态定位的情况下，元素应该处于的位置。</li><li>fixed<br>固定定位，元素的位置相对于浏览器窗口是固定位置。<br>即使窗口是滚动的它也不会移动，适用于广告和网页背景。</li><li>absolute<br>绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于&lt;html&gt;<br>absolute 定位使元素的位置与文档流无关，因此不占据空间，可以和其他元素重叠。<br>对于重叠的元素，可以用z-index调整覆盖关系。</li><li>sticky<br>粘性定位依赖于用户的滚动，元素在 position:relative 与 position:fixed 定位之间切换。<br>它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像position:fixed;，它会固定在目标位置。<br>元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。</li></ul><h2 id="页眉"><a href="#页眉" class="headerlink" title="页眉"></a>页眉</h2><h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><p>经常会用到边框作为导航栏之上的页眉，如下图<br><img src="https://raw.githubusercontent.com/Guiny-Time/Guiny-Time.github.io/main/images/attachmentsyemei.png"></p><p style="    border-left-style: solid;    border-width:5px;    border-color: #E5954D;    background-color: #FFF6D7;">我是边框<br>确实</p><h3 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h3><h2 id="页脚"><a href="#页脚" class="headerlink" title="页脚"></a>页脚</h2>]]></content>
      
      
      <categories>
          
          <category> web信息处理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021/6/5~2021/6/9涩图精选</title>
      <link href="/2021/06/05/%E6%B6%A9%E5%9B%BE2021-6-5/"/>
      <url>/2021/06/05/%E6%B6%A9%E5%9B%BE2021-6-5/</url>
      
        <content type="html"><![CDATA[<div class="justified-gallery"><p><img src="https://pixiv.cat/89437956.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90281512-1.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90281866.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90305978.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90293195.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90302417.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90316803.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90307332.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90299457.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90293517.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90291724.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90297150.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90294146-1.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90294146-4.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90294146-5.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90294146-7.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90294146-8.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90294146-9.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90294146-12.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90294146-15.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90294146-16.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90294146-19.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90297208.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90299492.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90316535-1.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90294319-1.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90294319-2.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90294319-3.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90294319-7.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90294319-9.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90294319-12.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90294319-13.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90294319-14.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90294319-17.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90294319-19.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90325444.jpg" alt="Pixiv.Cat"></p><p><img src="https://pixiv.cat/90302397.jpg" alt="Pixiv.Cat"></p><p><img src="https://pixiv.cat/90339383-1.jpg" alt="Pixiv.Cat"></p><p><img src="https://pixiv.cat/90339383-2.jpg" alt="Pixiv.Cat"></p><p><img src="https://pixiv.cat/90339383-3.jpg" alt="Pixiv.Cat"></p><p><img src="https://pixiv.cat/90339383-4.jpg" alt="Pixiv.Cat"></p><p><img src="https://pixiv.cat/90339383-5.jpg" alt="Pixiv.Cat"></p><p><img src="https://pixiv.cat/90339383-6.jpg" alt="Pixiv.Cat"></p><p><img src="https://pixiv.cat/90325137-1.jpg" alt="Pixiv.Cat"></p><p><img src="https://pixiv.cat/90321129.jpg" alt="Pixiv.Cat"></p><p><img src="https://pixiv.cat/90340035.jpg" alt="Pixiv.Cat"></p><p><img src="https://pixiv.cat/90318831.jpg" alt="Pixiv.Cat"></p><p><img src="https://pixiv.cat/90330826.jpg" alt="Pixiv.Cat"></p><p><img src="https://pixiv.cat/90339912.jpg" alt="Pixiv.Cat"></p><p><img src="https://pixiv.cat/90324361.jpg" alt="Pixiv.Cat"></p><p><img src="https://pixiv.cat/90317915.jpg" alt="Pixiv.Cat"></p><p><img src="https://pixiv.cat/90338117.jpg" alt="Pixiv.Cat"></p><p><img src="https://pixiv.cat/90327857.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90369328.jpg"></p><p><img src="https://pixiv.cat/90365455.jpg"></p><p><img src="https://pixiv.cat//90347904.jpg"></p><p><img src="https://pixiv.cat/90347943.jpg"></p><p><img src="https://pixiv.cat/90364617.jpg"></p><p><img src="https://pixiv.cat/90371034.jpg"></p><p><img src="https://pixiv.cat/90362442.jpg"></p><p><img src="https://pixiv.cat/90334896.jpg"></p><p><img src="https://pixiv.cat/90356032.jpg"></p><p><img src="https://pixiv.cat/90325697-1.jpg"></p><p><img src="https://pixiv.cat/90370369.jpg"></p><p><img src="https://pixiv.cat/90349856.jpg"></p><p><img src="https://pixiv.cat/90346155.jpg"><br><img src="https://pixiv.cat/90381253.jpg"></p><p><img src="https://pixiv.cat/90358374.jpg"></p><p><img src="https://pixiv.cat/90349918.jpg"><br><img src="https://pixiv.cat/90380805-1.jpg"><br><img src="https://pixiv.cat/90387307.jpg"><br><img src="https://pixiv.cat/90395080.jpg"><br><img src="https://pixiv.cat/90379944.jpg"><br>画的是三体中的红岸基地（妙啊<br><img src="https://pixiv.cat/90389930-3.jpg"><br><img src="https://pixiv.cat/90389930-4.jpg"><br><img src="https://pixiv.cat/90391148-1.jpg"><br><img src="https://pixiv.cat/90369040.jpg"><br><img src="https://pixiv.cat/90380507.jpg"><br><img src="https://pixiv.cat/90388496.jpg"><br><img src="https://pixiv.cat/90367612.jpg"><br><img src="https://pixiv.cat/90425312.jpg"><br><img src="https://pixiv.cat/90391947.jpg"><br><img src="https://pixiv.cat/90380216.jpg"><br><img src="https://pixiv.cat/90416969.jpg"><br><img src="https://pixiv.cat/90403519.jpg"><br><img src="https://pixiv.cat/90379934.jpg"><br><img src="https://pixiv.cat/90416980.jpg"><br><img src="https://pixiv.cat/90398962.jpg"><br><img src="https://pixiv.cat/90415485.jpg"><br><img src="https://pixiv.cat/90405261.jpg"><br><img src="https://pixiv.cat/90386845.jpg"><br><img src="https://pixiv.cat/90403613.jpg"><br><img src="https://pixiv.cat/90404694.jpg" alt="Pixiv.Cat"></p>          </div>]]></content>
      
      
      <categories>
          
          <category> 涩图 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>L8-设计模式</title>
      <link href="/2021/05/25/L8-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/05/25/L8-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="L8-设计模式"><a href="#L8-设计模式" class="headerlink" title="L8-设计模式"></a>L8-设计模式</h1><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>设计模式描述了一个在我们的环境中反复出现的问题，然后描述了该问题的核心解决方案，以这种方式，您可以使用该解决方案一百万次，而不必以同样的方式进行两次</p><blockquote><p>Design pattern describes a problem which occurs over and over again in our environment, and then describes the core of the solution to that problem, in such a way that you can use this solution a million times over, without ever doing it the same way twice</p></blockquote><p>设计模式使得优秀的设计与架构被反复使用</p><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><ul><li>寻找合适的对象<blockquote><p>•在设计中需要考虑的因素太多，例如，继承、封装、多态、单一责任、接口编程等<br>•确定设计方法</p></blockquote></li><li>确定对象的粒度<blockquote><p>•系统中对象的大小和数量<br>•类设计中的层次结构<br>•组合vs.继承</p></blockquote></li><li>提升重用性</li><li>为变革而设计</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>四人组对设计模式的划分有经典的23种，按照目的和范围可以划分为</p><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><ul><li>创造性<br>处理对象的创建</li><li>结构性<br>处理类与对象的构成关系</li><li>行为性<br>处理类或对象的交互与分配职责<h4 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h4></li><li>类<br>类与子类之间的关系，编译时的静态关系</li><li>对象<br>对象之间的关系，运行时的动态关系</li></ul><h3 id="模式元素"><a href="#模式元素" class="headerlink" title="模式元素"></a>模式元素</h3><ul><li>模式名<br>一个有意义的名字</li><li>问题领域<br>在上下文中反复遇到的问题，或者说此设计模式适用的问题发生的情况</li><li>解决方案<br>构成设计的元素、关系、责任和协作</li><li>反馈<br>使用该种设计模式的利弊<blockquote></blockquote></li></ul><p><strong>上下文情形</strong><br>描述了解决方案适用的问题类型<br><strong>问题</strong><br>问题指的是重复出现在上下文情景中<br><strong>解决方案</strong><br>构成设计的元素、关系、责任和协作</p><h3 id="如何选择设计模式"><a href="#如何选择设计模式" class="headerlink" title="如何选择设计模式"></a>如何选择设计模式</h3><ul><li><p>考虑设计模式如何解决设计问题。</p><blockquote><p>•如何识别合适的对象，<br>•如何确定对象的粒度，<br>•如何指定对象接口，<br>•如何指定对象实现，<br>•如何平衡类继承和接口继承，<br>•考虑接口编程，而不是实现编程。</p></blockquote></li><li><p>查找设计模式的意图以找到匹配。</p></li><li><p>了解设计模式之间的相互关系。</p></li><li><p>考虑一下如何使您的设计可重用。</p></li></ul><h3 id="设计模式总结"><a href="#设计模式总结" class="headerlink" title="设计模式总结"></a>设计模式总结</h3><h4 id="创造型设计模式"><a href="#创造型设计模式" class="headerlink" title="创造型设计模式"></a>创造型设计模式</h4><ul><li>抽象工厂模式<br>可以改变产品对象的种类</li><li>建造者模式<br>可以改变符合对象的创建方式</li><li>工厂模式<br>可以改变被实例化对象的子类</li><li>原型模式<br>可以改变被实例化的对象的一个类</li><li>单例模式<br>可以改变一个类的唯一实例</li></ul><h4 id="结构型设计模式总结"><a href="#结构型设计模式总结" class="headerlink" title="结构型设计模式总结"></a>结构型设计模式总结</h4><ul><li>适配器模式<br>可以改变对象的接口</li><li>桥接模式<br>可以改变对象的实现。</li><li>组合器模式<br>可以改变对象的结构和组合。</li><li>探测者模式<br>可以改变对象的职责而不需要子类化。</li><li>外观模式<br>可以改变子系统的接口。</li><li>享元模式<br>可以改变物品的存储成本。</li><li>代理模式<br>可以改变对象访问方式(它的位置)的代理</li></ul><h4 id="行为型设计模式总结"><a href="#行为型设计模式总结" class="headerlink" title="行为型设计模式总结"></a>行为型设计模式总结</h4><ul><li>责任链模式<br>可以改变一个对象来满足一个请求。</li><li>命令模式<br>在何时以及如何满足一个请求时可能会有所不同。</li><li>解释器模式<br>能改变一种语言的语法和解释的人。</li><li>迭代器模式<br>可以改变访问和/或遍历聚合元素的方式的迭代器。</li><li>中继者模式<br>对象可以改变对象之间的交互方式和交互方式。</li><li>Memento模式<br>这可以改变存储在对象外部的私有信息以及存储时间。</li><li>观察者模式<br>可以改变依赖于另一个对象的对象的数量;如何将相关对象保持最新。</li><li>状态模式<br>可以改变一个对象的状态。</li><li>策略模式<br>可以改变算法使用的策略。</li><li>模板方法模式(?<br>可以改变算法的步骤。</li><li>访问者模式<br>可以改变应用于对象的操作而不改变它们的类</li></ul><h3 id="请注意-不要对简单问题使用设计模式"><a href="#请注意-不要对简单问题使用设计模式" class="headerlink" title="请注意, 不要对简单问题使用设计模式"></a><font color="red">请注意, 不要对简单问题使用设计模式</font></h3><ul><li>设计模式使代码难以阅读/理解/调试。</li><li>设计模式使软件结构变得复杂。</li><li>不恰当地使用设计模式会让事情变得更糟。</li><li>不要用设计模式来解决简单的问题。</li></ul><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>在整个程序生命周期中只实例化一个对象，防止多个对象存在造成冲突等问题，并且提供一个全局方法可供访问(GetInstance()之类的)</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li>操作系统使用文件系统来管理文件</li><li>访问硬件的接口</li><li>静态配置数据(配置文件)</li><li>日志记录对象(Logger)</li><li>访问缓存存储</li><li>线程池<blockquote><p><strong>同步锁 synchronized</strong><br>Synchronized关键字确保每次只有一个线程可以访问被该关键字修饰的方法。<br>Synchronized public static void 方法名(para ){}</p></blockquote></li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrinterDriver</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> PrinterDriver printerDriver;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">PrinterDriver</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PrinterDriver <span class="title">getPrinterDriver</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果不存在则实例化</span></span><br><span class="line"><span class="keyword">if</span> (printerDriver == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (PrinterDriver.class) &#123;</span><br><span class="line">    <span class="keyword">if</span> (printerDriver == <span class="keyword">null</span>) &#123;</span><br><span class="line">      printerDriver = <span class="keyword">new</span> PrinterDriver();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> printerDriver;</span><br><span class="line">&#125;</span><br><span class="line">…</span><br></pre></td></tr></table></figure><h3 id="单例模式与静态类的区别"><a href="#单例模式与静态类的区别" class="headerlink" title="单例模式与静态类的区别"></a>单例模式与静态类的区别</h3><h4 id="可访问性"><a href="#可访问性" class="headerlink" title="可访问性"></a>可访问性</h4><ul><li>静态方法: 每个类都可以自由访问静态变量。</li><li>单例方法:易于控制谁获得实例<h4 id="灵活性"><a href="#灵活性" class="headerlink" title="灵活性"></a>灵活性</h4></li><li>静态方法方法:只复制一份</li><li>单例方法:如果需要，它可以配置一个指定数量的实例<h4 id="清晰程度"><a href="#清晰程度" class="headerlink" title="清晰程度"></a>清晰程度</h4></li><li>静态方法方法:可能污染命名空间</li><li>单例方法:不需要创建全局可见变量</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>对客户端访问实例化的类能够直接控制</li><li>可以取代全局变量</li><li>创建的实例化数目是可控的<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4></li><li>在多线程模式中需小心使用</li></ul><h3 id="类图结构"><a href="#类图结构" class="headerlink" title="类图结构"></a>类图结构</h3><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-05-25-16-27-29.png"></p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p><a href="https://www.runoob.com/design-pattern/factory-pattern.html">https://www.runoob.com/design-pattern/factory-pattern.html</a></p><h3 id="扩展与应用"><a href="#扩展与应用" class="headerlink" title="扩展与应用"></a>扩展与应用</h3><p>工厂方法模式将特定于应用程序的类从具体类型的实例化<strong>解耦</strong><br><strong>使用接口创建对象，但让子类决定实例化哪个类</strong><br>在以下情况下考虑使用工厂模式:</p><ul><li>一个类不能预测它必须创建的对象的类。</li><li>一个类希望它的子类指定它创建的对象。</li><li>类将责任委托给几个helper子类中的一个，你想本地化哪个helper子类是委托的知识。</li></ul><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><ul><li>功能抽象类(或者接口)<br>包含了一些需要被实现的方法，比如Shape</li><li>具体的小东西<br>实现了接口方法，比如Circle、Rectangle等等</li><li>工厂(提货)<br>含有工厂方法(比如display、print之类的)，一般是用string进行匹配实例化？</li></ul><h3 id="类图结构-1"><a href="#类图结构-1" class="headerlink" title="类图结构"></a>类图结构</h3><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-05-25-21-26-18.png"></p><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p><a href="https://www.runoob.com/design-pattern/facade-pattern.html">https://www.runoob.com/design-pattern/facade-pattern.html</a></p><h3 id="扩展与应用-1"><a href="#扩展与应用-1" class="headerlink" title="扩展与应用"></a>扩展与应用</h3><p>外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性，使子系统更易于使用</p><ul><li>为复杂的子系统提供一个简单的接口。</li><li>由于客户端和抽象的实现类之间存在许多依赖关系，所以将子系统从客户端解耦。</li><li>使用façade为分层设计的每个子系统定义一个入口点</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>操作系统使用façade将多个框架组合成一个。</li><li>程序编译器使用façade，让程序员的生活更轻松。</li><li>Web服务使用façade作为入口点。</li><li>数据库连接器，例如Java数据库连接(JDBC)使用façade来隐藏连接建立的复杂性。<br>或者说：<br>1、为复杂的模块或子系统提供外界访问的模块<br>2、子系统相对独立<br>3、预防低水平人员带来的风险</li></ul><h3 id="代码结构-1"><a href="#代码结构-1" class="headerlink" title="代码结构"></a>代码结构</h3><ul><li>各种子类(或者说子系统们)<br>之间的关系挺独立的，各自有各自的功能</li><li>外观类<br>内部实例化了这几个类的对象，实现了对应方法并对外提供可调用的接口</li></ul><h3 id="类图结构-2"><a href="#类图结构-2" class="headerlink" title="类图结构"></a>类图结构</h3><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-05-25-22-03-46.png"><br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-05-25-22-03-27.png"><br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-05-25-22-10-33.png"></p><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p><a href="https://www.runoob.com/design-pattern/adapter-pattern.html">https://www.runoob.com/design-pattern/adapter-pattern.html</a></p><h3 id="扩展与应用-2"><a href="#扩展与应用-2" class="headerlink" title="扩展与应用"></a>扩展与应用</h3><p>将类的接口转换为客户期望的另一个接口。适配器可以让类一起工作，否则由于不兼容的接口而无法工作</p><ul><li>使用一个现有的类，但它的接口与你需要的不匹配。</li><li>创建一个可重用的类，与不相关的或不可预见的类协作，也就是那些不一定有兼容接口的类。</li><li>使用几个现有的子类，但通过子类化每个人来调整它们的接口是不切实际的。对象适配器可以适应其父类的接口。</li></ul><h3 id="继承vs对象组合"><a href="#继承vs对象组合" class="headerlink" title="继承vs对象组合"></a>继承vs对象组合</h3><h4 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h4><ul><li>当我们想要适应一个类及其所有子类时，类适配器将无法工作。</li><li>适配器覆盖被适配的类的一些行为。<h4 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h4></li><li>一个适配器可以与许多适配器一起工作</li><li>适配器还可以一次为所有适配器添加功能。</li><li>很难覆盖被覆盖对象的行为</li></ul><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>多个数据库访问器</li><li>使用具有不兼容接口的工具包类</li><li>其他与桥接不兼容接口相关的通用问题<blockquote><p>例如，手机充电器和适配器，存储卡适配器，电子插头和适配器等</p></blockquote></li></ul><h3 id="代码结构-2"><a href="#代码结构-2" class="headerlink" title="代码结构"></a>代码结构</h3><ul><li>基础类<br>包含了一些有点过时的无法涵盖所有潜在问题的方法</li><li>进阶类<br>包含了新的解决潜在问题的方法</li><li>适配器<br>连接基础类和进阶类的桥梁，总之是要把两个合一块(我们三个就要在一起.jpg)</li></ul><p>之后，客户端通过基础类就可以通过适配器调用进阶类的方法以实现对应功能</p><h3 id="类图结构-3"><a href="#类图结构-3" class="headerlink" title="类图结构"></a>类图结构</h3><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-25-22-27-13.png"><br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-25-22-27-49.png"></p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p><a href="https://www.runoob.com/design-pattern/observer-pattern.html">https://www.runoob.com/design-pattern/observer-pattern.html</a></p><h3 id="扩展与应用-3"><a href="#扩展与应用-3" class="headerlink" title="扩展与应用"></a>扩展与应用</h3><p>在对象之间定义一对多的依赖关系，这样当一个对象改变状态时，它的所有依赖关系都会被通知并自动更新(一个分发布者与多个订阅者)</p><ul><li>当改变一个对象需要改变未知数量的其他对象。</li><li>当一个对象应该能够通知其他对象，而不假设这些对象是谁。</li><li>当一个抽象有两个方面，其中一个依赖于另一个</li></ul><h3 id="代码结构-3"><a href="#代码结构-3" class="headerlink" title="代码结构"></a>代码结构</h3><ul><li>发布者类<br>当发布者的状态改变的时候，发布这一消息</li><li>订阅者类<br>当发布者发布消息的时候，接收该消息并作出对应的反馈(也可以不反馈)</li></ul><p><strong>观察者模式可以只存在发布者而不存在订阅者</strong></p><h3 id="类图结构-4"><a href="#类图结构-4" class="headerlink" title="类图结构"></a>类图结构</h3><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-26-14-26-04.png"><br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-26-14-26-33.png"></p>]]></content>
      
      
      <categories>
          
          <category> 软件工程与软件过程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>L7-系统分析与设计</title>
      <link href="/2021/04/27/L7-%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
      <url>/2021/04/27/L7-%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="L7-系统分析与设计"><a href="#L7-系统分析与设计" class="headerlink" title="L7-系统分析与设计"></a>L7-系统分析与设计</h1><markdwon>  <details>    <summary><center>目标1：context-DFD(上下文数据流图)</center></summary><p>用于分析系统中数据的流向。在这个阶段我们只考虑整个程序和外部实体之间的联系</p><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-02-13-59-37.png"></p><h3 id="图样分析"><a href="#图样分析" class="headerlink" title="图样分析"></a>图样分析</h3><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-04-27-21-32-06.png"></p><h4 id="进程-Processing"><a href="#进程-Processing" class="headerlink" title="进程(Processing)"></a>进程(Processing)</h4><ul><li><strong>主要功能</strong>：接收数据、处理数据(过程黑箱)、输出数据</li><li>可以有多个输入输出</li><li>规范命名(最好是名词收尾的形式)</li></ul><h4 id="数据流-Data-Flow"><a href="#数据流-Data-Flow" class="headerlink" title="数据流(Data Flow)"></a>数据流(Data Flow)</h4><ul><li><strong>主要功能</strong>：显示数据流动的路径</li><li>可以表示一个或多个数据项</li><li>规范命名</li><li>路上至少经过一个进程</li></ul><h4 id="数据存储-Data-Storage"><a href="#数据存储-Data-Storage" class="headerlink" title="数据存储(Data Storage)"></a>数据存储(Data Storage)</h4><ul><li><strong>主要功能</strong>：表示存储的一个或多个将由进程处理的数据</li><li>不能与其他数据存储相连</li><li>规范命名</li></ul><h4 id="外部实体-External-Entity"><a href="#外部实体-External-Entity" class="headerlink" title="外部实体(External Entity)"></a>外部实体(External Entity)</h4><ul><li>向系统提供数据</li><li>从系统获取数据</li></ul></details><markdown><details>  <summary><center>目标2：Level-0图</center></summary><h2 id="Level-0图"><a href="#Level-0图" class="headerlink" title="Level-0图"></a>Level-0图</h2><p>在上下文数据流图的基础上进行扩展，将被隐藏的系统显示出来</p><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-02-14-00-07.png"></p><ul><li>level-0图提供了系统所有组件的概述</li><li>显示主要内部进程、数据流和数据存储</li><li>在level-0图的层次包括上下文图中已识别的外部实体</li><li>进程号并不表示进程执行的顺序</li></ul></details></markdown><markdown><details><summary><center>目标3：Level-1图(低级dfd图)</center></summary><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-02-14-00-39.png"></p><p>•低级dfd的级别只能在所有功能原语被识别时才能确定(升级)<br>•所有低级dfd都基于上级确定的流程<br>•所有低级dfd的输入和输出数据流必须正确对齐(平衡)</p></details></markdown><h3 id="目标图表总结"><a href="#目标图表总结" class="headerlink" title="目标图表总结"></a>目标图表总结</h3><p>•数据流程图用于数据和流程建模。<br>•dfd显示系统中的数据移动和转换。<br>•dfd以层次结构组织细节层次。<br>•上下文图表示系统范围及其外部依赖关系。<br>•level-0图显示了系统的主要流程、数据存储、外部实体和数据流。<br>•低级图表(level-1图)显示了系统的附加细节。<br>•dfd应准确反映被建模的信息系统。<br>•dfd的完整集合应该扩展到原始层次，其中每个组件都反映了某些不可约的属性。这是一个迭代过程。</p><h2 id="面向对象-OOP"><a href="#面向对象-OOP" class="headerlink" title="面向对象(OOP)"></a>面向对象(OOP)</h2><h3 id="什么是面向对象编程-OOP"><a href="#什么是面向对象编程-OOP" class="headerlink" title="什么是面向对象编程(OOP)"></a>什么是面向对象编程(OOP)</h3><p>面向对象编程是一种实现方法，在这种方法中，程序被组织为对象的协作集合，每个对象代表某个类的实例，其类都是通过继承关系统一的类层次结构的成员</p><blockquote><p>”Object-oriented programming is a method of implementation in which programs are organized as cooperative collections of objects, each of which represents an instance of some class, and whose classes are all members of a hierarchy of classes united via inheritance relationships.” </p></blockquote><h3 id="什么是面向对象设计-OOD"><a href="#什么是面向对象设计-OOD" class="headerlink" title="什么是面向对象设计(OOD)"></a>什么是面向对象设计(OOD)</h3><p>面向对象设计是一种设计方法，包括面向对象的分解过程和描述被设计系统的逻辑和物理以及静态和动态模型的符号</p><blockquote><p>Object-oriented design is a method of design encompassing the process of object-oriented decomposition and a notation for depicting both logical and physical as well as static and dynamic models of the system under design</p></blockquote><h3 id="面向对象分析-OOA"><a href="#面向对象分析-OOA" class="headerlink" title="面向对象分析(OOA)"></a>面向对象分析(OOA)</h3><p>面向对象分析是一种分析方法，它从问题域词汇表中的类和对象的角度来检查需求</p><blockquote><p>Object-oriented analysis is a method of analysis that examines requirements from the perspective of the classes and objects found in the vocabulary of the problem domain</p></blockquote><h4 id="用例分析"><a href="#用例分析" class="headerlink" title="用例分析"></a>用例分析</h4><p>实际上是从用户故事中分析需要写哪些类、类与类之间的关系</p><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-06-10-54-43.png"><br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-06-10-55-28.png"></p><h4 id="类间分析"><a href="#类间分析" class="headerlink" title="类间分析"></a>类间分析</h4><ul><li>主要从经典范畴原则派生类和对象</li><li>关注问题领域的有形事物</li></ul><h4 id="行为分析"><a href="#行为分析" class="headerlink" title="行为分析"></a>行为分析</h4><ul><li><p>关注动态行为作为类和对象的主要来源。</p></li><li><p>基于具有相似行为的对象组的窗体类。</p></li><li><p>将有共同责任的事情分组。</p><blockquote><p>类的层次结构从一般的职责到专门的行为被创建</p></blockquote></li><li><p>由系统函数导出</p></li></ul><ol><li>将系统行为分配给系统的各个部分</li><li>了解谁发起这些行为，谁参与这些行为</li><li>起重要作用的发起者和参与者被视为对象。</li></ol><h4 id="类-职责-协作卡-CRC"><a href="#类-职责-协作卡-CRC" class="headerlink" title="类-职责-协作卡(CRC)"></a>类-职责-协作卡(CRC)</h4><p>图样：<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-06-11-00-28.png"></p><p>包含了类的继承关系(父类、子类)、对该类的描述、变量(变量名和它的描述)、职责</p><p>包含了：</p><ul><li>类的继承关系(父类、子类)</li><li>对该类的描述</li><li>变量(变量名和它的描述)</li><li>职责(不同于类的方法，但是方法履行职责)<br>执行对象的职责与了解对象的职责</li></ul><p>其分析作用是</p><ul><li>回顾用例图的描述</li><li>识别相关的参与者和对象</li><li>用例图场景的角色扮演</li><li>重复上面的步骤，直到所有的用例都被执行</li></ul><h2 id="结构分析"><a href="#结构分析" class="headerlink" title="结构分析"></a>结构分析</h2><h3 id="流程建模"><a href="#流程建模" class="headerlink" title="流程建模"></a>流程建模</h3><p>详见DFD图</p><h3 id="数据建模-Data-Modelling"><a href="#数据建模-Data-Modelling" class="headerlink" title="数据建模(Data Modelling)"></a>数据建模(Data Modelling)</h3><h4 id="什么是数据建模"><a href="#什么是数据建模" class="headerlink" title="什么是数据建模"></a>什么是数据建模</h4><p>数据建模指的是一个详细的模型，它捕获组织数据的整体结构，独立于任何数据库管理系统或其他实现考虑</p><ul><li>数据建模建立发展数据中的定义、结构和关系。</li><li>数据建模解释了需要组织做什么，以及管理在组织中执行的工作的规则。</li><li>数据模型不关心数据何时被处理或使用。</li><li>概念数据建模通常与其他需求分析和系统分析活动一起执行，如流程建模和逻辑建模。</li><li>工作和活动通常通过项目字典或由通用计算机辅助软件工程(CASE)软件工具维护的存储库进行协调和共享。</li><li>数据建模最常用的技术是实体关系(E-R)图</li></ul><h4 id="数据建模的重要性"><a href="#数据建模的重要性" class="headerlink" title="数据建模的重要性"></a>数据建模的重要性</h4><ul><li><p>在数据库、程序、计算机屏幕和打印报告的设计中，数据的特性是很重要的。</p></li><li><p>数据是许多现代信息系统中最复杂的方面。</p><blockquote><p>事务处理系统，如订单处理系统，在验证数据、协调错误和协调数据移动方面可能会有相当大的过程复杂性。</p></blockquote></li><li><p>数据的特征，如格式和实体关系，相对稳定，并且在同一业务领域的组织之间基本相同。</p><blockquote><p>基于面向数据而不是面向流程或逻辑的信息系统设计应该有更长的使用寿命。</p></blockquote></li></ul><h4 id="为数据建模收集信息！"><a href="#为数据建模收集信息！" class="headerlink" title="为数据建模收集信息！"></a>为数据建模收集信息！</h4><p>概念数据模型可以从头开始开发、从现有数据模型中提炼或购买(特定业务领域的标准数据模型)。数据建模通常是从多种角度进行的：</p><ul><li><p>自上而下的方法<br>从对业务性质的理解中获取数据模型的业务规则(面试，询问具体问题)</p></li><li><p>自下而上的方法<br>审阅特定的业务文件，如报告和收据等。</p></li></ul><h3 id="实体关系建模-E-R-Modelling"><a href="#实体关系建模-E-R-Modelling" class="headerlink" title="实体关系建模(E-R Modelling)"></a>实体关系建模(E-R Modelling)</h3><p>E-R图是实体关系模型的图形化展示，被用于数据建模。该建模方式是数据库设计中常用的方法，建模符号由三个主要的构造(数据实体、关系、相关属性)组成</p><h4 id="实体-Entities"><a href="#实体-Entities" class="headerlink" title="实体(Entities)"></a>实体(Entities)</h4><p>实体指的是存在于用户环境中的一个人、一个地方、一个事件、一个对象等等，拥有自己的身份，有别于其他实体。<br>实体类型(或实体类)是共享共同属性或特征(类似于OOD中的“类”)的实体的集合，比如各种品种的猫猫的实体组成猫的实体类型。<br>实体实例是实体类型的单一出现(类似于OOD中的“对象”)，比如从猫猫实体类中实例化出深红大猫猫，大猫猫是唯一的</p><p>对实体类型的定义应该包括：</p><ul><li>实体类型的每个实例的唯一特征(属性)是什么。</li><li>在实体类型中包含和不包含什么实体实例。<br>当- 创建和删除实体类型的实例时。当一个实例可能变成另一个实体类型的实例时。<br>例如:对建筑公司的投标一旦被接受就成为合同。</li><li>什么历史是可以保存的。</li></ul><h4 id="ER模型变量"><a href="#ER模型变量" class="headerlink" title="ER模型变量"></a>ER模型变量</h4><p>你就参考OOD里头类的变量来就完事了<br>比如员工类，变量有名字、年龄、技能、员工代码等等<br>每个实体类型都必须具有一个或一组属性，以区别同一个类型的其他实例。属性或属性的集合称为候选键(Candidate Key, 你是不是想到了数据库的键…差不多)</p><ul><li><p>一个可以包含多个值的属性称为多值属性(Multivalued Attribute)</p></li><li><p>几个重复到一起的属性称为重复组(Repeating Group)</p><blockquote><p>使用一对大括号括起重复组或多值属性</p></blockquote></li><li><p>对于每个实体实例必须有一个值的属性称为必选属性(Required Attribute)</p></li><li><p>一个不能为每个实体实例都有值的属性称为可选属性(Optional Attribute)</p></li><li><p>一个有意义的组成部分被称为复合属性(Composite Attribute)</p></li><li><p>可以从数据库中其他数据计算出的属性值称为派生属性(Derived Attribute)<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-28-17-29-28.png"></p></li></ul><h4 id="ER模型关系"><a href="#ER模型关系" class="headerlink" title="ER模型关系"></a>ER模型关系</h4><ul><li>关系是<strong>组织</strong>感兴趣的<strong>一个或多个实体类型的实例之间的关联</strong>。</li><li>关系通常意味着<strong>一个事件已经发生</strong>，或者<strong>实体实例之间存在一些自然的联系</strong>。</li><li>关系用动词短语来标记。</li><li>参与关系的实体类型的数量被称为关系的程度。<blockquote><ul><li>一元关系(或递归关系)、二元关系和三元关系是常见的。</li><li>更高程度的关系是可能的，但在实践中很少遇到。<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-28-17-32-45.png"></li></ul></blockquote></li></ul><h5 id="关系基数"><a href="#关系基数" class="headerlink" title="关系基数"></a>关系基数</h5><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-28-17-36-22.png"><br>首先我们来看一堆魔法棒，他英文名字挺直白的，叫牛脚符号(Crow’s Foot Symbols)。。<br>这堆奇奇怪怪的跟召唤恶魔的奇怪符号一样的符号指的是可以(或必须)与实体A的每个实例相关联的实体b的数量，自上而下分别是：</p><ul><li>一个或者更多个</li><li>要么一个，要么没有(欢迎来到0与1的世界)</li><li>就一个</li><li>要么0，要么1，要么一堆</li></ul><p>应用到实体实例中就是：<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-28-17-39-08.png"></p><h4 id="超类型-Supertypes-与子类型-Subtypes"><a href="#超类型-Supertypes-与子类型-Subtypes" class="headerlink" title="超类型(Supertypes)与子类型(Subtypes)"></a>超类型(Supertypes)与子类型(Subtypes)</h4><p>可以理解成OOD中的继承父类和子类</p><ul><li>子类型<br>实体类型中的实体的一个子组，它对组织具有完全意义，并具有不同于其他子组的公共属性或关系</li><li>超类型<br>与一个或多个子类型有关系的泛型实体类型<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-28-17-45-40.png"></li></ul><p>上图中，Employee是底下两个的父类</p><h5 id="关系规则"><a href="#关系规则" class="headerlink" title="关系规则"></a>关系规则</h5><p>为了避免出现超级老虎吃屎的问题，我们需要制定规则</p><ul><li><p>总专业化规则<br>•指定超类型的每个实体实例<strong>必须是关系的某个子类型</strong>的成员。例如，一个人必须是员工或学生或两者都是。<br>•从超类型到圆的双行</p></li><li><p>重叠规则:<br>•指定一个实体实例<strong>可以同时是两个或多个子类型的成员</strong>。一个人既可以是雇员也可以是学生<br>•在圈里写个“o”</p></li><li><p>局部特殊化规则<br>•指定父类型的实体实例<strong>不必属于任何子类型</strong>。例如，一个员工可以只是一个员工，一个员工不必是教员或员工。<br>•从超类型到圆的一行</p></li><li><p>不相交的规则:<br>•指定如果超类型的实体实例是一个子类型的成员，它<strong>不能同时是任何其他子类型的成员</strong>。例如，一个人必须是雇员或学生。<br>•在圈里写个“d”<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-28-18-02-06.png"></p></li></ul><h1 id="GRASP-General-Responsibility-Assignment-Software-Pattern-or-Principles-原则"><a href="#GRASP-General-Responsibility-Assignment-Software-Pattern-or-Principles-原则" class="headerlink" title="GRASP(General Responsibility Assignment Software Pattern or Principles)原则"></a>GRASP(General Responsibility Assignment Software Pattern or Principles)原则</h1><p>领域模型(Domain Model)是概念类或领域中实际情况对象的可视化表示</p><h2 id="GRASP-创造者-Creator"><a href="#GRASP-创造者-Creator" class="headerlink" title="GRASP-创造者(Creator)"></a>GRASP-创造者(Creator)</h2><p>创造者指：谁创造了谁？<br>如果A和B之间有以下关系中的一个，我们就可以认为B是A的创造者：</p><ul><li>B包含或复合聚合A</li><li>B记录A</li><li>B紧密使用A</li><li>B拥有A的初始化数据。</li></ul><p>举个例子，“项目”这个实体拥有“项目待办列表”这个实体的所有数据，所以我们认为项目是项目待办列表的创造者</p><h2 id="GRASP-信息专家-Information-Expert"><a href="#GRASP-信息专家-Information-Expert" class="headerlink" title="GRASP-信息专家(Information Expert)"></a>GRASP-信息专家(Information Expert)</h2><p>给对象分配职责的基本原则是将一个职责分配给具有完成该职责所需信息的类<br>说人话就是：谁能(有信息)干给谁干<br>比如说产品待办列表有所有的用户需求信息，所以它负责用户故事</p><h2 id="GRASP-低耦合-Low-Coupling"><a href="#GRASP-低耦合-Low-Coupling" class="headerlink" title="GRASP-低耦合(Low Coupling)"></a>GRASP-低耦合(Low Coupling)</h2><p>当系统的耦合度低时，我们改动系统的一部分代码时不会对其他部分造成太大的影响<br>低耦合的方法：分配职责，使不必要的耦合保持在较低水平。使用这个原则来评估替代方案</p><h2 id="GRASP-控制者-Controller"><a href="#GRASP-控制者-Controller" class="headerlink" title="GRASP-控制者(Controller)"></a>GRASP-控制者(Controller)</h2><p>谁是控制者？<br>将责任分配给代表以下选择之一的对象:</p><ul><li>表示整个系统，一个“根对象”，一个软件运行的设备，或一个主要子系统(façade控制器的变体)。</li><li>表示系统操作发生的用例场景(用例或会话控制器)。</li></ul><h2 id="GRASP-高内聚-High-Cohesion"><a href="#GRASP-高内聚-High-Cohesion" class="headerlink" title="GRASP-高内聚(High Cohesion)"></a>GRASP-高内聚(High Cohesion)</h2><p>如何保持对象集中、可理解和可管理，以及作为一个副作用，支持低耦合?这就需要高内聚，分配责任，保持高度的凝聚力。用它来评估替代方案<br>高内聚是指类与类之间的关系而定.高，意思是他们之间的关系要简单明了，不要有很强的关系<br>内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系</p><h2 id="GRASP-多态-Polymorphism"><a href="#GRASP-多态-Polymorphism" class="headerlink" title="GRASP-多态(Polymorphism)"></a>GRASP-多态(Polymorphism)</h2><p>如何基于类型处理备选方案? 如何创建可插拔的软件组件?<br>解决方法：多态</p><blockquote><p>当相关的替代方案或行为随类型而变化时，使用多态操作将行为的责任分配给行为所变化的类型<br>好处是新变体的扩展容易添加，并且可以在不影响客户机的情况下引入新的实现(热拔插)</p></blockquote><h2 id="GRASP-纯制造，间接和保护变异-Pure-Fabrication-Indirection-and-Protected-Variations"><a href="#GRASP-纯制造，间接和保护变异-Pure-Fabrication-Indirection-and-Protected-Variations" class="headerlink" title="GRASP-纯制造，间接和保护变异(Pure Fabrication, Indirection and Protected Variations)"></a>GRASP-纯制造，间接和保护变异(Pure Fabrication, Indirection and Protected Variations)</h2><h3 id="纯制造"><a href="#纯制造" class="headerlink" title="纯制造"></a>纯制造</h3><p>当你不想违背高内聚低耦合的原则，但是解决方案又不完美的时候该怎么办？<br>将一组高内聚的职责分配给一个不代表问题域概念的人工或方便类，以支持高内聚、低耦合和重用。如类(class)是一种虚构的想象。</p><h3 id="间接"><a href="#间接" class="headerlink" title="间接"></a>间接</h3><p>在哪里分配责任，以避免两个或多个事物之间的直接耦合?如何对对象进行解耦合，以支持低耦合，并保持较高的重用潜力?<br>解决方法是将责任分配给中间对象，以便在其他组件或服务之间进行中介，这样您的组件或服务就不会直接耦合<br>常见的应用在于适配器模式、桥接模式、观察者模式、中继器模式、外观模式</p><h3 id="突变保护"><a href="#突变保护" class="headerlink" title="突变保护"></a>突变保护</h3><p>如何设计对象、子系统和系统，使这些元素的变化或不稳定性不会对其他元素产生不良影响?<br>解决方法是识别预测的变化或不稳定点;为它们分配创建稳定接口(广义的访问视图)的职责<br>常见的应用在于许多设计原则中，比如多态、接口、封装与绝大多数设计模式</p><h1 id="面向对象五大原则-SOLID"><a href="#面向对象五大原则-SOLID" class="headerlink" title="面向对象五大原则(SOLID)"></a>面向对象五大原则(SOLID)</h1><h2 id="SOLID"><a href="#SOLID" class="headerlink" title="SOLID"></a>SOLID</h2><ul><li>SRP单一职责原则</li><li>OCP开闭原则</li><li>LSP里氏替换原则</li><li>ISP接口隔离原则</li><li>DIP依赖反转原则</li></ul><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>一个类干一件事并干好，每个模块或类都应该对软件提供的功能的单个部分负责(高内聚)</p><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>模块对于扩展是开放的，但是对于修改是封闭的</p><blockquote><p>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化（开）</p><p>而不是通过修改已有的代码来实现变化（闭）</p></blockquote><p>比如工厂模式，一个很好的符合开闭原则的设计模式<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-28-23-57-08.png"></p><h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>如果对于每个类型为S的对象o1，都有一个类型为T的对象o2，使得所有以T定义的程序P，当o1取代o2时，P的行为保持不变，那么S就是类型为T的子类型</p><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>不应该强迫客户端依赖于它们不使用的接口，只继承该用的接口</p><p>解决方法是从操作中创建不同的方法接口，然后让客户端实现需要的接口，如下图(感谢大鹏文档的回答)</p><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedane20210630103543.png"></p><h3 id="依赖反转原则"><a href="#依赖反转原则" class="headerlink" title="依赖反转原则"></a>依赖反转原则</h3><blockquote><p>对抽象接口的每一次更改都对应于对其具体实现的更改。相反，对具体实现的更改并不总是(甚至通常)需要对其实现的接口进行更改。</p></blockquote><p>依赖反转原则是指一种特定的解耦（传统的依赖关系创建在高层次上，而具体的策略设置则应用在低层次的模块上）形式，使得高层次的模块不依赖于低层次的模块的实现细节，依赖关系被颠倒（反转），从而使得低层次模块依赖于高层次模块的需求抽象。</p><h4 id="该原则规定"><a href="#该原则规定" class="headerlink" title="该原则规定"></a>该原则规定</h4><ul><li>高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口。</li><li>抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。</li><li>该原则颠倒了一部分人对于面向对象设计的认识方式。如高层次和低层次对象都应该依赖于相同的抽象接口</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>GRASP原则可以作为一个工具，帮助掌握OOD的基础知识，理解对象设计中的责任分配。</li><li>GRASP遵循责任驱动设计的理念，思考如何将责任分配给协作对象。</li><li>GRASP和SOLID基本重叠。</li></ul></markdwon>]]></content>
      
      
      <categories>
          
          <category> 软件工程与软件过程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>L6-架构设计</title>
      <link href="/2021/04/25/L6-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
      <url>/2021/04/25/L6-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="L6-架构设计"><a href="#L6-架构设计" class="headerlink" title="L6-架构设计"></a>L6-架构设计</h1><h2 id="什么是系统架构"><a href="#什么是系统架构" class="headerlink" title="什么是系统架构"></a>什么是系统架构</h2><ul><li><p>系统的软件架构是对系统进行推理所需的一组<strong>结构</strong>，这些结构包括<strong>软件元素</strong>、它们之间的<strong>关系</strong>以及两者的<strong>属性</strong></p><blockquote><p>“The software architecture of a system is the set of structures needed to reason about the system, which comprise software elements, relations among them, and properties of both</p></blockquote></li><li><p>系统架构是系统在其环境中的<strong>基本概念或属性的集合</strong>，体现在其元素、关系以及其设计和发展的原则中</p><blockquote><p>“The architecture of a system is the set of fundamental concepts or properties of the system in its environment, embodied in its elements, relationships, and the principles of its design and evolution</p></blockquote></li><li><p>架构设计关注的是如何<strong>组织软件系统</strong>并<strong>设计该系统的整体结构</strong></p><blockquote><p>Architectural design is concerned with understanding how a software system should be organized and designing the overall structure of that system</p></blockquote></li></ul><h2 id="系统架构的重要性"><a href="#系统架构的重要性" class="headerlink" title="系统架构的重要性"></a>系统架构的重要性</h2><ul><li>加强利益相关者之间的沟通</li><li>允许架构师和项目经理估算成本和进度</li><li>定义后续实现的约束</li><li>包含最基本和最难改变的设计决策</li><li>为软件产品创建可转移和可重用的模型</li><li>便于系统分析</li></ul><h2 id="架构层级"><a href="#架构层级" class="headerlink" title="架构层级"></a>架构层级</h2><p>架构本身是一种抽象</p><h3 id="微观层面"><a href="#微观层面" class="headerlink" title="微观层面"></a>微观层面</h3><p>指的是具体的一个小的程序的实现架构，这些小的程序通过接口可以组合成一个更大的程序。考虑如何实现它，如何分解成小组件<br>比如说四轮项目的玩家，包含了管理器、控制器；而四轮本体是一个更大的项目</p><h3 id="宏观层面"><a href="#宏观层面" class="headerlink" title="宏观层面"></a>宏观层面</h3><p>指的是整个系统的架构，关注如何使用组件组成这么一个大的系统<br>比如四轮本体，包含了玩家、敌人和放置这几个小的程序</p><h2 id="架构设计的声明周期"><a href="#架构设计的声明周期" class="headerlink" title="架构设计的声明周期"></a>架构设计的声明周期</h2><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-06-22-55-43.png"></p><h3 id="架构重要性需求（Architecturally-Significant-Requirements）：指在所有需求中一些对架构有特殊重要性的需求。"><a href="#架构重要性需求（Architecturally-Significant-Requirements）：指在所有需求中一些对架构有特殊重要性的需求。" class="headerlink" title="架构重要性需求（Architecturally Significant Requirements）：指在所有需求中一些对架构有特殊重要性的需求。"></a>架构重要性需求（Architecturally Significant Requirements）：指在所有需求中一些对架构有特殊重要性的需求。</h3><blockquote><p>设计是一种转换，从需求到解决方案，可以是由代码、框架和组件组成的结构。<br>结构的初步文档(草图)应该作为建筑设计的一部分。<br>如果正在开发的项目不是微不足道的，那么应该评估设计，以确保做出的决策适合于处理ASRs<br>架构师在实现过程中的职责是确保代码与设计的一致性。</p></blockquote><h2 id="原则性方法Principled-Methods"><a href="#原则性方法Principled-Methods" class="headerlink" title="原则性方法Principled Methods"></a>原则性方法Principled Methods</h2><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-06-22-57-56.png"></p><h3 id="Architectural-Views-4-1-："><a href="#Architectural-Views-4-1-：" class="headerlink" title="Architectural Views (4+1)："></a>Architectural Views (4+1)：</h3><ul><li>Logical View<br>逻辑视图将系统中的关键抽象显示为对象或对象类。<br>用于将系统需求与逻辑视图中的元素相关联。</li><li>Physical View<br>物理视图显示系统硬件和软件组件如何在系统中分布。<br>用于规划系统部署</li><li>Development View<br>开发视图显示了如何对软件进行开发分解。<br>有利于分配工作和规划发展。</li><li>Process View<br>流程视图显示了系统是如何在运行时由交互流程组成的。<br>用于判断非功能系统特征</li><li>Scenarios<br>用于说明和验证这4个视图。<h3 id="Structures-and-Views-ADD"><a href="#Structures-and-Views-ADD" class="headerlink" title="Structures and Views (ADD)"></a>Structures and Views (ADD)</h3></li><li>View：视图由一组元素和它们之间的关系的表示组成。<br>结构是元素本身的集合，因为它们存在于软件或硬件中</li><li>Module structures：如何将系统构建为一组必须构建或获取的代码或数据单元。</li><li>Component-and-connector structures: 如何将系统构建为一组具有运行时行为(组件)和交互(连接器)的元素。</li><li>Allocation structures：显示了软件元素及其操作环境中的元素之间的关系。<h4 id="Viewpoints-视图为视图的构造提供了一个模板。"><a href="#Viewpoints-视图为视图的构造提供了一个模板。" class="headerlink" title="Viewpoints: 视图为视图的构造提供了一个模板。"></a>Viewpoints: 视图为视图的构造提供了一个模板。</h4></li><li>Context viewpoint: 描述系统及其环境之间的关系、依赖关系和交互。</li><li>Functional viewpoint: 描述系统的功能元素、它们的职责、接口和交互。</li><li>Information viewpoint: 描述系统如何存储、操作、管理和分发信息。</li><li>Concurrency viewpoint: 描述系统的并发结构并将功能元素映射到并发单元。</li><li>Development viewpoint: 描述支持软件开发过程的体系结构。</li><li>Deployment viewpoint: 描述如何使用关联依赖项在其操作环境中安装和部署系统。</li><li>Operational viewpoint: 描述如何操作、管理和支持系统。</li><li>View Relationships:</li></ul><h2 id="Architectural-Patterns-体系结构模式"><a href="#Architectural-Patterns-体系结构模式" class="headerlink" title="Architectural Patterns(体系结构模式)"></a>Architectural Patterns(体系结构模式)</h2><p>体系结构模式描述了用于解决问题的元素类型及其交互形式。</p><h3 id="客户端-服务器结构-Client-Server-Architecture"><a href="#客户端-服务器结构-Client-Server-Architecture" class="headerlink" title="客户端-服务器结构(Client-Server Architecture)"></a>客户端-服务器结构(Client-Server Architecture)</h3><p>该模式由两部分构成：单个服务器端和多个客户端。服务器组件对多个客户端组件提供服务。客户端向服务器端请求服务，服务端提供对应服务给这些客户端。此外，服务器端继续监听客户端请求。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>服务器可以跨网络分布</li><li>一般功能可提供给所有客户<h4 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h4></li><li>客户端通过请求/应答连接器连接到服务器</li><li>服务器组件也可以是其他服务器的客户端<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4></li><li>服务器可能是一个性能瓶颈</li><li>服务器可能是单点故障</li><li>在系统建立之后，关于定位功能(客户端还是服务器端)的决定通常是复杂的，更改成本很高</li></ul><h3 id="分层结构-Layered-Architecture"><a href="#分层结构-Layered-Architecture" class="headerlink" title="分层结构(Layered Architecture)"></a>分层结构(Layered Architecture)</h3><p>该模式用于构建可分解为多组子任务的程序，每个子任务都在某个抽象层，每个层对上一个更高层提供服务。</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>如果要对界面进行维护，允许更换整个层</li><li>每层均可提供冗余设施，提高系统可靠性。<h4 id="限制-1"><a href="#限制-1" class="headerlink" title="限制"></a>限制</h4></li><li>每个软件都被精确分配到一个层</li><li>至少有两层(但通常是三层或更多)。允许使用的关系不应该是循环的(即较低的层不应该使用上面的层)。<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4></li><li>添加层次会增加系统的前期成本和复杂性</li><li>层会影响性能，带来功能损失。</li></ul><h3 id="Model-View-Controller-MVC-Architecture"><a href="#Model-View-Controller-MVC-Architecture" class="headerlink" title="Model-View-Controller (MVC) Architecture"></a>Model-View-Controller (MVC) Architecture</h3><p>划分交互程序为3个部分：</p><ul><li>模型——包含核心功能和数据</li><li>视图——显示信息给用户（多个视图可被定义）</li><li>控制器——处理用户输入<br>它通过分割用户信息的内部陈述和呈现、接受方式来实现，解耦组件并允许高效的代码复用。<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4></li><li>允许数据独立于其表示进行更改，反之亦然</li><li>支持以不同的方式呈现相同的数据。<h4 id="限制-2"><a href="#限制-2" class="headerlink" title="限制"></a>限制</h4></li><li>模型、视图和控制器必须至少有一个实例</li><li>模型组件不应该直接与控制器交互。<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4></li><li>对于简单的用户界面来说，复杂性可能不值得</li><li>它可能不适用于某些用户界面工具包。</li></ul><h2 id="参考架构"><a href="#参考架构" class="headerlink" title="参考架构"></a>参考架构</h2><h3 id="网页应用"><a href="#网页应用" class="headerlink" title="网页应用"></a>网页应用</h3><h3 id="移动应用"><a href="#移动应用" class="headerlink" title="移动应用"></a>移动应用</h3><h2 id="架构设计的经验法则"><a href="#架构设计的经验法则" class="headerlink" title="架构设计的经验法则"></a>架构设计的经验法则</h2><ul><li>软件体系结构应该是单个架构师或一小群架构师的产品</li><li>架构师应该将架构建立在定义良好的质量属性需求的优先级列表上</li><li>应该评估体系结构交付系统重要质量属性的能力。</li><li>架构不应该依赖于商业产品或工具的特定版本。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件工程与软件过程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>L5-系统建模</title>
      <link href="/2021/04/13/L5-%E7%B3%BB%E7%BB%9F%E5%BB%BA%E6%A8%A1/"/>
      <url>/2021/04/13/L5-%E7%B3%BB%E7%BB%9F%E5%BB%BA%E6%A8%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="L5-系统建模"><a href="#L5-系统建模" class="headerlink" title="L5-系统建模"></a>L5-系统建模</h1><markdown><details><summary><center>目标1: 上下文图(Context Diagram)编写</center></summary><p>结构如下：</p><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-02-10-58-18.png"></p><p>主要由两个结构组成</p><ul><li><p>系统或外部系统<br>由方框表示，上部分用&lt;&lt;&gt;&gt;括起来的是类型，用来描述模型元素<br>类型有use、include、import和system等等，一般用到的是system</p></li><li><p>联系<br>表示了系统与外部系统之间的联系，用实线表示</p></li></ul></details></markdown><markdown><details> <summary><center>目标2: 活动图(Activity Diagram)编写</center></summary><p>结构如下：</p><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-02-11-09-17.png"></p><p>好吧结构有点多，看一下图例吧：</p><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-02-11-11-05.png"></p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul><li>初始节点(Initial Node)<br>实心黑点，表示执行活动的起点</li><li>分支节点(Decision Node)<strong>异步</strong><br>菱形，一进二出。会因为真或假(比如接受或拒绝)产生两个分支，两个分支流向不同的结果</li><li>合并节点(Merge Node)<strong>异步</strong><br>菱形，多进一出。可以在不同步的情况下将多个流聚集在一起</li><li>分叉节点(Fork Node)<strong>同步</strong><br>长条，一进多出。并行操作的分支起始，从分叉节点可以开启多个并行操作</li><li>汇合节点(Join Node)<strong>同步</strong><br>长条，多进一出。可以在同步的情况下将多个流聚集在一起</li><li>对象节点(Object Node)<br>矩形框，上面有&lt;&lt;&gt;&gt;表示的对象类型，比如数据存储(datastore)、系统(system)等等</li><li>终止节点(Final Node)<br>实心黑点外面还有一个圆圈，表示活动的终点</li></ul><h3 id="关于分支合并（Decision-and-Merge-Nodes）与分叉汇合（Fork-and-Join-Nodes）"><a href="#关于分支合并（Decision-and-Merge-Nodes）与分叉汇合（Fork-and-Join-Nodes）" class="headerlink" title="关于分支合并（Decision and Merge Nodes）与分叉汇合（Fork and Join Nodes）"></a>关于分支合并（Decision and Merge Nodes）与分叉汇合（Fork and Join Nodes）</h3><p>这两个东西有点像，在上面的描述大概是同步和异步之间的区别</p><ul><li>分支同步：处理决策，决策的的结束不一定(或者说极小概率也行)是同步结束的，所以说它的异步的</li><li>分叉汇合：对象在运行时可能会存在两个或多个<strong>并发运行的控制流</strong>，为了对并发的控制流建模，UML中引入了分叉与汇合的概念。分叉用于将动作流分为两个或多个并发运行的分支，而汇合则用于<strong>同步</strong>这些并发分支，以达到共同完成一项事务的目的</li></ul></details></markdown><details>  <summary><center>目标3: 包图(Package Diagram)编写</center></summary>  <markdown><p>结构如下：</p><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-02-13-21-49.png"></p><h3 id="什么是包-Package"><a href="#什么是包-Package" class="headerlink" title="什么是包(Package)"></a>什么是包(Package)</h3><p>包被认为是其成员的名称空间，在java中是package，在C#中相对于namespace</p><h3 id="包图的作用"><a href="#包图的作用" class="headerlink" title="包图的作用"></a>包图的作用</h3><ul><li>当执行分析时，包图被用来组织开发的工件</li><li>提供封装和包容，并支持模块化</li><li>在复杂的系统开发中提供清晰和整洁的组织</li><li>支持版本控制<h3 id="图样"><a href="#图样" class="headerlink" title="图样"></a>图样</h3></li></ul><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-02-13-20-14.png"></p><p>上面有两种关系，从属(Dependency)与控制(Containment)。从属表示一个包在没有另一个包的情况下无法正常运行；控制表示一个包需要另一个包才能工作<br></p></markdown><p></p></details><details> <summary><center>目标4: 部署图(Deployment Diagram)编写</center></summary>  <markdown><p>结构如下：</p><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-02-13-24-39.png"></p><p>由六部分组成</p><ul><li>节点<br>表示硬件或者软件运行环境的元素</li><li>工件<br>上面有&lt;&lt;artifact&gt;&gt;标记，代表了物理世界中由软件开发过程或系统操作所使用或产生的一些具体元素。如可执行文件、源文件、数据库表、文档或消息等</li><li>设备<br>节点的子类型，上面有&lt;&lt;device&gt;&gt;标记。它被用来表示具有处理能力的物理计算资源，工件可以在其上部署以供执行。</li><li>通讯路径<br>用实线表示，是两个部署目标之间的一种关联类型，它们可以通过它交换信息</li><li>运行环境<br>节点的子类型，上面有&lt;&lt;excutionEnvironment&gt;&gt;标记，被用来表示一些支持工件执行的环境(主要是软件)。运行环境通常分配给设备或节点。例如，应用服务器、操作系统或数据库等</li><li>部署规范<br>上面有&lt;&lt;deployment spec&gt;&gt;标记部署规范指定了部署在节点上的工件的一组属性</li></ul></markdown></details><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ul><li>对一个已经存在的系统<br>帮助阐明现有系统做什么，以明确系统的优缺点。</li><li>对于一个新系统（还不存在的，准备开发的系统）<br>有助于解释需求，让需求更明确、有助于写出系统文档</li></ul><h2 id="系统建模四要素"><a href="#系统建模四要素" class="headerlink" title="系统建模四要素"></a>系统建模四要素</h2><ul><li><p>外部External:系统所处的外部环境和“上下文”（意思是系统的工作，比如说用了第三方接口，或者第三方服务，比如说用了百度地图服务，天气预报接口。运行的环境不只有自己，还有别的外部（external）工具，这就叫外部环境）</p><blockquote><p>使用Context Model与Business Model(就是活动图)来实现（见本节课目标）</p></blockquote></li><li><p>交互Interaction:系统与环境/与用户之间的交互，或是系统内部部件与部件之间的交互（比如说这个方法，调用了那个方法，方法就是内部的“部件”）</p><blockquote><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-06-22-46-38.png"></p></blockquote></li><li><p>结构Structural:系统的结构，或者系统要处理的数据的结构</p><blockquote><p>根据组件的功能，和他们的关系来建模；用于设计系统的整体架构；它使用Class Diagram来建模</p></blockquote></li><li><p>行为Behavioral: runtime  behavior就是系统运行过程中，如何对外界作出响应</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>模型(model)是系统的抽象视图，它故意忽略了一些系统细节</li><li><strong>上下文图</strong> 上下文模型(context model)显示了系统在操作环境中的位置。它有助于定义系统的边界</li></ul><p><strong>UML没有专门为上下文模型提供的图表！！！</strong></p><blockquote><p>•在需求工程的早期阶段创建<br>•了解并确定正在开发的系统的边界<br>•在没有细节的情况下，建立系统和运行环境之间交互的高层视图。<br>•使用简单的块图或空的类图</p></blockquote><ul><li><p><strong>活动图</strong> 商业处理模型<br>与商业业务有关的建模</p><blockquote><p>•建模业务流程<br>•描述系统在特定的业务流程中是如何被涉及的<br>•使用活动图或专用的业务流程模型和符号(BPMN)</p></blockquote></li><li><p><strong>用例图</strong> 描述外部参与者和要开发的系统之间的交互序列图用于显示系统对象之间的交互</p></li><li><p><strong>类图</strong> 定义系统的类及其关系的静态结构</p></li><li><p><strong>包图</strong> 用于组织开发过程的工件</p></li><li><p><strong>部署图</strong> 用于显示组件对物理节点的分配</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件工程与软件过程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>L4-需求工程</title>
      <link href="/2021/03/19/L4-%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/"/>
      <url>/2021/03/19/L4-%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="L4-需求工程"><a href="#L4-需求工程" class="headerlink" title="L4-需求工程"></a>L4-需求工程</h1><markdown>  <details>    <summary><center>目标: 用例图(Use-Case Diagram)编写</center></summary><p>结构如下：</p><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-04-11-16-33-39.png"></p><h3 id="基本构成"><a href="#基本构成" class="headerlink" title="基本构成"></a>基本构成</h3><p>由五个部分组成</p><ul><li>包边界<br>大的项目边界，包含了用例、角色和主题</li><li>角色(小人+底下的角色名)<br>是所有可能与这个系统交互的人或系统</li><li>主体边界<br>显示的是被考虑的主体的边界。边界内的是所有该系统包含的用例</li><li>用例<br>用例指定主体可以是一个或多个角色<br>用例的外观是一个椭圆，定义了主体的行为而不去考虑其内部结构，指定了主体提供给用户的有用功能的一个单元</li><li>联系<br>角色与样例之间的联系，用实线表示</li></ul><h3 id="用例图的扩展"><a href="#用例图的扩展" class="headerlink" title="用例图的扩展"></a>用例图的扩展</h3><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-06-22-44-22.png"><br>use case不够用，有其他use case要加入，就extend,注意辨析extending use case和extended use case的先后关系（上面图里有)</p><h3 id="用例图的包含"><a href="#用例图的包含" class="headerlink" title="用例图的包含"></a>用例图的包含</h3><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-06-22-45-50.png"></p></details></markdown><h2 id="概念性定义"><a href="#概念性定义" class="headerlink" title="概念性定义"></a>概念性定义</h2><h3 id="需求工程"><a href="#需求工程" class="headerlink" title="需求工程"></a>需求工程</h3><p>发现、分析、记录和检查软件系统的服务和约束的过程称为需求工程(RE)</p><blockquote><p>The process of finding out, analyzing, documenting and checking the services and constraints of a software system is called requirements engineering (RE</p></blockquote><h3 id="利益相关者"><a href="#利益相关者" class="headerlink" title="利益相关者"></a>利益相关者</h3><p>利益相关者是与系统成功有利害关系的任何人:客户、最终用户、开发人员、项目经理、维护人员，甚至是那些营销系统的人</p><blockquote><p>A stakeholder is anyone who has a stake in the success of the system: the customer, the end users, the developers, the project manager, the maintainers, and even those who markets the system for example</p></blockquote><p>其中，还存在潜在利益相关者这一概念</p><h2 id="需求工程过程"><a href="#需求工程过程" class="headerlink" title="需求工程过程"></a>需求工程过程</h2><p>总体来说，需求工程可以划分为以下三个阶段</p><h2 id="需求抽出与分析"><a href="#需求抽出与分析" class="headerlink" title="需求抽出与分析"></a><font color="red">需求抽出与分析</font></h2><p>与涉众交互，发现用户和系统需求<br>评估项目的可行性+必要时做一个雏形（prototype）+审查要求</p><h3 id="需求抽出"><a href="#需求抽出" class="headerlink" title="需求抽出"></a>需求抽出</h3><ul><li>理解项目的方方面面</li><li>确定要做的工作</li><li>确定为这次项目提供功能性服务的部件（比如类，接口，方法等）</li><li>确定系统特性</li><li>确定限制因素（如：必须用MySQl做数据库，预算限制等）</li><li>确定系统的环境</li><li>确定新系统如何使用，如何帮助用户</li></ul><h3 id="需求分析模型"><a href="#需求分析模型" class="headerlink" title="需求分析模型"></a>需求分析模型</h3><ul><li>确定宏观需求和技术性需求</li><li>把需求细分为小需求，把可以一起搞的小需求放一组</li><li>确定不同需求实现的优先次序</li><li>做文档</li></ul><h3 id="领域需求"><a href="#领域需求" class="headerlink" title="领域需求"></a>领域需求</h3><p>由技术层、应用层得出，而不是由用户得出。因为不同的用户或利益相关者不知道他们确切想从计算机中得到什么，他们只会用自己贴近生活的语言描述，都是需要从技术层出发进行一次抽象，从现实生活到计算机能做到的需求的一次抽象</p><h3 id="由需求得出的三步走"><a href="#由需求得出的三步走" class="headerlink" title="由需求得出的三步走"></a>由需求得出的三步走</h3><h4 id="采访"><a href="#采访" class="headerlink" title="采访"></a><strong>采访</strong></h4><p> 在这一阶段，开发人员可以进行<strong>采访</strong>这一活动，以获得相关信息，比如“我要做什么”<br>访谈可以分为两种形式: </p><ol><li>开放式访谈，不预先准备问题，完全由利益相关者拿捏</li><li>封闭式访谈，预先准备一组问题，比如“你将使用这个项目来做什么工作流”一类的</li></ol><h4 id="民族志-这是什么"><a href="#民族志-这是什么" class="headerlink" title="民族志(???这是什么"></a><strong>民族志</strong>(???这是什么</h4><p> 总的来说，民族志是一种观察技术，可以用来理解操作过程，并帮助导出支持这些过程的软件需求<br> 比如说：你要写一个搬砖机器人的软件，你就要自己去搬砖，来观察搬砖操作流程，来知道软件具体要做什么，可以更好的提出需求</p><ol><li>让自己沉浸在搬砖的工作环境中</li><li>观察每天的搬砖工作并做笔记</li><li>发现人们实际上是如何搬砖的，而不是预定义的(标准的)业务流程</li><li>发现搬砖机器人系统的隐含需求</li></ol><h4 id="用户故事-Stories-与用户情节-Scenarios"><a href="#用户故事-Stories-与用户情节-Scenarios" class="headerlink" title="用户故事(Stories)与用户情节(Scenarios)"></a><strong>用户故事(Stories)与用户情节(Scenarios)</strong></h4><ul><li>Stories:叙事性描述，描述了系统的使用，描述了系统大致的架构。</li><li>Scenarios:在story的基础上，更细化，把里面的信息更结构化，、<blockquote><p>比如，stories只说了：用户打开电视，看到了视频。<br>Scenario则更加细化地说：开关按钮传入高电平信号到主板，系统分析后传出哪一个频道的图像信号，比Stories更加细化，结构化。</p></blockquote></li></ul><p>用户故事：设想一个人在使用你的软件。他的目的是什么？希望通过这个软件获得什么？可以写成有故事场景的记叙文(有点类似UI课)，主要囊括以下几个细节：</p><ol><li>描述系统如何用于某些特定的任务</li><li>描述人们做什么以及他们如何与系统交互</li><li>描述他们使用和生产什么信息</li><li>描述他们在这个过程中可能使用什么系统<details><summary>用户需求与系统需求</summary><markdown>### 用户需求</markdown></details></li></ol><ul><li>通常用图表用自然语言编写抽象声明的服务,系统应该提供或约束系统</li><li>通常是为非技术人员编写的<h3 id="系统需求"><a href="#系统需求" class="headerlink" title="系统需求"></a>系统需求</h3></li><li>详细描述软件系统的服务和操作约束</li><li>定义具体要实现的内容</li><li>它可能是系统投资者和软件之间的合同的一部分</li><li>通常是为技术人员编写的</li></ul><details>  <summary>功能需求与非功能需求</summary>  <markdown><h3 id="功能需求"><a href="#功能需求" class="headerlink" title="功能需求"></a>功能需求</h3><ul><li>表现为系统所需要实现的功能</li><li>根据要开发的系统的性质，重点可能会转移到系统的其他方面<blockquote><p>规定开发人员必须在产品中实现的软件功能，用户利用这些功能来完成任务，满足业务需求。功能需求有时也被称作行为需求 （behavīoral requirement），因为习惯上总是用“应该”对其进行描述：“系统应该发送电子邮件来通知用户已接受其预定”。功能需求描述是开发人员需要实现什 么。注意：用户需求不总是被转变成功能需求。产品特性，所谓特性（feature），是指一组逻辑上相关的功能需求，它们为用户提供某项功能，使业务目标 得以满足。对商业软件而言，特性则是一组能被客户识别，并帮助他决定是否购买的需求，也就是产品说明书中用着重号标明的部分。客户希望得到的产品特性和用 户的任务相关的需求不完全是一回事。一项特性可以包括多个用例，每个用例又要求实现多项功能需求，以便用户能够执行某项任务</p></blockquote></li></ul><h3 id="非功能需求"><a href="#非功能需求" class="headerlink" title="非功能需求"></a>非功能需求</h3><ul><li>将系统的特性作为一个整体来指定</li><li>非功能性需求比单独的功能性需求更重要</li><li>更难实现</li><li>具体表现在运行速度、安全性、可靠性、扩展性等等方面<blockquote><p>指依一些条件判断系统运作情形或其特性，而不是针对系统特定行为的需求。包括安全性、可靠性、互操作性、健壮性、易使用性、可维护性、可移植性、可重用性、可扩充性</p></blockquote></li></ul><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p>非功能性需求主要有三种：</p><ul><li><p>产品需求-指定或约束软件的运行时行为<br>  可用性、安全性、效率、独立性</p>  <img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedane20210629154933.png" width="450px/">  </li><li><p>组织需求-来自客户和开发人员组织的政策和程序的广泛系统需求</p><p>   组织的愿景、目标、目标和优先事项。<br>   业务和绩效计划。<br>   质量保证的系统、过程和要求。<br>   具体的变更计划。</p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedane20210629155105.png" width="450px/"></li><li><p>额外需求-源于系统的外部因素及其发展过程<br>  监管、法律、伦理、隐私等等</p>  <img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedane20210629155333.png" width="450px/"></li></ul><h4 id="可测量的非功能性需求"><a href="#可测量的非功能性需求" class="headerlink" title="可测量的非功能性需求"></a>可测量的非功能性需求</h4><p>非功能性需求的用户故事可以抽象成以下流程(质量属性场景，Quality Attribute Scenarios)：<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedane20210629133435.png"><br>刺激源 –传递刺激–&gt; 工件(环境) –反馈–&gt; 应对措施</p><ul><li><p>刺激源(Source of stimulus)：产生刺激的实体(人、计算机系统或任何其他执行器)</p></li><li><p>刺激（stimulus）：类似于一种输入或者事件，当它发生时，系统需要响应</p></li><li><p>环境（Environment）：在什么情况下，使用与应对刺激</p></li><li><p>工件（Artifact）：来应对刺激的东西</p></li><li><p>响应（response）：作为刺激到来的结果而进行的活动</p></li><li><p>反应测量（Response measure）：当响应发生时，它应该在某些方面是可测量的，以便对需求进行测试。<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedane20210629133625.png"></p></li></ul></markdown></details><details>  <summary>效用树(Utility Tree)</summary>  <markdown><h3 id="什么是效用树"><a href="#什么是效用树" class="headerlink" title="什么是效用树"></a>什么是效用树</h3><p>一种判断非功能性需求优先级的树，以确定在不惹利益相关者生气的情况下(?)率先实现哪些需求</p><h3 id="搭建效用树"><a href="#搭建效用树" class="headerlink" title="搭建效用树"></a>搭建效用树</h3><ul><li>根节点(2333)是被称作Utility的占位符标签</li><li>根节点的子节点，也就是树的第二层包含广泛的质量属性类别</li><li>树的第三个层次精炼了这些类别，把大类细分化小</li><li>需求被捕获为场景，装进用户故事<br>每个场景都由系统买家和架构师进行评级，级别分别为低(L)、中(M)或高(H)。•具有(H,H)评级的场景是最值得关注的场景</li></ul><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-04-11-16-20-43.png"></p>  </markdown></details><details>  <summary>可行性分析(Feasibility Study)</summary>  <markdown><p>主要分为两块：</p><h3 id="商业可行性分析"><a href="#商业可行性分析" class="headerlink" title="商业可行性分析"></a>商业可行性分析</h3><ul><li><p>运行可行性<br>拟议的系统将如何影响组织结构、工作程序和人员</p></li><li><p>经济可行性<br>评估项目的成本和收益，也被称作<strong>成本-收益分析(cost-benifit analysis)</strong></p><h3 id="技术可行性分析"><a href="#技术可行性分析" class="headerlink" title="技术可行性分析"></a>技术可行性分析</h3></li><li><p>技术可行性<br>评估所提议的技术解决方案的实用性以及技术技能、专门知识和资源的可用性</p></li><li><p>计划可行性<br>研究是否能在规定的时间内按时完成</p></li></ul></markdown></details><h2 id="需求规范"><a href="#需求规范" class="headerlink" title="需求规范"></a><font color="red">需求规范</font></h2><p>将需求转换为标准形式(系统、用户、商业)<br>主要有三个规范方式</p><ul><li>结构化自然语言(Structured Natural Language)<br>列一个很漂亮的表格，比如大鹏在lab2中提供的用户故事表，里面详细列出了该用户故事所要拎出来的重点：</li></ul><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-04-11-16-30-39.png"></p><p>结构化自然语言的要点：清晰、没有歧义、不要让人听不懂</p><ul><li>图形标记(Graphical Notation )<br>就是UML的用例图<br>人物(使用者，也被称作Actor)、他所能做的操作(UseCase，放到不同圈圈里了)、连线(Association，连接角色和他能做的事)</li></ul><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-04-11-16-33-39.png"></p><ul><li>数学规范<br>有限状态机？课件上给的例子是这个<br>状态和转移<br>从一个状态到下一个所需要的条件、执行的操作等等</li></ul><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-04-11-16-37-37.png"></p><h2 id="需求验证"><a href="#需求验证" class="headerlink" title="需求验证"></a><font color="red">需求验证</font></h2><p>评估项目的可行性;如有需要，建立<strong>原型</strong>; 评审需求</p><h3 id="领域需求-1"><a href="#领域需求-1" class="headerlink" title="领域需求"></a>领域需求</h3><p>领域需求来自于系统的应用领域，而不是来自于系统用户的特定需求</p><blockquote><p>Domain requirements are derived from the application domain of the system rather than from the specific needs of system users</p></blockquote><h4 id="检测方面"><a href="#检测方面" class="headerlink" title="检测方面"></a>检测方面</h4><ul><li>有效性检查<br>需求是否反映了系统用户的真实需求</li><li>一致性检查<br>识别冲突和混乱需求</li><li>完整性检查<br>文档化的需求是否定义了所有的功能和约束</li><li>现实检查<br>软件系统是否可以在建议的预算范围内实现或由现有技术支持</li><li>可验证性<br>功能和质量属性是否可验证</li></ul><h4 id="检测方法"><a href="#检测方法" class="headerlink" title="检测方法"></a>检测方法</h4><ul><li>测试用例(软件测试)<br>为有挑战性的需求实现测试用例</li><li>原型<br>开发系统的可执行模型</li><li>评审<br>分为内部评审和外部评审</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件工程与软件过程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>L3-敏捷开发</title>
      <link href="/2021/03/18/L3-%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/"/>
      <url>/2021/03/18/L3-%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="L3-敏捷开发"><a href="#L3-敏捷开发" class="headerlink" title="L3-敏捷开发"></a>L3-敏捷开发</h1><markdown><details><summary><center>目标: 用户故事(User Story)编写</center></summary><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>用户故事是系统用户可能经历的使用场景</p><blockquote><p> a user story is a scenario of use that might be experienced by a system user</p></blockquote><h3 id="编写原则与格式"><a href="#编写原则与格式" class="headerlink" title="编写原则与格式"></a>编写原则与格式</h3><ul><li>(Who)作为一个角色(比如患者、总裁)</li><li>(Why)我想要(使用该软件的某个功能)…这样我就可以(达成某个想要实现的目标)…</li><li>用户故事还可能包括验收标准和意见</li></ul></details></markdown><h2 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a>敏捷开发</h2><blockquote><p>敏捷开发是目前最主流的软件开发方法<br>主要的两种敏捷开发模式：XP(极限开发)与Scrum</p></blockquote><h3 id="敏捷开发宣言"><a href="#敏捷开发宣言" class="headerlink" title="敏捷开发宣言"></a>敏捷开发宣言</h3><ul><li>个人和交互胜过过程和工具</li><li>工作软件胜过全面文档</li><li>客户协作胜于合同谈判</li><li>响应变化而不是遵循计划<h3 id="敏捷开发原则"><a href="#敏捷开发原则" class="headerlink" title="敏捷开发原则"></a>敏捷开发原则</h3></li><li>客户协助<br>用户应该与开发团队密切合作<br>用户应对系统进行反馈，并提出需求/改进建议</li><li>拥抱变革<br>对需求的更改可以在开发过程中的任何时候发生<br>随着需求的快速变化，计划可能很快变得不准确</li><li>增量提交<br>交付软件比遵循计划更重要<br>软件应该以增量和迭代的方式开发，每次交付都包含更多的功能</li><li>维护简单<br>对于软件和软件过程，保持一切简单<br>专注于向客户交付有价值的软件，而不是编写全面的文档</li><li>面向用户而非面向过程<br>关注团队中的人。工具和实践是第二<br>人们应该去发展他们自己的工作方式，而不是给予指令性的过程<br>发掘和探索团队成员的技能和知识，并信任他们</li></ul><ol><li>最重要的是通过尽早和不断交付有价值的软件满足客户需要。</li><li>我们欢迎需求的变化，即使在开发后期。敏捷过程能够驾驭变化，保持客户的竞争优势。</li><li>经常交付可以工作的软件，从几星期到几个月，时间尺度越短越好。</li><li>业务人员和开发者应该在整个项目过程中始终朝夕在一起工作。</li><li>围绕斗志高昂的人进行软件开发，给开发者提供适宜的环境，满足他们的需要，并相信他们能够完成任务。</li><li>在开发小组中最有效率也最有效果的信息传达方式是面对面的交谈。</li><li>可以工作的软件是进度的主要度量标准。</li><li>敏捷过程提倡可持续的开发速度。出资人、开发人员和用户应该保持长期，恒定的节奏。</li><li>对卓越技术与良好设计的不断追求将有助于提高敏捷性。</li><li>简单至关重要。</li><li>最好的架构、需求和设计都源自自我组织的团队。</li><li>每隔一定时间，团队都要反省，总结如何更有效率，然后相应地调整自己的行为。</li></ol><hr><h3 id="极限开发-XP"><a href="#极限开发-XP" class="headerlink" title="极限开发(XP)"></a><center>极限开发(XP)</center></h3><hr><blockquote><p>“XP is a style of software development focusing on excellent application of programming techniques, clear communication, and teamwork…”<br><strong>XP是一种专注于编程技术的优秀应用、清晰沟通和团队合作的软件开发风格……</strong></p></blockquote><h4 id="XP14大原则"><a href="#XP14大原则" class="headerlink" title="XP14大原则"></a>XP14大原则</h4><ul><li>关注成员<br>平衡团队需求和个人需求</li><li>关注价值<br>时间价值和系统和团队的期权价值</li><li>互惠互利<br>每一项活动都应使有关各方受益<br>编写自动化测试，帮助设计和实现更好的今天;把测试作为“文档”留给未来的程序员</li></ul><p><strong>别搞内部文档，好东西要分享，这是开源运动的核心原则之一</strong><br>重构以提高简洁性、清晰度和连贯性</p><ul><li>自相似性<br>将一个解决方案的结构运用到一个新的环境中，即使是在不同的尺度上</li><li>改进<br>立即开始一项活动，然后随着时间的推移改进结果</li><li>多样性<br>程序员应该一起解决问题，所有的意见都应该得到重视</li><li>反射<br>重温并分析为什么会导致成功/失败</li><li>活动流<br>持续的活动流而不是离散的阶段(小的增量，持续的集成)</li><li>机遇<br>将遇到的问题视作改变的机遇，有助于个人成长、加深关系、改进软件</li><li>冗余</li></ul><p><strong>软件开发中的困难问题应该用几种不同的方法来解决</strong></p><ul><li>失败<br>如果您有三种方法来实现<strong>user story</strong>，但您不知道该使用哪一种，那么尝试所有的方法</li><li>质量<br>质量可以通过缺陷、设计质量和开发经验来衡量</li><li>小的一步<br>每次进行一个测试，并一次集成和测试几个小时的更改</li><li>职责<br>无法指定责任，它<strong>只能被接受</strong><h3 id="XP工作流"><a href="#XP工作流" class="headerlink" title="XP工作流"></a>XP工作流</h3></li></ul><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-01-15-31-28.png"></p><ol><li>开启项目，编写user story<br>在项目开发的开始，产品经理和用户编写故事(程序员也可能参与)</li><li>估计故事和任务<br>如果story太大，产品经理可以将user story进行分割<br>如果程序员不理解主题，user story前将加上首字母大写的单词“Spike”</li><li>周期主题(冲刺目标)<br>产品经理和/或用户决定季度周期的“主题”(大画面)实现，直到整个项目完成</li><li>选定user story<br>产品经理/用户/程序员为每周主题选定合理数量的用户故事，并添加一些stack<br>迭代直到项目开发完成</li></ol><h4 id="XP流程中程序员的工作流"><a href="#XP流程中程序员的工作流" class="headerlink" title="XP流程中程序员的工作流"></a>XP流程中程序员的工作流</h4><p>日常临时会议：确定面临的问题以及解决方案<br>与同事配对，并进行快速设计（XP要求程序员两两配对一起写代码，会定期切换任务，你做他的他做你的）<br>测试：写每个小模块的单元测试<br>写代码，写能通过单元测试的代码。如果对需求有疑问，问用户去<br>重构：代码应通过所有单元测试，没有重复逻辑，确保良好的编码规范<br>问答：软件系统的用户应在现场回答问题，来帮助程序员更好地开发。用户和产品经理都能够做出决策。<br>整合各个部分，并通过系统测试<br>丢弃：丢掉不能用的部分<br>结束</p><hr><h3 id="Scrum框架"><a href="#Scrum框架" class="headerlink" title="Scrum框架"></a><center>Scrum框架</center></h3><hr><p>Scrum是一个软件开发的框架。在这个框架中，人们可以解决复杂的适应性问题，同时富有生产力和创造性地交付最高可能价值的产品</p><blockquote><p>A framework within which people can address complex adaptive problems, while productively and creatively delivering products of the highest possible value</p></blockquote><h4 id="Scrum框架-1"><a href="#Scrum框架-1" class="headerlink" title="Scrum框架"></a>Scrum框架</h4><ul><li>价值观<br>Scrum团队成员通过Scrum角色、事件和工件学习和探索承诺、勇气、专注、开放和尊重的价值</li><li>原则<br>将所有组件绑定在一起</li><li>团队<br>一个典型的Scrum团队包括一个产品负责人、一个开发团队和一个Scrum管理员</li><li>事件<br>对于所有Scrum团队来说，有四种正式的活动是共同的: Sprint(冲刺)计划、每日Scrum、Sprint复习和Sprint回顾</li><li>产品<br>产品待办事项、冲刺待办事项、投资组合待办事项、计划待办事项</li></ul><h4 id="Scrum工作流"><a href="#Scrum工作流" class="headerlink" title="Scrum工作流"></a>Scrum工作流</h4><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-01-15-30-52.png"></p><ul><li><p>愿景(Vision)<br>在这一阶段确定要实现的功能和目标等</p></li><li><p>产品待办事项列表管理人(Product Backlog Management)<br>产品负责人管理产品待办事项列表，也就是产品<strong>待定项</strong>、<strong>可用性</strong>和<strong>订购</strong><br>开发团队负责所有的评估，但是*<strong>所有的变更必须由产品所有者进行</strong></p></li></ul><p>什么是产品待办事项列表?</p><blockquote><p>所有特性、功能、增强和修复<br>这些建议可能会在评审、sprint评审或回顾之后从用户那里得到<br>这个列表是不断变化的，因为需求可能一直在改变。应该按照优先级排序，并给出一个值判断其实现与否</p></blockquote><ul><li>迭代计划(Sprint Planning)<br>整个Scrum团队共同为迭代工作创建一个计划，产品负责人给出了此迭代的目标，开发团队从产品待办事项列表中选择项目(没有人告诉团队该做什么)</li></ul><p>Sprint Backlog</p><blockquote><p>“Sprint Backlog是为Sprint选择的一组产品Backlog项，以及交付产品增量和实现Sprint目标的计划。”<br>选择Sprint Backlog中的条目来满足Sprint目标。sprint Backlog应该至少包含一个在前一个sprint的回顾会议中确定的高优先级的过程改进。Sprint Backlog中的计划应该有足够的细节来指导Daily Scrum<br>Sprint Backlog中的项目可以更改，但只能由开发团队更改Sprint Backlog可以用来监控Sprint进程。</p></blockquote><ul><li><p>冲刺回顾(Sprint Review)<br>Scrum团队和相关的涉众评审已经完成的工作<br>Scrum Master负责组织会议产品负责人解释已经做了什么和什么还没有做<br><strong>目的</strong><br>回顾时间线、预算和潜在能力回顾一下下一步最有价值的事情是什么<br>讨论产品待办事项列表的状态演示完成的工作并回答问题</p></li><li><p>冲刺回溯(Sprint Retrospective)<br>Scrum Master负责组织会议<br>Scrum Master鼓励团队进行改进<br>Scrum团队成员计划如何提高产品质量</p></li></ul><p><strong>目的</strong><br>检查上一次Sprint在人员、关系、过程和工具方面的进展情况，确定潜在的改进制定一个实施<strong>改进</strong>的计划</p><h4 id="Scrum角色"><a href="#Scrum角色" class="headerlink" title="Scrum角色"></a>Scrum角色</h4><p><strong>Scrum主持人(Scrum Master)</strong><br><em>职责</em></p><ul><li>帮助团队理解项目</li><li>促进事件</li><li>指导开发团队使用Scrum</li><li>消除障碍</li><li>规划Scrum实现</li><li>帮助产品负责人<blockquote><p>• Helping the team to understand the project<br>• Facilitating events<br>• Coaching the Development Team for Scrum<br>• Removing impediments<br>• Planning Scrum implementations<br>• Helping the Product Owner</p></blockquote></li></ul><p><strong>产品所有者(Product Owner)</strong><br>提出产品需求的人，或者说甲方</p><p><strong>开发团队(Development Team)</strong><br>咱，打工人罢了</p><hr><h3 id="XP与Scrum的区别"><a href="#XP与Scrum的区别" class="headerlink" title="XP与Scrum的区别"></a><center>XP与Scrum的区别</center></h3><hr><h4 id="四大不同点"><a href="#四大不同点" class="headerlink" title="四大不同点"></a>四大不同点</h4><ul><li>迭代长度不同<br>XP的一个迭代周期为1~2周，而Scrum则是2~4周</li><li>修改要求<br>在迭代过程中，Scrum不允许替换未能实现的User Story。而XP在一个迭代中，如果一个User Story还没有实现，则可以考虑用另外的需求将其替换，替换的原则是需求实现的时间量是相等的</li><li>User Story优先级<br>XP的实现必须遵守User Story的优先级，但是Scrum在这点上很灵活，因为在实现上可能存在依赖性的问题</li><li>是否采用严格的工程方法以保证进度或者质量<br>Scrum没有对软件的整个实施过程开出养个工程实践的处方，要求开发者自觉保证<br>而XP对整个流程方法定义非常严格，规定需要采用TDD,自动测试，结对编程，简单设计，重构等约束团队的行为</li></ul><p>不难发现，这四个区别显见的是：Scrum非常突出自我管理,而XP注重强有力的工程实践约束</p><h3 id="敏捷开发的问题"><a href="#敏捷开发的问题" class="headerlink" title="敏捷开发的问题"></a>敏捷开发的问题</h3><p>敏捷方法可能不适合嵌入式系统工程或大型复杂系统的开发</p><ul><li>敏捷的非正式性与大企业中常用的法律方法是不相容的(合同问题)</li><li>敏捷通常用于新软件系统开发，而不是软件维护</li><li>敏捷方法是为位于同一地点的小型团队设计的。对于具有多个地理分布的团队的大型项目，管理和协调的复杂性显著增加，因此敏捷方法的有效性变得可疑</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件工程与软件过程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>L2-软件过程</title>
      <link href="/2021/03/17/L2-%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B/"/>
      <url>/2021/03/17/L2-%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="L2-软件过程"><a href="#L2-软件过程" class="headerlink" title="L2-软件过程"></a>L2-软件过程</h1><markdown><details><summary><center>目标: 类图(Class Diagram)编写</center></summary><p>结构如下：</p><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-02-09-56-57.png?token=APFFA5ID65ZB3QUI2NVLA5TAZBIZW"><br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-02-10-30-38.png?token=APFFA5MHGUU2RLKM7NOWI5TAZBIZ4"></p><p>由三个结构组成：类名(位于1层)、变量名(位于2层)、方法(位于3层)</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li>公有变量<br>-变量名 : 类型</li><li> 保护变量<br>#变量名 : 类型</li><li> 私有变量</li></ul><p>+变量名 : 类型</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>-/#/+方法名(输入参数in : 类型，或者没有) : 返回值(没有就不写)</p><h3 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h3><p>抽象类跟类长得差不多，接口需要在1层上写&lt;&lt;interface&gt;&gt;</p><h3 id="类间关系"><a href="#类间关系" class="headerlink" title="类间关系"></a>类间关系</h3><p><a href="https://blog.csdn.net/K346K346/article/details/59582926">https://blog.csdn.net/K346K346/article/details/59582926</a></p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedane20210629214143.png" style="float:right; " width="200px;/"><ul><li><p>继承(Generalization)<br>由子类指向父类</p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedane20210629214253.png" style="float:right; " width="200px;/"></li><li><p>实现(Realization)<br>比如接口的方法被实现，由实现方指向接口</p></li></ul><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedane20210629214334.png" style="float:right; " width="200px;/"><ul><li><p>依赖(Dependency)<br>指的是使用另一个类的对象作为 返回值或输入值</p></li><li><p>关联、聚合与组合(Association, Aggregation and Composition)<br>组合相较于聚合更广，而聚合相较于关联更广</p></li></ul><blockquote><p>关联(Association)表示系统中对象之间的连接或关联，如学生与老师。他的依赖程度比依赖关系要强，比如学生可以没有电脑（虽然会导致部分以电脑为参数或者返回电脑的方法无法使用），但是学生不能没有老师（类A成为类B的属性(或者说变量)，而属性是一种更为紧密的耦合，更为长久的持有关系）</p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedane20210629214410.png"></blockquote><blockquote><p>聚合(Aggregation)是关联关系的一个子类型。它可以被描述为一种关系的“一部分(成员变量)”，如学生和班级。在聚合关系中，对象有独立的生命周期，使用者知道两个对象的存在</p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedane20210629214502.png"></blockquote><blockquote><p>组合(Composition)是聚合关系的一个子类型。它代表了一种“整体/部分”关系(在构造函数中实例化)，如学生和他的心。二者生命周期相同，存在一种封装关系，如果一个组合被删除，那么它的所有相关部分也将随之被删除</p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedane20210629214527.png"></blockquote></details></markdown><h2 id="瀑布流模型-Waterfall-Model"><a href="#瀑布流模型-Waterfall-Model" class="headerlink" title="瀑布流模型(Waterfall Model)"></a>瀑布流模型(Waterfall Model)</h2><h3 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h3><p><strong>需求/定义 - 系统/软件设计 - 实现/单元测试 - 集成/系统测试 - 使用操作/维护</strong></p><blockquote><p>收集信息、需要实现的功能，分析是否可行，创建规格<br>将需求分配给硬件或软件系统，建立一个整体的系统架构<br>具体实现与单元测试<br>集成后进行系统测试；测试完之后即可交付用户<br>投入使用；后期维护与更新</p></blockquote><ul><li>最早发布的软件开发过程</li><li>源自大型军事系统工程中的工程流程<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3>适合：嵌入式系统、关键系统（对安全性要求高）、大型软件系统<br>不适合：必须应对变化的软件<br>原因：瀑布流模型充满了单向性，它使得变化难以发生</li></ul><h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p align="center"><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/imagesCS335-1.png"></p><h2 id="V模型-V-Model"><a href="#V模型-V-Model" class="headerlink" title="V模型(V-Model)"></a>V模型(V-Model)</h2><h3 id="核心思想与特点"><a href="#核心思想与特点" class="headerlink" title="核心思想与特点"></a>核心思想与特点</h3><p><strong>特点</strong>：简单、易于管理<br><strong>核心思想</strong>：鼓励在所有阶段进行测试，认为开发和测试同等重要</p><h3 id="图示-1"><a href="#图示-1" class="headerlink" title="图示"></a>图示</h3><p align="center"><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/imagesCS335-2.png"></p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>不适合需求经常变更的软件项目</li><li>对时间跨度长，复杂的面对对象程序也不合适</li></ul><h2 id="增量开发"><a href="#增量开发" class="headerlink" title="增量开发"></a>增量开发</h2><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ul><li>从软件系统最简单的部分开始实现</li><li>随着每次增量，产品不断发展，每次都添加增强功能，直到最终版本完成</li><li>代码被分割成小块，便于在开发流程中测试</li><li>在开发过程中很容易更改<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3></li><li>节省了需求变更时改变的开销<br>相对于瀑布流模型，需要写的文档比较少</li><li>快速接受反馈<br>容易获取反馈，用户可以评论，并给出有用的建议(感觉很像github)</li><li>提早交付部分可工作的产品<br>用户可以使用早期版本并伴随着整个开发周期<br>然而，增量式开发并不意味着每个增量都需要交付给用户<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3></li><li>流程不可视<br>需要定期交付来衡量进度<br>如果增量的迭代周期很短，为系统的每个版本生成文档是不划算的</li><li>系统结构会随着新增量的增加而降低<br>频繁的变更会给源代码和项目管理带来额外的负担，这可能对软件系统架构造成损害<br>随着更多的功能组件被添加到系统中，现有的架构可能需要相应修改，这可能会导致级联效应。<br>因此增量开发经常要重构</li></ul><p><strong>不适合开发大型、复杂和长生命周期的软件系统项目</strong></p><h2 id="螺旋模型-Spiral-Model"><a href="#螺旋模型-Spiral-Model" class="headerlink" title="螺旋模型(Spiral Model)"></a>螺旋模型(Spiral Model)</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><strong>初期需求 - 原型1 - 新需求 - 检验/验证 - 研发计划- 原型2 - 草图 - 检验/验证 - 测试计划 - 操作原型（检测和解决潜在的风险） - （开发和测试）细节设计 - 编写代码 - 集成 - 测试 - 实现 - 交付（计划接下来的限制）</strong></p><h3 id="图示-2"><a href="#图示-2" class="headerlink" title="图示"></a>图示</h3><p align="center"><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/imagesCS335-3.png"></p><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><h4 id="原型Prototype"><a href="#原型Prototype" class="headerlink" title="原型Prototype"></a>原型Prototype</h4><blockquote><p>“A prototype is a temporary implementation of some functional subset of the system, often presented to users for feedback and validation, which is then discarded when the validation exercise is complete.”<br><strong>原型是系统某些功能子集的临时实现，通常呈现给用户以获得反馈和验证，然后当验证工作完成时就会丢弃</strong></p></blockquote><h4 id="概念验证阶段Proof-of-Concept"><a href="#概念验证阶段Proof-of-Concept" class="headerlink" title="概念验证阶段Proof-of-Concept"></a>概念验证阶段Proof-of-Concept</h4><blockquote><p>”A proof-of-concept is some code designed to prove that a risky element of the proposed architecture is feasible and to highlight any problems and pitfalls. A proof-of-concept is also a temporary implementation, which is discussed when it has served its purpose and the risk under investigation is understood.”<br><strong>概念证明是一些代码，用来证明所提议的架构中的风险元素是可行的，并突出任何问题和缺陷。概念验证也是一种临时的实施，当它达到目的并了解调查中的风险时才会讨论</strong></p></blockquote><p>说人话大概是：证明一个有风险的代码块有可能作妖，并且突出有缺陷的部分（就一个纠错代码）</p><h4 id="骨架系统Skeleton-System"><a href="#骨架系统Skeleton-System" class="headerlink" title="骨架系统Skeleton System"></a>骨架系统Skeleton System</h4><blockquote><p>”A skeleton implements the system’s main architectural structures but contains only a minimal subset of the system’s functionality. A skeleton system is retained rather than discarded and becomes the basis for the construction phase.” A skeleton system is sometimes called an “evolutionary prototype”.<br><strong>一个框架实现系统的主要架构结构，但只包含系统功能的最小子集。一个骨架系统被保留而不是丢弃，并成为构建阶段的基础。骨骼系统有时被称为“进化原型</strong></p></blockquote><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>降低风险</li><li>降低需要开发的软件总量</li><li>快速交付</li></ul><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul><li>需求妥协可能会改变系统的原始想法</li><li>对系统进化的控制有限</li></ul><h2 id="集成-amp-配置"><a href="#集成-amp-配置" class="headerlink" title="集成&amp;配置"></a>集成&amp;配置</h2><p>原理：注重重复使用已有部件（接口，类，方法等）</p><h3 id="开发过程"><a href="#开发过程" class="headerlink" title="开发过程"></a>开发过程</h3><p><strong>需求确定 -&gt; software discovery evaluation:确定需要的部件和子系统 -&gt; 提取出可以重用的部件 -&gt; Application System Configuration:如果有现成部件可以用，则优先考虑使用 -&gt; Component Adaptation &amp; Integration：没有现成部件能用，才考虑开发新部件</strong></p><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul><li>复用组件，减少开发工作量</li><li>减少开销和风险</li><li>开发速度快</li></ul><h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><ul><li>要用已有的部件，但已有部件的功能又不是很符合需求，需求可能会妥协，进而改变了需求</li><li>你用了已有部件，结果部件更新了，更新前合适，更新后不合适</li></ul><h2 id="理性统一过程-Rational-Unified-Process"><a href="#理性统一过程-Rational-Unified-Process" class="headerlink" title="理性统一过程(Rational Unified Process)"></a>理性统一过程(Rational Unified Process)</h2><p>包括以下四点：</p><ul><li>   起始<strong>Inception</strong>: 分析部分use case的非功能性需求（安全性，可扩展性等），创建business case，做开发环境的准备工作</li><li>细化<strong>Elaboration</strong>: 对核心，有风险软件的结构进行了编程和测试，大部分需求都确定，不会变了。主要风险被减轻；包含迭代。</li><li>   架构<strong>Construction</strong>: 涉及系统设计、实现和测试，系统的部分被开发或集成了，完成此阶段后，应准备好部分工作系统和相关文件并交付给用户。</li><li>   转变<strong>Transition</strong>: 可以被用到现实中去，在此过程完成后，项目应能正常运行，文档也写好了。</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h4 id="没有什么软件开发模型适合所有项目"><a href="#没有什么软件开发模型适合所有项目" class="headerlink" title="没有什么软件开发模型适合所有项目"></a>没有什么软件开发模型适合所有项目</h4>]]></content>
      
      
      <categories>
          
          <category> 软件工程与软件过程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>L1-软件工程介绍</title>
      <link href="/2021/03/16/L1-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%BB%8B%E7%BB%8D/"/>
      <url>/2021/03/16/L1-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="L1-软件工程介绍"><a href="#L1-软件工程介绍" class="headerlink" title="L1-软件工程介绍"></a>L1-软件工程介绍</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="软件工程的定义"><a href="#软件工程的定义" class="headerlink" title="软件工程的定义"></a>软件工程的定义</h3><blockquote><p>“Software engineering is an engineering discipline that is concerned with all aspects of software production from initial conception to operation and maintenance.”<br><strong>软件工程是一门工程学科，涉及软件生产的各个方面，从最初的概念到操作和维护</strong></p></blockquote><ul><li>选择最佳的<em>理论</em> 和<em>工具</em> 用于开发</li><li>在<em>财务限制</em> 的范围内开发（好惨，但是现实如此</li><li>在这些限制条件下找到解决方案</li></ul><h3 id="软件过程的定义"><a href="#软件过程的定义" class="headerlink" title="软件过程的定义"></a>软件过程的定义</h3><blockquote><p>“The systematic approach that is used in software engineering is sometimes called a software process. A software process is a sequence of activities that leads to the production of a software product.”<br><strong>在软件工程中使用的系统方法有时被称为软件过程。软件过程是导致软件产品生产的一系列活动</strong></p></blockquote><p>软件过程可以被称作软件过程模型，就是瀑布、V那些开发框架</p><h2 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h2><h3 id="软件工程基础"><a href="#软件工程基础" class="headerlink" title="软件工程基础"></a>软件工程基础</h3><ul><li><p>可靠性</p><blockquote><p>没有故障<br>在需要的时候可以用<br>安全可靠</p></blockquote></li><li><p>满足需求</p><blockquote><p>理解不同利益相关者的期望<br>平衡冲突需求<br>在分配的预算和时间内交付软件系统</p></blockquote></li><li><p>复用管理</p><blockquote><p>有效利用现有资源，包括员工、技能、可用技术和软件</p></blockquote></li><li><p>流程</p><blockquote><p>使用管理和理解的开发过程，这可能取决于要开发的软件类型<br>组织和计划开发过程</p></blockquote></li></ul><h2 id="软件过程"><a href="#软件过程" class="headerlink" title="软件过程"></a>软件过程</h2><h3 id="软件过程的基本流程"><a href="#软件过程的基本流程" class="headerlink" title="软件过程的基本流程"></a>软件过程的基本流程</h3><p>这是一个循环</p><ul><li><b>软件规范：</b>需求/制约</li><li><b>软件开发：</b>设计/开发</li><li><b>软件确认：</b>全面的软件测试</li><li><b>软件进化：</b>修正/应对变化发展</li></ul><h3 id="评价一个软件的质量"><a href="#评价一个软件的质量" class="headerlink" title="评价一个软件的质量"></a>评价一个软件的质量</h3><p>主要从四个方面衡量</p><ul><li>兼容性<blockquote><p>软件需要被目标用户群体兼容<br>软件是可懂的、可用的，与系统兼容</p></blockquote></li><li>安全可靠性<blockquote><p>软件是可信赖的、安全可靠的<br>在出现故障时不应该造成物理或经济上的损害</p></blockquote></li><li>效率<blockquote><p>软件不应该占用浪费太多系统资源<br>效率包括响应性、处理时间和资源利用率等</p></blockquote></li><li>可维护性<blockquote><p>软件的开发应该以一种能够适应客户不断变化的需求的方式进行（版本更迭）</p></blockquote></li></ul><h2 id="软件类型"><a href="#软件类型" class="headerlink" title="软件类型"></a>软件类型</h2><h4 id="独立系统"><a href="#独立系统" class="headerlink" title="独立系统"></a>独立系统</h4><ul><li>运行在个人电脑、移动设备或大型机上的应用程序<br>如：Adobe Photoshop, Windows Calculator等</li></ul><h4 id="交互式系统"><a href="#交互式系统" class="headerlink" title="交互式系统"></a>交互式系统</h4><ul><li>运行在远程计算机上，但用户可以从自己的计算机访问的应用程序<br>如：网络应用、淘宝应用、云服务等</li></ul><h4 id="嵌入式系统"><a href="#嵌入式系统" class="headerlink" title="嵌入式系统"></a>嵌入式系统</h4><ul><li>控制和管理硬件设备的软件<br>如：冰箱温度控制，微波炉烹饪功能，油泵控制等</li></ul><h4 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h4><ul><li>大批量处理数据的应用系统<br>如：手机计费系统、员工工资支付系统、银行交易处理系统等</li></ul><h4 id="娱乐系统"><a href="#娱乐系统" class="headerlink" title="娱乐系统"></a>娱乐系统</h4><ul><li>这些系统大多是可以在个人电脑或特殊主机硬件上运行的游戏<br>如：Xbox、PS4、任天堂</li></ul><h4 id="建模-仿真系统"><a href="#建模-仿真系统" class="headerlink" title="建模/仿真系统"></a>建模/仿真系统</h4><ul><li>为科学家和工程师开发的应用系统<br>以模拟物理过程、化学反应、蛋白质折叠、可视化等</li></ul><h4 id="数据收集-分析系统"><a href="#数据收集-分析系统" class="headerlink" title="数据收集/分析系统"></a>数据收集/分析系统</h4><ul><li>从环境中收集数据并将数据发送到其他系统进行处理的软件系统<br>如：数据仓库、数据湖、大数据分析系统、传感器数据处理系统等</li></ul><h4 id="为系统搭建的系统"><a href="#为系统搭建的系统" class="headerlink" title="为系统搭建的系统"></a>为系统搭建的系统</h4><ul><li>大型企业或组织中使用的系统或子系统。<br>如：企业资源计划(ERP)系统，或由其他离散系统组成的系统。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件工程与软件过程 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
