<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>L11-项目管理</title>
      <link href="/2021/06/23/L11-%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
      <url>/2021/06/23/L11-%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="L11-项目管理"><a href="#L11-项目管理" class="headerlink" title="L11-项目管理"></a>L11-项目管理</h1><markdwon>  <details>    <summary><center>目标1：活动网图(Activity Network)</center></summary><p><strong>绘图步骤如下</strong></p><ul><li>制作活动表格</li><li>根据依赖性绘制活动网图</li></ul><h3 id="活动表格"><a href="#活动表格" class="headerlink" title="活动表格"></a>活动表格</h3><p>包含三列，从左往右分别是有序的任务代号(一般是T+数字)、工期(按天数计)、依赖性(需要在哪些任务完成的前提下才能开展这个任务)<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-25-10-29-07.png"></p><h3 id="活动网图"><a href="#活动网图" class="headerlink" title="活动网图"></a>活动网图</h3><p>你可以按照表格的顺序来画，之后再调整节点的位置使之更美观</p><ul><li>当一个节点不依赖任何节点时，它与Start节点直接相连</li><li>当一个节点依赖一个或多个节点时，它与所有依赖的节点相连</li></ul><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-25-10-31-37.png"></p><center>不依赖任何节点的节点</center><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-25-10-33-18.png"></p><center>依赖一个节点(上)与依赖两个节点(下)的节点</center><h3 id="我们可以用活动网图做什么？"><a href="#我们可以用活动网图做什么？" class="headerlink" title="我们可以用活动网图做什么？"></a>我们可以用活动网图做什么？</h3><p>我们可以用活动网图来找到**关键路径(Critical Path)**，即网图中最长的一条路径<br>关键路径不能存在延迟，一旦关键路径发生咕咕事件，整个项目的开发时间将会随之延长</p>  </details><markdwon>  <details>    <summary><center>目标2：活动时间线(Activity Timeline/ Bar Chart)</center></summary><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-25-10-40-21.png"><br>    挺顾名思义的，就是在能够反映时间的表格上将每个任务占用的时间、什么时候开始、什么时候结束表示在图上</p>  </details><markdwon>  <details>    <summary><center>目标3：人员安排图(Staff Allocation)</center></summary><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-25-10-41-53.png"></p><pre><code>斜线表示的是兼任工作，指做了某个任务的一部分，而不是全部  </code></pre><p>还是挺顾名思义的，甚至和活动时间线图有点像，只是加上了表示每个员工的轴<br>人员安排图能直观展现出哪个员工在什么时候干了什么工作</p>  </details><h2 id="软件项目管理原则"><a href="#软件项目管理原则" class="headerlink" title="软件项目管理原则"></a>软件项目管理原则</h2><p>因为<strong>时间</strong>(Time)和<strong>预算</strong>(Budget)存在限制，所以我们需要对项目进行管理。一个项目管理成功的四个标准是：</p><ul><li>及时交付</li><li>成本在预算之内</li><li>满足客户期望</li><li>让整个开发团队开心(这东西最重要)</li></ul><blockquote><p>管理者的工作<br>管理者的工作主要有以下几点：</p><ul><li>写提案</li><li>项目计划</li><li>管理风险</li><li>估计成本</li><li>监控和审查项目</li><li>选择和评估人员</li><li>写报告/做报告</li></ul></blockquote><h3 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h3><p>通过提案来向甲方爸爸赢(pian)取合同。<br>提案主要描述项目目标以及项目将被如何执行，为什么选择我们而不是其他人…等等</p><h3 id="项目计划"><a href="#项目计划" class="headerlink" title="项目计划"></a>项目计划</h3><p>项目计划主要包括：<br>• 定义了可用资源(时间、预算、人员、工具)<br>• 将工作分解为更小的单元，并评估每个小单元的时间和资源需要<br>• 安排流程(时间表、组织员工工作)<br>• 跟踪进度(实时监控开发进度)<br>• 比较实际与计划的进度/支出(当出大问题的时候，需要重新规划项目路线)<br>• 减小任务间的依赖性<br>进度、成本和风险必须在项目中修改，项目计划通常集中于开发过程</p><h4 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h4><blockquote><p>活动(Activities)<br>活动指的是一个项目应该产生切实的产出，它允许项目经理评估进程<br>里程碑(Milestones)<br>指进度表上的点，让我们可以评估进展;<br>每个流程活动的终点，如下图所示<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-25-10-21-03.png"><br>可交付成果(Deliverables)<br>交付给客户的项目结果，例如安全报告。<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-25-10-17-57.png"></p></blockquote><h4 id="项目计划的难度"><a href="#项目计划的难度" class="headerlink" title="项目计划的难度"></a>项目计划的难度</h4><p>•评估很困难!<br>•生产率与员工数量不成比例<br>•将人添加到项目中会让它延迟(存在沟通问题)<br>•意外总是会发生的(墨菲定律！！)<br>•计划时要考虑到意外情况</p><h3 id="风险管理"><a href="#风险管理" class="headerlink" title="风险管理"></a>风险管理</h3><h4 id="什么是风险管理"><a href="#什么是风险管理" class="headerlink" title="什么是风险管理"></a>什么是风险管理</h4><ul><li>确定潜在风险、指定减小风险造成的负面影响的计划</li><li>风险是某些不利情况发生的可能性<blockquote><ul><li>项目风险(Project Risk)<br>影响项目进度和资源，如有同事离职，难以替代</li><li>产品风险(Product Risks)<br>影响正在开发的软件的质量或性能，例如，购买的组件不能按预期工作</li><li>商务风险(Business Risks)<br>影响生产软件的组织，例如竞争对手引入类似软件</li></ul></blockquote></li></ul><p>风险是可重叠的（大悲</p><h4 id="如何进行风险管理"><a href="#如何进行风险管理" class="headerlink" title="如何进行风险管理"></a>如何进行风险管理</h4><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-25-10-59-30.png"></p><ul><li><p>风险确认<br>确认项目/产品/商务风险</p></li><li><p>风险分析评估<br>评估风险的可能性和后果</p></li><li><p>风险计划<br>制定规避风险或最小化风险影响的计划</p><blockquote><p>制定风险管理策略<br>可能的策略:</p><ul><li>规避<br>避免风险发生的可能</li><li>最小化<br>降低风险的影响</li><li>突发计划<br>为最坏的情况做准备，并制定相应的策略(以防万一)</li></ul></blockquote></li><li><p>风险监测<br>定期检查风险，并制定降低风险和修订风险的计划</p></li></ul><h4 id="更多风险类型"><a href="#更多风险类型" class="headerlink" title="更多风险类型"></a>更多风险类型</h4><ul><li>技术风险<br>来自用于开发的软件、硬件上的风险</li><li>人员风险<br>与开发团队有关的风险</li><li>组织风险<br>来自项目/产品的组织环境的风险</li><li>工具风险<br>与用于开发系统的支持工具/软件相关的风险</li><li>需求风险<br>因客户需求变更而产生的风险</li><li>评估风险<br>对资源的错误估计带来的风险</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好的项目管理将带领项目走向成功<br>项目管理很难，因为软件是很抽象的<br>项目经理所有的估计和进度<br>计划和评估是迭代和连续的<br>里程碑是可预测的状态，其中产生了进度报告<br>项目计划包括制作展示活动、持续时间和人员配备的图形演示<br>风险管理识别风险并制定计划以控制风险</p></markdwon></markdwon></markdwon>]]></content>
      
      
      <categories>
          
          <category> 软件工程与软件过程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021/6/16~2021/6/21涩图精选</title>
      <link href="/2021/06/16/2021-6-16-2021-6-21%E6%B6%A9%E5%9B%BE%E7%B2%BE%E9%80%89/"/>
      <url>/2021/06/16/2021-6-16-2021-6-21%E6%B6%A9%E5%9B%BE%E7%B2%BE%E9%80%89/</url>
      
        <content type="html"><![CDATA[<div class="justified-gallery"><p><img src="https://pixiv.cat/90572331.jpg"><br><img src="https://pixiv.cat/90572417.jpg"><br><img src="https://pixiv.cat/90560804.jpg"><br><img src="https://pixiv.cat/90573029.jpg"><br><img src="https://pixiv.cat/90554488.jpg"><br><img src="https://pixiv.cat/90540403.jpg"><br><img src="https://pixiv.cat/90570547.jpg"><br><img src="https://pixiv.cat/90574125.jpg"><br><img src="https://pixiv.cat/90539913.jpg"><br><img src="https://pixiv.cat/90570532.jpg"><br><img src="https://pixiv.cat/90572919.jpg"><br><img src="https://pixiv.cat/90568354.jpg"><br><img src="https://pixiv.cat/90563359.jpg"><br><img src="https://pixiv.cat/90555862.jpg"><br><img src="https://pixiv.cat/90568079.jpg"><br><img src="https://pixiv.cat/90577000.jpg"><br><img src="https://pixiv.cat/90579376-2.jpg"><br><img src="https://pixiv.cat/90565427-1.jpg"><br><img src="https://pixiv.cat/90565427-3.jpg"><br><img src="https://pixiv.cat/90565427-4.jpg"><br><img src="https://pixiv.cat/90565427-15.jpg"><br><img src="https://pixiv.cat/90564100-3.jpg"><br><img src="https://pixiv.cat/90564100-10.jpg"><br><img src="https://pixiv.cat/90564100-12.jpg"><br><img src="https://pixiv.cat/90564100-18.jpg"><br><img src="https://pixiv.cat/90564100-30.jpg"><br><img src="https://pixiv.cat/90564100-31.jpg"><br><img src="https://pixiv.cat/90603692-5.jpg"><br><img src="https://pixiv.cat/90581839.jpg"><br><img src="https://pixiv.cat/90604060.jpg"><br><img src="https://pixiv.cat/90586736.jpg"><br><img src="https://pixiv.cat/90604070.jpg"><br><img src="https://pixiv.cat/90603764.jpg"><br><img src="https://pixiv.cat/90603920.jpg"><br><img src="https://pixiv.cat/90603074.jpg"><br><img src="https://pixiv.cat/90621846.jpg"><br><img src="https://pixiv.cat/90620174.jpg"><br><img src="https://pixiv.cat/90637238-2.jpg"><br><img src="https://pixiv.cat/90631073.jpg"><br><img src="https://pixiv.cat/90635284.jpg"><br><img src="https://pixiv.cat/90630182.jpg"><br><img src="https://pixiv.cat/90625250.jpg"><br><img src="https://pixiv.cat/90623902-1.jpg"><br><img src="https://pixiv.cat/90616435.jpg"><br><img src="https://pixiv.cat/90608386.jpg"><br><img src="https://pixiv.cat/90622904-1.jpg"><br><img src="https://pixiv.cat/90622904-2.jpg"><br><img src="https://pixiv.cat/90622904-3.jpg"><br><img src="https://pixiv.cat/90622904-4.jpg"><br><img src="https://pixiv.cat/90622904-5.jpg"><br><img src="https://pixiv.cat/90623860-1.jpg"><br><img src="https://pixiv.cat/90623860-2.jpg"><br><img src="https://pixiv.cat/90603005.jpg"><br><img src="https://pixiv.cat/90625415.jpg"><br><img src="https://pixiv.cat/90663217.jpg"><br><img src="https://pixiv.cat/90662892.jpg"><br><img src="https://pixiv.cat/90647268-1.jpg"><br><img src="https://pixiv.cat/90634700.jpg"><br><img src="https://pixiv.cat/90647771.jpg"><br><img src="https://pixiv.cat/90648189.jpg"><br><img src="https://pixiv.cat/90656844.jpg"><br><img src="https://pixiv.cat/90700083-1.jpg"><br><img src="https://pixiv.cat/90670244.jpg"><br><img src="https://pixiv.cat/90690039.jpg"><br><img src="https://pixiv.cat/90696501.jpg"><br><img src="https://pixiv.cat/90691661.jpg"><br><img src="https://pixiv.cat/90697625.jpg"><br><img src="https://pixiv.cat/90699081-1.jpg"><br><img src="https://pixiv.cat/90703588.jpg"><br><img src="https://pixiv.cat/90699068.jpg"><br><img src="https://pixiv.cat/90718201.jpg"><br><img src="https://pixiv.cat/90645158.jpg"><br><img src="https://pixiv.cat/90651148.jpg"><br><img src="https://pixiv.cat/90666326.jpg"><br><img src="https://pixiv.cat/90674307.jpg"><br><img src="https://pixiv.cat/90646043-1.jpg"><br><img src="https://pixiv.cat/90646043-2.jpg"><br><img src="https://pixiv.cat/90646043-4.jpg"><br><img src="https://pixiv.cat/90646043-5.jpg"><br><img src="https://pixiv.cat/90646043-13.jpg"><br><img src="https://pixiv.cat/90646043-17.jpg"><br><img src="https://pixiv.cat/90646043-18.jpg"><br><img src="https://pixiv.cat/90674668-1.jpg"><br><img src="https://pixiv.cat/90674668-2.jpg"><br><img src="https://pixiv.cat/90680263.jpg"><br><img src="https://pixiv.cat/90670677.jpg"><br><img src="https://pixiv.cat/90670271.jpg"></p>          </div>]]></content>
      
      
      <categories>
          
          <category> 涩图 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>L10-软件测试</title>
      <link href="/2021/06/14/L10-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
      <url>/2021/06/14/L10-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="L10-软件测试"><a href="#L10-软件测试" class="headerlink" title="L10-软件测试"></a>L10-软件测试</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="什么是软件测试"><a href="#什么是软件测试" class="headerlink" title="什么是软件测试"></a>什么是软件测试</h3><ul><li><strong>为什么要进行软件测试</strong><blockquote><p>软件测试的目的是<strong>一个程序做它想做的事，并在它投入使用之前发现程序缺陷</strong></p></blockquote></li><li><strong>如何进行软件测试</strong><blockquote><p>当您测试软件时，您<strong>使用人工数据执行程序</strong></p></blockquote></li><li><strong>通过软件测试，我们可以获得什么?</strong><blockquote><p>您可以检查测试运行的结果，以查找有关程序<strong>非功能属性的错误、异常或信息</strong></p></blockquote></li></ul><p>测试是更一般的<strong>软件验证和确认过程的一部分</strong></p><h3 id="软件测试的目标"><a href="#软件测试的目标" class="headerlink" title="软件测试的目标"></a>软件测试的目标</h3><ul><li>向开发人员和客户<strong>演示软件满足其需求</strong><blockquote><ul><li>对于定制软件<br>需求文档中的每个需求都应该至少有一个测试。</li><li>对于通用软件<br>应该对所有的系统特性进行测试，加上这些特性的组合，这些特性将合并到产品发布中</li></ul></blockquote></li><li><strong>发现软件</strong>不正确、不受欢迎的行为或不符合其规范<strong>的糟糕情况</strong><blockquote><p>缺陷测试关注的是根除不需要的系统行为，比如系统崩溃、与其他系统的不需要的交互、不正确的计算和数据损坏</p></blockquote></li></ul><h3 id="测试过程的目标"><a href="#测试过程的目标" class="headerlink" title="测试过程的目标"></a>测试过程的目标</h3><h4 id="验证测试-Validation-Testing"><a href="#验证测试-Validation-Testing" class="headerlink" title="验证测试(Validation Testing)"></a>验证测试(Validation Testing)</h4><ul><li>向开发人员和系统客户演示该软件满足其需求</li><li><strong>成功的测试表明该系统按预期运行</strong><h4 id="缺陷测试-Defect-Testing"><a href="#缺陷测试-Defect-Testing" class="headerlink" title="缺陷测试(Defect Testing)"></a>缺陷测试(Defect Testing)</h4></li><li>在软件的行为不正确或不符合其规范的地方<strong>发现错误或缺陷</strong></li><li><strong>成功的测试是使系统执行不正确</strong>，从而暴露系统中的缺陷的测试</li></ul><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-14-20-40-54.png" alt="程序测试中的输入-输出模型"></p><h3 id="验证与确认"><a href="#验证与确认" class="headerlink" title="验证与确认"></a><font color="red">验证与确认</font></h3><h4 id="验证-Verification"><a href="#验证-Verification" class="headerlink" title="验证(Verification)"></a>验证(Verification)</h4><ul><li>关注“我们构建的产品是正确的吗?”的问题<blockquote><p>Are we building the product right?</p></blockquote></li><li>软件应符合其法律、规格以及说明</li></ul><h4 id="确认-Validation"><a href="#确认-Validation" class="headerlink" title="确认(Validation)"></a>确认(Validation)</h4><ul><li>关注“我们是否构建了正确的产品?”的问题<blockquote><p>“Are we building the right product?”</p></blockquote></li><li>软件应该做用户真正需要的</li><li>产品是否满足利益相关者的需求？通常涉及用户的接受度和适应性</li></ul><p>经过这两个测试(IV &amp; V过程)，建立起对系统“符合目的”的信心</p><h3 id="检测与测试"><a href="#检测与测试" class="headerlink" title="检测与测试"></a>检测与测试</h3><h4 id="软件检查-Software-Inspections"><a href="#软件检查-Software-Inspections" class="headerlink" title="软件检查(Software Inspections)"></a>软件检查(Software Inspections)</h4><ul><li>对静态系统表示进行分析以发现问题**(静态验证)**</li><li>可以通过基于工具的文档和代码分析进行补充<h4 id="软件测试-Software-Testing"><a href="#软件测试-Software-Testing" class="headerlink" title="软件测试(Software Testing)"></a>软件测试(Software Testing)</h4></li><li>有关实践和观察产品行为**(动态验证)**</li><li>系统使用测试数据执行，并观察其操作行为<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4>检查和测试是互补的，而不是对立的验证技术<br>二者都应该在V &amp; V过程中使用</li><li>软件检查可以检查是否符合规格，但不符合客户的实际要求</li><li>软件检查不能检查非功能特征，如性能、可用性等</li></ul><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-14-20-41-38.png" alt="软件测试流程模型"></p><h3 id="测试的阶段"><a href="#测试的阶段" class="headerlink" title="测试的阶段"></a>测试的阶段</h3><ul><li>开发测试<br>在开发过程中测试系统以发现bug和缺陷</li><li>发布测试<br>由单独的测试团队在系统发布给用户之前测试系统的完整版本</li><li>用户测试<br>系统的用户或潜在用户在他们自己的环境中测试系统</li></ul><h2 id="测试-Testing-与捉虫-Debugging"><a href="#测试-Testing-与捉虫-Debugging" class="headerlink" title="测试(Testing)与捉虫(Debugging)"></a>测试(Testing)与捉虫(Debugging)</h2><p>缺陷测试和捉虫是不同的过程: </p><blockquote><p>缺陷测试涉及到确认错误的存在</p><ul><li>比较输入和输出</li><li>程序为什么不工作(废话因为有bug啊————</li><li>我要怎么打破我的程序(你需要一把锤子</li></ul><p>捉虫涉及到定位和修复这些错误</p><ul><li>研究是什么东西导致了错误发生</li><li>为什么代码不工作</li><li>我要如何修复我的程序</li><li>目标是搞出一个没有bug的美好程序</li><li>有系统地寻找bug</li></ul></blockquote><p>捉虫涉及到制定一个关于程序行为的假设，然后测试这些假设以找到系统错误</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h4 id="进行测试之前…"><a href="#进行测试之前…" class="headerlink" title="进行测试之前…"></a>进行测试之前…</h4><p>首先你需要确定你的代码能够运行，它不是意大利面怪</p><ul><li>不要有奇奇怪怪的语法错误</li><li>不要有奇奇怪怪的静态语义错误<br>其次你需要有一组预期的测试结果</li><li>一组输入</li><li>对输入组中的每个输入，都有一个对应的预期输出</li></ul><h3 id="捉虫"><a href="#捉虫" class="headerlink" title="捉虫"></a>捉虫</h3><h4 id="捉虫之道"><a href="#捉虫之道" class="headerlink" title="捉虫之道"></a>捉虫之道</h4><p>以下方法都可以通过调试工具(如调试编译器、动态调试辅助)加以补充</p><ul><li>暴力破解代码，直到bug被发现</li><li>回溯<br>比较适合小程序，回到没bug的上一版本，并进行对比</li><li>原因消除<br>假设是什么导致的错误，并输入测试数据来检查</li></ul><h4 id="捉虫时可能遇到的问题"><a href="#捉虫时可能遇到的问题" class="headerlink" title="捉虫时可能遇到的问题"></a>捉虫时可能遇到的问题</h4><ul><li>观察到的bug及其原因可能在地理上是分开的</li><li>观察到的bug可能随着另一个问题的修复而消失</li><li>bug的原因可能是难以追踪的人为错误</li><li>bug的原因可能是每个人都相信的假设</li><li>观察到的bug可能是间歇性的，因为系统或编译错误</li></ul><h4 id="debug有的时候要人命"><a href="#debug有的时候要人命" class="headerlink" title="debug有的时候要人命"></a>debug有的时候要人命</h4><ul><li>重新考虑假设<br>操作系统改变了吗?硬盘满了吗?这是闰年吗?</li><li>开始为您的系统编制文档<blockquote><p>提供一个全新的角度，并突出显示困惑的地方<br>确保注释和规范描述了代码</p></blockquote></li><li>寻求外界的帮助<br>个人的能力是有限的，我们每个人都会有盲点</li></ul><h3 id="我们需要做什么、不需要做什么？"><a href="#我们需要做什么、不需要做什么？" class="headerlink" title="我们需要做什么、不需要做什么？"></a>我们需要做什么、不需要做什么？</h3><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-14-21-13-24.png"></p><h2 id="软件质量"><a href="#软件质量" class="headerlink" title="软件质量"></a>软件质量</h2><p>软件开发伴随着风险。现代软件通常十分复杂，伴随着几千行的代码。用户需求可能十分模糊，此外ddl和预算也很搞开发团队心态。诸多因素可能导致软件质量下降，这对开发团队、公司名誉的损害是巨大的</p><h3 id="如何评价软件质量"><a href="#如何评价软件质量" class="headerlink" title="如何评价软件质量"></a>如何评价软件质量</h3><p>根据ISO91261软件工程标准，衡量一个软件的质量主要从以下六个方面入手：<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-14-21-17-51.png"></p><p>即：</p><ul><li>功能性<br>适用性、准确性、互操作性、合规性、安全性</li><li>可靠性<br>成熟、容错、可恢复性</li><li>可用性<br>易懂、易学性、可操作性</li><li>效率<br>时间行为，资源行为</li><li>可维护性<br>可分析性，易变性，稳定性，可测试性</li><li>可移植性<br>适应性，可安装性，一致性，可更换性</li></ul><h3 id="反映软件质量糟糕的一面"><a href="#反映软件质量糟糕的一面" class="headerlink" title="反映软件质量糟糕的一面"></a>反映软件质量糟糕的一面</h3><p>主要有三个要素：错误、故障和失败</p><ul><li><p>错误(Error)</p><blockquote><p>错误指的是软件开发人员所犯的错误。它们<strong>存在于程序员的头脑中</strong>，并可能导致软件中的一个或多个错误</p></blockquote></li><li><p>故障(Fault)</p><blockquote><p>故障<strong>由源代码中的错误代码组成</strong>，可能是一个或多个错误的产物。错误可能导致程序执行过程中的失败<br>故障类型</p><ul><li>算法类故障(占将近50%)<blockquote><p>算法故障是指当软件的某个单元在指定的算法下不能产生对应于给定输入的输出时发生的故障</p></blockquote></li><li>语法类故障</li><li>文档类故障</li><li>应力或过载类故障</li><li>容量和边界类故障</li><li>计算和精度类故障(占将近50%)<blockquote><p>当使用所选公式计算的结果不符合预期的精度或精度时，计算和精度故障就会发生</p></blockquote></li><li>吞吐量或性能类故障</li><li>恢复类故障</li><li>定时或协调类故障</li><li>标准和步骤类故障</li></ul></blockquote></li><li><p>失败(Failure)</p><blockquote><p>失败是<strong>故障的症状</strong>，由软件的不正确或不规范行为组成。错误可能一直隐藏着，直到满足了一组特定的条件，这些条件表明它们是软件执行中的一个失败<br>几种级别的失败如下：</p><ul><li><strong>导致系统崩溃</strong>，恢复时间很长;或者故障会导致功能和数据的丢失，没有任何变通方法</li><li><strong>导致功能或数据的丢失</strong>，但是有手动的变通方法来临时完成这些任务</li><li><strong>导致部分功能或数据丢失</strong>，用户可以用少量变通方法完成大部分任务</li><li><strong>导致表面上和轻微的不便</strong>，所有用户任务仍然可以完成</li></ul></blockquote></li></ul><h4 id="从故障到失败"><a href="#从故障到失败" class="headerlink" title="从故障到失败"></a>从故障到失败</h4><p>首先，程序员在敲代码的时候写错了什么东西，导致了故障产生(Fault)<br>当程序执行，故障开始传染<br>之后，传染进一步升级，并影响到程序本身<br>最后，传染造成了失败。不过需要注意的是，<strong>并不是每个传染最终都会造成失败，也不是每个故障都会产生传染</strong><br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-14-21-28-02.png"></p><h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><p><strong>测试理论的目标</strong><br>确定理想的测试——也就是说，确保软件在所有输入下都能工作所需的最小测试数据</p><h3 id="几种测试"><a href="#几种测试" class="headerlink" title="几种测试"></a>几种测试</h3><h4 id="单元测试-Unit-Testing"><a href="#单元测试-Unit-Testing" class="headerlink" title="单元测试(Unit Testing)"></a>单元测试(Unit Testing)</h4><ul><li>对软件的单个单元进行测试，以确保其正确工作。这可以是单个组件，也可以是复合组件</li><li>组件可以是方法、类或子系统。它可以是单个GUI组件(如按钮)或它们的集合(如窗口)</li><li>这利用了该单元的编程接口</li></ul><h4 id="集成测试-Integration-Testing"><a href="#集成测试-Integration-Testing" class="headerlink" title="集成测试(Integration Testing)"></a>集成测试(Integration Testing)</h4><ul><li>测试两个或更多单元，以确保它们正确地互操作</li><li>这可以使用编程接口或系统接口</li><li>是自顶向下，自底向上，还是采用“端到端用户功能”的方法(这啥玩意</li></ul><h4 id="系统测试-System-Testing"><a href="#系统测试-System-Testing" class="headerlink" title="系统测试(System Testing)"></a>系统测试(System Testing)</h4><ul><li>对整个软件系统进行测试，以确保它正确工作，满足/解决用户的需求/问题</li><li>本系统使用的系统界面可以是GUI、网络界面、web界面等…</li></ul><h4 id="收敛测试-Acceptance-Testing"><a href="#收敛测试-Acceptance-Testing" class="headerlink" title="收敛测试(Acceptance Testing)"></a>收敛测试(Acceptance Testing)</h4><ul><li>对整个软件系统进行测试，以确保其<strong>满足用户需求</strong></li><li>同样，这使用了系统接口</li></ul><h5 id="上述几种测试的直观联系"><a href="#上述几种测试的直观联系" class="headerlink" title="上述几种测试的直观联系"></a>上述几种测试的直观联系</h5><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-14-21-43-06.png"></p><h4 id="回归测试-Regression-Testing"><a href="#回归测试-Regression-Testing" class="headerlink" title="回归测试(Regression Testing)"></a>回归测试(Regression Testing)</h4><ul><li>在软件经历变更后确认或否认软件的功能</li><li>在发现并纠正bug时进行新的回归测试</li><li>确保您不会重新引入以前已修复的错误<blockquote><ul><li>保持严格的定期测试时间表</li><li>使用测试管理软件</li><li>对测试进行分类，以便理解</li><li>根据需要，例如客户的需求，确定测试的优先级</li></ul></blockquote></li></ul><h4 id="穷举调试-Exhaustive-Testing"><a href="#穷举调试-Exhaustive-Testing" class="headerlink" title="穷举调试(Exhaustive Testing)"></a>穷举调试(Exhaustive Testing)</h4><ul><li>这通常是不可行的，因为这将花费太长时间或需要太多内存空间</li><li>一个好的测试应该有很高的发现错误的可能性，而不是重复另一个测试，在测量什么方面是独立的，这样错误就不会相互隐藏，并且尽可能多地测试代码</li></ul><h3 id="黑盒测试与白盒测试"><a href="#黑盒测试与白盒测试" class="headerlink" title="黑盒测试与白盒测试"></a>黑盒测试与白盒测试</h3><h4 id="黑盒测试-功能测试"><a href="#黑盒测试-功能测试" class="headerlink" title="黑盒测试(功能测试)"></a>黑盒测试(功能测试)</h4><p>生成执行规范的输入值，并将实际输出与预期输出进行比较。我们不知道测试过程中代码内部发生了什么，只关注输入与输出</p><blockquote><p>完全基于程序规范，目的是<strong>验证程序满足规定的要求</strong><br>黑盒测试<strong>不会发现与额外功能相关的故障</strong>。这些都是遗漏的错误<br>黑盒测试提供了规范的覆盖率，但<strong>没有提供实现的全部覆盖率</strong>。也就是说，实现中的代码可能产生规范中没有说明的结果</p></blockquote><ol><li>根据规格进行测试。</li><li>使用基于规格说明的测试覆盖率标准。</li><li>开发来自规范的测试用例。</li><li>“锻炼”的规范。</li></ol><h5 id="包括"><a href="#包括" class="headerlink" title="包括"></a>包括</h5><ul><li>等价类测试<br>将输入数据划分出几个等价区域，并在每个区域中测试一个值</li><li>边界值测试<br>测试边界值</li><li>组合测试<br>测试输入数值的组合</li><li>随机测试<br>选取随机数进行测试<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-14-21-59-29.png"></li></ul><h4 id="白盒测试-结构测试"><a href="#白盒测试-结构测试" class="headerlink" title="白盒测试(结构测试)"></a>白盒测试(结构测试)</h4><p>生成执行实现的输入值，并将实际输出与预期输出进行比较。我们知道测试过程中每条代码上发生了什么，测试是根据代码的结构进行设计的</p><blockquote><p>使用软件的实现来派生测试。这些测试的目的是<strong>测试程序代码的某些方面</strong><br>白盒测试<strong>不会发现与缺失功能相关的故障</strong>。这些都是遗漏的错误<br>白盒测试<strong>提供了实现的覆盖率</strong>，而不是规范的覆盖率。也就是说，可能在规范中声明的行为在实现中没有代码</p></blockquote><ol><li>对实现进行测试</li><li>使用基于实现的测试覆盖标准</li><li>开发来自实现的测试用例。</li><li>“锻炼”的实现<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-14-22-02-28.png"></li></ol><h4 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h4><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-14-21-56-03.png"></p><h3 id="是不是应该结束测试了？"><a href="#是不是应该结束测试了？" class="headerlink" title="是不是应该结束测试了？"></a>是不是应该结束测试了？</h3><p>当满足以下三种情况的时候，我们可以考虑结束软件测试：</p><ul><li>预算角度：分配的时间或预算已过期</li><li>活动角度：软件通过了所有计划的测试</li><li>风险管理角度：预测的故障率满足某些质量标准</li></ul><h3 id="静态验证与动态检验"><a href="#静态验证与动态检验" class="headerlink" title="静态验证与动态检验"></a>静态验证与动态检验</h3><p>言简意骇一句话：静态验证不需要执行软件代码，而动态验证需要执行</p><h4 id="静态检验-Static-Verification"><a href="#静态检验-Static-Verification" class="headerlink" title="静态检验(Static Verification)"></a>静态检验(Static Verification)</h4><ul><li>静态验证(或静态分析)可以非常简单，就像让受过培训的人阅读代码并有经验来查找错误一样</li><li>它还可以采用一种数学方法，包括程序的符号执行</li><li>最后，它可以是一种正式的方法，包括规范和源代码之间转换的符号验证</li></ul><h4 id="动态检验-Dynamic-Verification"><a href="#动态检验-Dynamic-Verification" class="headerlink" title="动态检验(Dynamic Verification)"></a>动态检验(Dynamic Verification)</h4><ul><li>动态验证(或软件测试)通过执行程序来确认程序的运行</li><li>创建的测试用例指导选择合适的测试数据(由输入值和期望输出值组成)</li><li>输入值在执行期间作为程序的输入提供</li><li>从程序中收集实际输出，然后将它们与预期输出进行比较<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-14-21-55-14.png"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件工程与软件过程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021/6/10~2021/6/15涩图精选</title>
      <link href="/2021/06/10/6-10-6-15%E6%B6%A9%E5%9B%BE%E7%B2%BE%E9%80%89/"/>
      <url>/2021/06/10/6-10-6-15%E6%B6%A9%E5%9B%BE%E7%B2%BE%E9%80%89/</url>
      
        <content type="html"><![CDATA[<div class="justified-gallery"><p><img src="https://pixiv.cat/90406427-1.jpg"><br><img src="https://pixiv.cat/90406427-2.jpg"><br><img src="https://pixiv.cat/90424630-1.jpg"><br><img src="https://pixiv.cat/90424630-2.jpg"><br><img src="https://pixiv.cat/90424630-3.jpg"><br><img src="https://pixiv.cat/90414948.jpg"><br><img src="https://pixiv.cat/90429021.jpg"><br><img src="https://pixiv.cat/90440259.jpg"><br><img src="https://pixiv.cat/90415143-1.jpg"><br><img src="https://pixiv.cat/90415143-2.jpg"><br><img src="https://pixiv.cat/90415143-3.jpg"><br><img src="https://pixiv.cat/90409224.jpg"><br><img src="https://pixiv.cat/90434103.jpg"><br><img src="https://pixiv.cat/90412043.jpg"><br><img src="https://pixiv.cat/90424078.jpg"><br><img src="https://pixiv.cat/90411438.jpg"><br><img src="https://pixiv.cat/90407932.jpg"><br><img src="https://pixiv.cat/90436497-1.jpg"><br><img src="https://pixiv.cat/90424111.jpg"><br><img src="https://pixiv.cat/90433339.jpg"><br><img src="https://pixiv.cat/90402106.jpg"><br><img src="https://pixiv.cat/90414318.jpg"><br><img src="https://pixiv.cat/90422376-5.jpg"><br><img src="https://pixiv.cat/90422376-15.jpg"><br><img src="https://pixiv.cat/90422376-18.jpg"><br><img src="https://pixiv.cat/90422376-21.jpg"><br><img src="https://pixiv.cat/90402340.jpg"><br><img src="https://pixiv.cat/90446323.jpg"><br><img src="https://pixiv.cat/90454262-1.jpg"><br><img src="https://pixiv.cat/90457194.jpg"><br><img src="https://pixiv.cat/90458238.jpg"><br><img src="https://pixiv.cat/90450957.jpg"><br><img src="https://pixiv.cat/90471251.jpg"><br><img src="https://pixiv.cat/90472900-3.jpg"><br><img src="https://pixiv.cat/90472900-4.jpg"><br><img src="https://pixiv.cat/90472900-5.jpg"><br><img src="https://pixiv.cat/90472900-6.jpg"><br><img src="https://pixiv.cat/90472900-7.jpg"><br><img src="https://pixiv.cat/90472900-8.jpg"><br><img src="https://pixiv.cat/90472900-9.jpg"><br><img src="https://pixiv.cat/90472900-10.jpg"><br><img src="https://pixiv.cat/90479678.jpg"><br><img src="https://pixiv.cat/90445498-1.jpg"><br><img src="https://pixiv.cat/90479941.jpg"><br><img src="https://pixiv.cat/90495379.jpg"><br><img src="https://pixiv.cat/90465943-2.jpg"><br><img src="https://pixiv.cat/90489736.jpg"><br><img src="https://pixiv.cat/90486349.jpg"><br><img src="https://pixiv.cat/90495989.jpg"><br><img src="https://pixiv.cat/90481586.jpg"><br><img src="https://pixiv.cat/90486310.jpg"><br><img src="https://pixiv.cat/90494445-1.jpg"><br><img src="https://pixiv.cat/90494445-2.jpg"><br><img src="https://pixiv.cat/90486086.jpg"><br><img src="https://pixiv.cat/90481742.jpg"><br><img src="https://pixiv.cat/90484341.jpg"><br><img src="https://pixiv.cat/90486424.jpg"><br><img src="https://pixiv.cat/90512359-1.jpg"><br><img src="https://pixiv.cat/90516356.jpg"><br><img src="https://pixiv.cat/90512138.jpg"><br><img src="https://pixiv.cat/90510999.jpg"><br><img src="https://pixiv.cat/90516112.jpg"><br><img src="https://pixiv.cat/90492770.jpg"><br><img src="https://pixiv.cat/90513628.jpg"><br><img src="https://pixiv.cat/90523004.jpg"><br><img src="https://pixiv.cat/90518163.jpg"><br><img src="https://pixiv.cat/90506596.jpg"><br><img src="https://pixiv.cat/90507724.jpg"><br><img src="https://pixiv.cat/90501278.jpg"><br><img src="https://pixiv.cat/90528751.jpg"><br><img src="https://pixiv.cat/90523989.jpg"><br><img src="https://pixiv.cat/90527166.jpg"><br><img src="https://pixiv.cat/90511189.jpg"><br><img src="https://pixiv.cat/90509664.jpg"><br><img src="https://pixiv.cat/90544363.jpg"><br><img src="https://pixiv.cat/90539747.jpg"><br><img src="https://pixiv.cat/90550649-1.jpg"><br><img src="https://pixiv.cat/90529343.jpg"><br><img src="https://pixiv.cat/90528420-1.jpg"><br><img src="https://pixiv.cat/90528420-2.jpg"><br><img src="https://pixiv.cat/90526041-2.jpg"><br><img src="https://pixiv.cat/90526041-3.jpg"><br><img src="https://pixiv.cat/90526041-4.jpg"><br><img src="https://pixiv.cat/90526041-5.jpg"><br><img src="https://pixiv.cat/90548389.jpg"><br><img src="https://pixiv.cat/90528708.jpg"><br><img src="https://pixiv.cat/90550307-1.jpg"><br><img src="https://pixiv.cat/90540389.jpg"></p>          </div>]]></content>
      
      
      <categories>
          
          <category> 涩图 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>L9-UI/UX设计</title>
      <link href="/2021/06/08/L9-UI_UX%E8%AE%BE%E8%AE%A1/"/>
      <url>/2021/06/08/L9-UI_UX%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="L9-UI-UX设计"><a href="#L9-UI-UX设计" class="headerlink" title="L9-UI/UX设计"></a>L9-UI/UX设计</h1><p>这不是专业课知识吗）尚且可还行<br>虽然但是，我专业课也没好好学就是了（主要因为没考试，就水了</p><h2 id="为什么要进行设计？"><a href="#为什么要进行设计？" class="headerlink" title="为什么要进行设计？"></a>为什么要进行设计？</h2><p>设计关注事物如何工作，如何控制它们，以及人与技术之间互动的本质。如果做得好，结果是辉煌的，令人愉快的产品。<br>如果设计的不好，产品就无法使用，可能导致巨大的挫败感和愤怒。或者它们可能有用，但迫使我们按照产品的意愿行事，而不是按照我们的意愿行事</p><blockquote><ul><li>Design is concerned with how things work, how they are controlled, and the nature of the interaction between people and technology. When done well, the results are brilliant, pleasurable products.</li><li>When done badly, the products are unusable, leading to great frustration and irritation. Or they might be useable, but force us to behave the way the product wishes rather than as we wish</li></ul></blockquote><h3 id="设计前应考虑的一些事"><a href="#设计前应考虑的一些事" class="headerlink" title="设计前应考虑的一些事"></a>设计前应考虑的一些事</h3><ol><li>用户是谁？<br>不同的受众群体对UI的偏好可能有所不同</li><li>用户正在进行什么活动，交互发生在哪里(环境)？<br>使用认知走查来寻找潜在的交互问题</li><li>需要优化用户与产品的互动…以便他们匹配用户的活动和需求</li></ol><h2 id="良好的UI设计"><a href="#良好的UI设计" class="headerlink" title="良好的UI设计"></a>良好的UI设计</h2><p>计算机和界面应该功能齐全，易于使用，直观</p><h3 id="UI设计重点"><a href="#UI设计重点" class="headerlink" title="UI设计重点"></a>UI设计重点</h3><p>预测用户可能需要做什么，并确保界面具有易于访问、理解和使用的元素，以促进这些操作。UI汇集了来自交互设计、视觉设计和信息架构的概念<br>UI设计师眼里的用户智商.jpg) 总之你真的永远不知道用户会干什么</p><h3 id="执行鸿沟和评估鸿沟"><a href="#执行鸿沟和评估鸿沟" class="headerlink" title="执行鸿沟和评估鸿沟"></a>执行鸿沟和评估鸿沟</h3><ul><li>执行鸿沟(gulf of execution): 这是用户行动的意图和系统允许他们实现它的容易程度之间的鸿沟。</li><li>评估鸿沟(gulf of evaluation): 这是用户感知和解释他们所执行的行动是否成功的轻松程度。</li></ul><h3 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h3><ul><li>可见性<strong>Visibility</strong><br>用户需要知道所有的选项是什么，并直接知道如何访问它们</li><li>反馈<strong>Feedback</strong><br>每个操作需要一个反射。需要有一些指示，比如声音，移动的刻度盘，旋转的彩虹轮，总之就是用户的行动引起了一些东西的发生</li><li>功能可见性<strong>Affordance</strong><br>可见性是指事物的外观和使用方式之间的关系。对于设计师来说，这意味着一旦有人看到某样东西，他们就必须知道如何使用它</li><li>映射<strong>Mapping</strong><br>映射是控制和效果之间的关系。其理念是，通过优秀的设计，某些内容的控制将与它们所影响的内容非常相似</li></ul><p><strong>垂直滚动条</strong>是映射的一个很好的例子。它告诉你你在页面中的位置，当你向下拖动时，页面以相同的速度向下移动;控制和影响密切相关</p><ul><li>约束<strong>Constraints</strong><br>约束是指对交互或界面的限制。有些是非常明显和物理的，例如手机的屏幕大小</li><li>一致性<strong>Consistency</strong><br>每次同样的动作都会引起同样的反应</li></ul><h3 id="五大原则"><a href="#五大原则" class="headerlink" title="五大原则"></a>五大原则</h3><ul><li>用户熟悉度/用户友好度<br>界面应该基于面向用户的术语和概念，而不是计算机概念。<br>应该从左到右读取并输入数据</li><li>用户引导<br>应提供一些用户指南，如帮助系统、联机手册等</li><li>减少用户的内存负载<br>减少对短期记忆的需求，例如，用视觉线索来回忆过去的行为，而不是用户们必须用脑子去回忆它们<blockquote><p>例如，亚马逊(和许多其他电子商务网站)会向用户展示他们最近访问过的物品列表。这些列表帮助用户记住完成几天前开始的购买</p></blockquote></li><li>建立有意义的默认值<br>身高默认值为160而不是0或者-10086一类的</li><li>可恢复性(容错)<br>系统应该为用户错误提供一些弹性，并允许用户从错误中恢复。这可能包括撤销功能、确认破坏性操作、“软”删除等<br>如命令模式中的撤销支持、Unity删除文件之前的破坏性操作询问、Notable的删除缓冲</li></ul><h3 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h3><p>MVC模式指代<strong>模型-视图-控制器</strong>，其中视图展示在用户面前(也就是UI，用户接口，连接用户和软件)，当用户使用视图的时候，操作通过控制器最终施加在模型上，完成逻辑操作</p><h4 id="请注意！"><a href="#请注意！" class="headerlink" title="请注意！"></a>请注意！</h4><ul><li>用户界面设计在系统架构设计之后</li><li>在客户端为每个组件设计UI(或MVC架构模式中的视图)</li><li>系统用户通常通过界面而不是功能来判断一个系统(毕竟人类都是视觉动物，像我就觉得eclipse界面很丑)</li><li>糟糕的界面会导致用户犯错(误导用户)</li><li>糟糕的界面可能导致软件系统永远不会被使用(你根本不知道它在哪)</li></ul><h2 id="糟糕的UI设计"><a href="#糟糕的UI设计" class="headerlink" title="糟糕的UI设计"></a>糟糕的UI设计</h2><ul><li>缺乏一致性</li><li>没有指导/帮助</li><li>没有上下文敏感性</li><li>不良反应</li><li>不友好<blockquote><ul><li>Lack of consistency</li><li>Too much memorization No guidance / help</li><li>No context sensitivity</li><li>Poor response</li><li>Unfriendly </li></ul></blockquote></li></ul><h2 id="设计流程"><a href="#设计流程" class="headerlink" title="设计流程"></a>设计流程</h2><p>界面分析 -&gt; 界面设计 -&gt; 界面实现 -&gt; 界面验证 -&gt; 界面分析 -&gt; …</p><h3 id="界面分析-Interface-Analysis"><a href="#界面分析-Interface-Analysis" class="headerlink" title="界面分析(Interface Analysis)"></a>界面分析(Interface Analysis)</h3><p>界面分析意味着设计师理解将通过接口与系统交互的人(最终用户)之间的关系<br>•终端用户必须完成的任务<br>•作为界面一部分呈现的内容<br>•执行这些任务的环境</p><h3 id="界面设计-Interface-Design"><a href="#界面设计-Interface-Design" class="headerlink" title="界面设计(Interface Design)"></a>界面设计(Interface Design)</h3><ul><li>使用接口分析过程中开发的信息定义接口对象(GUI组件)和操作</li><li>定义导致用户界面状态改变的事件(用户动作)。模式化这类行为</li><li>描述每个界面状态，因为它将实际看向最终用户。</li><li>指示用户如何从界面提供的信息解释系统的状态。</li></ul><h3 id="界面实现-Interface-Construction"><a href="#界面实现-Interface-Construction" class="headerlink" title="界面实现(Interface Construction)"></a>界面实现(Interface Construction)</h3><ul><li>从一个能够评估使用场景的原型开始</li><li>继续使用开发工具来完成实现</li></ul><h3 id="界面验证-Interface-Design"><a href="#界面验证-Interface-Design" class="headerlink" title="界面验证(Interface Design)"></a>界面验证(Interface Design)</h3><p>验证界面是否满足以下几点：</p><ul><li>界面是否能够正确地实现每个用户任务，适应所有任务变化，并实现所有一般用户需求</li><li>界面是否易于使用和学习</li><li>用户是否接受界面作为他们工作中有用的工具</li></ul><h2 id="具体的设计点"><a href="#具体的设计点" class="headerlink" title="具体的设计点"></a>具体的设计点</h2><h3 id="交互类型"><a href="#交互类型" class="headerlink" title="交互类型"></a>交互类型</h3><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-08-16-33-32.png"><br>直接操作、菜单选择、表单填充、命令行、自然语言各自的优缺点</p><h3 id="信息展示"><a href="#信息展示" class="headerlink" title="信息展示"></a>信息展示</h3><p>需要考虑这么几个点：</p><ul><li>用户是否对精确的信息或数据关系感兴趣?<br>考虑到精度的选择，比如在图像渲染中选择高精度浮点数、中等还是低精度浮点数；选择float还是double</li><li>信息价值的变化有多快?更改必须立即说明吗?<br>实时更新/每十分钟更新数据等等</li><li>用户必须采取一些行动来响应变化吗?</li><li>是否有直接操作界面?</li><li>信息是文本还是数字?相对价值重要吗?</li></ul><h3 id="颜色选用"><a href="#颜色选用" class="headerlink" title="颜色选用"></a>颜色选用</h3><p>颜色为界面增加了额外的维度，可以帮助用户理解复杂的信息结构<br>颜色可以用来突出特殊事件</p><h4 id="颜色的常见错误"><a href="#颜色的常见错误" class="headerlink" title="颜色的常见错误"></a>颜色的常见错误</h4><ul><li>丑陋的颜色(滥用对比色等等)</li><li>表达意义时颜色选择不当(用红色表示正确、绿色表示错误等等)</li><li>显示器过度使用色彩(使整个界面花里胡哨)</li></ul><h3 id="GUI组件"><a href="#GUI组件" class="headerlink" title="GUI组件"></a>GUI组件</h3><h4 id="移动应用UI"><a href="#移动应用UI" class="headerlink" title="移动应用UI"></a>移动应用UI</h4><p>主界面<br>次要界面：对话框、tab文件夹、下拉菜单<br>表单、菜单栏、工具栏、滚动栏、状态栏、文本框、复选框、单选按钮、命令按钮等</p><h4 id="web应用UI"><a href="#web应用UI" class="headerlink" title="web应用UI"></a>web应用UI</h4><p>主界面等等<br>导航设计：考虑导航的逻辑，这样用户就不会迷失在网页的“超空间”中</p><h3 id="评估设计"><a href="#评估设计" class="headerlink" title="评估设计"></a>评估设计</h3><ul><li>学习速度<br>用户学习和使用系统/产品的速度</li><li>操作速度<br>系统对用户操作响应的速度</li><li>容错率<br>系统对用户错误操作的容忍度如何</li><li>恢复程度<br>系统从用户的错误操作中恢复出来的能力如何</li><li>适应性<br>系统与某一模型关联的紧密程度</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>•界面设计应该以用户为中心。界面应该具有逻辑性和一致性，并帮助用户从错误中恢复<br>•交互风格包括直接操作，菜单系统，表单填写，命令语言和自然语言<br>•图形显示应用于显示趋势和近似值。当精度要求时，数字显示<br>颜色的使用要有节制和一致性<br>•系统应该提供在线帮助<br>•错误消息应该是积极的而不是消极的<br>•应提供一系列不同类型的用户文档<br>•理想情况下，用户界面应该根据可用性规范进行评估</p><hr><h2 id="UX设计-用户体验设计"><a href="#UX设计-用户体验设计" class="headerlink" title="UX设计(用户体验设计)"></a>UX设计(用户体验设计)</h2><p>UX是跨学科的，结合了设计、人机交互、市场、经济学等等<br>用户体验(缩写为UX)是一个人与系统交互时的感觉。要想你的产品成功，不管它的功能有多好，用户必须享受使用和浏览它<br>HCI：人机交互(Human-Computer Interaction)</p><h3 id="需求层级"><a href="#需求层级" class="headerlink" title="需求层级"></a>需求层级</h3><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-08-17-01-11.png" style="float: right; display: inline;"><p>最基本的需求从金字塔的底部开始，直到金字塔顶端的最高需求。<br>如果基本需求没有得到满足，就很难找到满足更高需求的欲望和动力。</p><ul><li>用户体验金字塔的基本需求是功能和信息。</li><li>更高的需求是美学和可用性</li></ul><h4 id="功能与信息"><a href="#功能与信息" class="headerlink" title="功能与信息"></a>功能与信息</h4><p>需求金字塔的底层，同时也是UX必须满足的两个基本要求</p><h5 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h5><p>当接口能够正常工作而不中断时，这种需求就得到了满足<br>接口几乎没有bug，所有点击的内容都会带用户去他们想去的地方<br>为了开始处理你的界面的功能，你必须知道你的<strong>界面将执行什么任务</strong>以及<strong>它们将如何完成</strong></p><h5 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h5><p>为了有意义和有价值的用户体验，信息必须是:</p><ul><li>有用的:你的内容应该是原创的，满足需求。</li><li>可用的:网站必须易于使用。</li><li>可取的:图像、身份、品牌和其他设计元素被用来唤起情感和欣赏。内容需要可导航和可定位的现场和非现场</li><li>可访问的:内容需要残疾人可访问</li><li>可信的:用户必须信任和相信你告诉他们的</li></ul><h4 id="美观与易用"><a href="#美观与易用" class="headerlink" title="美观与易用"></a>美观与易用</h4><p>需求金字塔的高层，界面需要一个独特的，友好的和专业的外观，使它从人群中<strong>脱颖而出</strong></p><h5 id="美观"><a href="#美观" class="headerlink" title="美观"></a>美观</h5><p>好的美学是让用户记住界面的东西。它甚至可以帮助你在用户中创建一个忠实的追随者<br>通过检查外观，用户应该了解你的界面的价值和个性</p><h5 id="易用性"><a href="#易用性" class="headerlink" title="易用性"></a>易用性</h5><p>当大多数人谈到用户体验时，他们指的是可用性，这是用户体验层次的最高需求。</p><ul><li><p>高易用性可以提高用户的工作效率。</p></li><li><p>具有高可用性的界面允许用户快速准确地完成任务。</p><blockquote><p>然而，大多数界面很少能充分发挥可用性。这是因为大多数界面都有很多任务，总有一些任务用户会在上面犯错误。<br>为了充分满足这一需求，有必要分析用户在界面中完成每项任务所需的准确性和速度,这需要:</p><ul><li>把界面放在用户面前，观察他们的行为。</li><li>还需要批判性的设计思维，提出澄清和简化用户流程的解决方案。</li></ul></blockquote></li><li><p>当用户能够持续快速地完成每项任务而不出错时，界面就满足了其可用性需求。</p><blockquote><p>在这点上，用户体验可以总结为“用户是否拥有尽可能愉快的体验?”</p></blockquote></li></ul><h3 id="UX测试"><a href="#UX测试" class="headerlink" title="UX测试"></a>UX测试</h3><h4 id="A-B测试"><a href="#A-B测试" class="headerlink" title="A/B测试"></a>A/B测试</h4><p>A/B测试软件——将一个网站的流量分成两个相等的部分。一组查看版本A，另一组查看版本b。每个版本的转换率和跳出率等统计数据都会被跟踪</p><h3 id="UX的限制和困难"><a href="#UX的限制和困难" class="headerlink" title="UX的限制和困难"></a>UX的限制和困难</h3><ul><li>无法设计出一个适合所有人的、理想的用户体验设计，必须做出一些妥协</li><li>难以客观地衡量UX的有效性</li><li>传统的网页评估指标，如“页面浏览量”，不能用来评估用户体验设计的有效性</li><li>UX设计师不一定具有技术背景，这可能会导致他们与开发者在设计建议上产生矛盾</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件工程与软件过程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端布局要义</title>
      <link href="/2021/06/06/%E5%89%8D%E7%AB%AF%E5%B8%83%E5%B1%80%E8%A6%81%E4%B9%89/"/>
      <url>/2021/06/06/%E5%89%8D%E7%AB%AF%E5%B8%83%E5%B1%80%E8%A6%81%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h2 id="问题剖析"><a href="#问题剖析" class="headerlink" title="问题剖析"></a>问题剖析</h2><p>最近写web实验的时候经常遇到一个头疼的事情，也就是我发现自己不知道怎么实现页面上一些图片错落有致的布局形式。想想应该用的是div这些东西卡好位置之后再填充图片和文字进去，但是对div怎么卡位置还有点模糊。<br>总的来说就是摸鱼太久了啦。</p><h2 id="布局基本概念"><a href="#布局基本概念" class="headerlink" title="布局基本概念"></a>布局基本概念</h2><h3 id="两大工具-div与span"><a href="#两大工具-div与span" class="headerlink" title="两大工具: div与span"></a>两大工具: div与span</h3><p><strong>div-块级元素</strong><br></p><blockquote><p>&lt;div&gt; 元素是块级元素，它可用于组合其他 HTML 元素的容器,没有特定的含义。</p><ul><li>属于块级元素，浏览器会在其前后显示折行。</li><li>如果与 CSS 一同使用，&lt;div&gt; 元素可用于对大的内容块设置样式属性。</li></ul></blockquote><p>&lt;div&gt; 元素的常见的用途是文档布局。它取代了使用表格定义布局的老式方法。使用 &lt;table&gt; 元素进行文档布局不是表格的正确用法, &lt;table&gt; 元素的作用是显示表格化的数据。</p><p><strong>span-内联元素</strong><br></p><blockquote><p>&lt;span&gt; 元素是内联元素，可用作文本的容器，没有特定的含义。</p></blockquote><p>当与 CSS 一同使用时，&lt;span&gt; 元素可用于为某一部分特定的文本设置样式属性。</p><h2 id="网站布局"><a href="#网站布局" class="headerlink" title="网站布局"></a>网站布局</h2><h3 id="良好的布局习惯"><a href="#良好的布局习惯" class="headerlink" title="良好的布局习惯"></a>良好的布局习惯</h3><p>良好的布局习惯中，我们一般用&lt;header&gt;、 &lt;footer&gt;、 &lt;section&gt;等标签划分每个页面逻辑的代码块。<br><strong>注意</strong><br>这些标签类似&lt;div&gt; 和 &lt;span&gt; ，其实都没有实际的含义，只是用于划开一个区域</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;section1&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--something--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是页脚<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用CSS划分区域"><a href="#使用CSS划分区域" class="headerlink" title="使用CSS划分区域"></a>使用CSS划分区域</h3><p>当我们用div分好区块，我们只是在布局逻辑的层面上划分好了区块而已。当我们真的要调整这些区块的位置时，就需要使用CSS。</p><h4 id="盒子模型-box-model"><a href="#盒子模型-box-model" class="headerlink" title="盒子模型(box model)"></a>盒子模型(box model)</h4><ul><li>所有的html元素都可以看作一个盒子</li><li>每个html元素有内边距、外边距、边框和内容物<blockquote><ul><li>Margin(外边距) - 清除边框外的区域，外边距是透明的。<blockquote><p>margin没有颜色，完全透明<br>margin可以单独改变元素的上下左右边距，也可以一次改变所有的属性<br>margin并不是用来布局的 (虽然他一定程度上确实可以，但是调margin并不会让一个块级元素变成内联)</p></blockquote></li><li>Border(边框) - 围绕在内边距和内容外的边框。</li><li>Padding(内边距) - 清除内容周围的区域，内边距是透明的。<blockquote><p>padding定义元素边框与元素内容之间的空间，即上下左右的内边距<br>当元素的 padding（填充）内边距被清除时，所释放的区域将会受到元素背景颜色的填充</p></blockquote></li><li>Content(内容) - 盒子的内容，显示文本和图像。</li></ul></blockquote></li></ul><p>盒子模型的作用在于如何调整内容物的位置等等</p><h4 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h4><p>我们用定位来调整div元素的位置。定位有五种：</p><ul><li>static<br>静态定位即没有定位，遵循正常的文档流对象。<br>元素不会受到 top, bottom, left, right影响。</li><li>relative<br>相对定位元素的定位是<strong>相对其正常位置</strong>。<br>相对正常的位置指的是在静态定位的情况下，元素应该处于的位置。</li><li>fixed<br>固定定位，元素的位置相对于浏览器窗口是固定位置。<br>即使窗口是滚动的它也不会移动，适用于广告和网页背景。</li><li>absolute<br>绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于&lt;html&gt;<br>absolute 定位使元素的位置与文档流无关，因此不占据空间，可以和其他元素重叠。<br>对于重叠的元素，可以用z-index调整覆盖关系。</li><li>sticky<br>粘性定位依赖于用户的滚动，元素在 position:relative 与 position:fixed 定位之间切换。<br>它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像position:fixed;，它会固定在目标位置。<br>元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。</li></ul><h2 id="页眉"><a href="#页眉" class="headerlink" title="页眉"></a>页眉</h2><h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><p>经常会用到边框作为导航栏之上的页眉，如下图<br><img src="https://raw.githubusercontent.com/Guiny-Time/Guiny-Time.github.io/main/images/attachmentsyemei.png"></p><p style="    border-left-style: solid;    border-width:5px;    border-color: #E5954D;    background-color: #FFF6D7;">我是边框<br>确实</p><h3 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h3><h2 id="页脚"><a href="#页脚" class="headerlink" title="页脚"></a>页脚</h2>]]></content>
      
      
      <categories>
          
          <category> web信息处理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021/6/5~2021/6/9涩图精选</title>
      <link href="/2021/06/05/%E6%B6%A9%E5%9B%BE2021-6-5/"/>
      <url>/2021/06/05/%E6%B6%A9%E5%9B%BE2021-6-5/</url>
      
        <content type="html"><![CDATA[<div class="justified-gallery"><p><img src="https://pixiv.cat/89437956.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90281512-1.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90281866.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90305978.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90293195.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90302417.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90316803.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90307332.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90299457.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90293517.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90291724.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90297150.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90294146-1.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90294146-4.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90294146-5.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90294146-7.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90294146-8.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90294146-9.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90294146-12.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90294146-15.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90294146-16.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90294146-19.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90297208.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90299492.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90316535-1.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90294319-1.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90294319-2.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90294319-3.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90294319-7.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90294319-9.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90294319-12.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90294319-13.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90294319-14.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90294319-17.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90294319-19.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90325444.jpg" alt="Pixiv.Cat"></p><p><img src="https://pixiv.cat/90302397.jpg" alt="Pixiv.Cat"></p><p><img src="https://pixiv.cat/90339383-1.jpg" alt="Pixiv.Cat"></p><p><img src="https://pixiv.cat/90339383-2.jpg" alt="Pixiv.Cat"></p><p><img src="https://pixiv.cat/90339383-3.jpg" alt="Pixiv.Cat"></p><p><img src="https://pixiv.cat/90339383-4.jpg" alt="Pixiv.Cat"></p><p><img src="https://pixiv.cat/90339383-5.jpg" alt="Pixiv.Cat"></p><p><img src="https://pixiv.cat/90339383-6.jpg" alt="Pixiv.Cat"></p><p><img src="https://pixiv.cat/90325137-1.jpg" alt="Pixiv.Cat"></p><p><img src="https://pixiv.cat/90321129.jpg" alt="Pixiv.Cat"></p><p><img src="https://pixiv.cat/90340035.jpg" alt="Pixiv.Cat"></p><p><img src="https://pixiv.cat/90318831.jpg" alt="Pixiv.Cat"></p><p><img src="https://pixiv.cat/90330826.jpg" alt="Pixiv.Cat"></p><p><img src="https://pixiv.cat/90339912.jpg" alt="Pixiv.Cat"></p><p><img src="https://pixiv.cat/90324361.jpg" alt="Pixiv.Cat"></p><p><img src="https://pixiv.cat/90317915.jpg" alt="Pixiv.Cat"></p><p><img src="https://pixiv.cat/90338117.jpg" alt="Pixiv.Cat"></p><p><img src="https://pixiv.cat/90327857.jpg" alt="Pixiv.Cat"><br><img src="https://pixiv.cat/90369328.jpg"></p><p><img src="https://pixiv.cat/90365455.jpg"></p><p><img src="https://pixiv.cat//90347904.jpg"></p><p><img src="https://pixiv.cat/90347943.jpg"></p><p><img src="https://pixiv.cat/90364617.jpg"></p><p><img src="https://pixiv.cat/90371034.jpg"></p><p><img src="https://pixiv.cat/90362442.jpg"></p><p><img src="https://pixiv.cat/90334896.jpg"></p><p><img src="https://pixiv.cat/90356032.jpg"></p><p><img src="https://pixiv.cat/90325697-1.jpg"></p><p><img src="https://pixiv.cat/90370369.jpg"></p><p><img src="https://pixiv.cat/90349856.jpg"></p><p><img src="https://pixiv.cat/90346155.jpg"><br><img src="https://pixiv.cat/90381253.jpg"></p><p><img src="https://pixiv.cat/90358374.jpg"></p><p><img src="https://pixiv.cat/90349918.jpg"><br><img src="https://pixiv.cat/90380805-1.jpg"><br><img src="https://pixiv.cat/90387307.jpg"><br><img src="https://pixiv.cat/90395080.jpg"><br><img src="https://pixiv.cat/90379944.jpg"><br>画的是三体中的红岸基地（妙啊<br><img src="https://pixiv.cat/90389930-3.jpg"><br><img src="https://pixiv.cat/90389930-4.jpg"><br><img src="https://pixiv.cat/90391148-1.jpg"><br><img src="https://pixiv.cat/90369040.jpg"><br><img src="https://pixiv.cat/90380507.jpg"><br><img src="https://pixiv.cat/90388496.jpg"><br><img src="https://pixiv.cat/90367612.jpg"><br><img src="https://pixiv.cat/90425312.jpg"><br><img src="https://pixiv.cat/90391947.jpg"><br><img src="https://pixiv.cat/90380216.jpg"><br><img src="https://pixiv.cat/90416969.jpg"><br><img src="https://pixiv.cat/90403519.jpg"><br><img src="https://pixiv.cat/90379934.jpg"><br><img src="https://pixiv.cat/90416980.jpg"><br><img src="https://pixiv.cat/90398962.jpg"><br><img src="https://pixiv.cat/90415485.jpg"><br><img src="https://pixiv.cat/90405261.jpg"><br><img src="https://pixiv.cat/90386845.jpg"><br><img src="https://pixiv.cat/90403613.jpg"><br><img src="https://pixiv.cat/90404694.jpg" alt="Pixiv.Cat"></p>          </div>]]></content>
      
      
      <categories>
          
          <category> 涩图 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ch24: 卡方测试</title>
      <link href="/2021/05/28/Ch24%EA%9E%89%20%E5%8D%A1%E6%96%B9%E6%B5%8B%E8%AF%95/"/>
      <url>/2021/05/28/Ch24%EA%9E%89%20%E5%8D%A1%E6%96%B9%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Ch24-卡方测试"><a href="#Ch24-卡方测试" class="headerlink" title="Ch24: 卡方测试"></a>Ch24: 卡方测试</h1><p>书本p672~p692</p><h2 id="卡方值图"><a href="#卡方值图" class="headerlink" title="卡方值图"></a>卡方值图</h2><p>或者说，有点歪的正态曲线(实际上完全不是正态曲线)<br><img src="/.com//Clipboard_2021-05-28-08-48-48.png"></p><h2 id="临界卡方值"><a href="#临界卡方值" class="headerlink" title="临界卡方值"></a>临界卡方值</h2><p>根据卡方值表，利用自由度df与重要性指数α获得值<br>值得注意的是，卡方值表中的横轴是右侧面积<br><img src="/.com//Clipboard_2021-05-28-08-47-57.png"></p><h2 id="卡方拟合优度测试-chi-square-Goodness-of-Fit-Tests"><a href="#卡方拟合优度测试-chi-square-Goodness-of-Fit-Tests" class="headerlink" title="卡方拟合优度测试(chi-square Goodness-of-Fit Tests)"></a>卡方拟合优度测试(chi-square Goodness-of-Fit Tests)</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>指的是<strong>原假设认为数据属于均匀分布</strong>，而<strong>备择假设认为数据不属于均匀分布</strong>，现在需要是否能够<strong>推翻原假设</strong><br>比如原假设认为十二星座对就业不影响，而现在想验证十二星座能影响就业(推翻不影响的原假设</p><blockquote><p><strong>一个类别变量</strong>的计数分布是否与模型预测的分布相匹配的检验称为拟合优度检验。<br>在卡方拟合优度检验中，预期计数来自预测模型。检验从n - 1个自由度的卡方模型中找到一个p值，其中n是类别变量中的类别数</p></blockquote><h3 id="前提条件判断"><a href="#前提条件判断" class="headerlink" title="前提条件判断"></a>前提条件判断</h3><ul><li>计数数据条件(Counted Data Condition): 该数据必须是一个分类变量的类别计数。</li><li>独立性假设(Independence Assumption): 单位内的计数应该是相互独立的。</li><li>样本量假设(Frequency Condition): 我们必须有足够的数据才能使方法工作，所以我们通常检查期望单位频率条件。我们预计每个单位中至少有5个个体<h3 id="计算卡方值"><a href="#计算卡方值" class="headerlink" title="计算卡方值"></a>计算卡方值</h3>s是样本标准差，而σ是总体标准差<br><img src="/.com//Clipboard_2021-05-28-08-46-15.png"><br>实际值-观测值得到的结果也被称为<strong>残差(Residual)</strong><h3 id="计算P值"><a href="#计算P值" class="headerlink" title="计算P值"></a>计算P值</h3>df的值：<strong>类别</strong>-1(比如12星座的例子，df为12 - 1 = 11)<br>利用计算卡方值与df的值，在卡方值表查找p值的大小(一般为右尾测试)<br><img src="/.com//Clipboard_2021-06-10-11-36-06.png"><br><img src="/.com//Clipboard_2021-06-10-11-37-03.png"></li></ul><h2 id="卡方同一性测试-The-χ2-test-for-homogeneity"><a href="#卡方同一性测试-The-χ2-test-for-homogeneity" class="headerlink" title="卡方同一性测试(The χ2-test for homogeneity)"></a>卡方同一性测试(The χ2-test for homogeneity)</h2><p>卡方同一测试的目的是是否能够<strong>证实某种理论是正确的</strong></p><blockquote><p>对<strong>同一分类变量</strong>的<strong>两组或多组计数分布</strong>进行比较的检验，即一个变量相对于不同类别的分布<br>同质性卡方检验发现基于总体频率的预期计数，在(零假设)假设下调整每组的总数，每个组的分布是相同的。我们从(#Rows - 1) * (#Cols - 1)自由度的卡方分布中找到一个p值，其中#Rows表示类别的数量，#Cols表示独立组的数量</p></blockquote><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><ul><li>计数数据条件: 该数据必须是一个分类变量的类别计数。</li><li>独立性假设:单位内的计数应该是相互独立的。</li><li>单位频率条件:我们必须有足够的数据才能使这些方法工作，所以我们通常检查期望单位频率条件。我们预计每个单位中至少有5个个体。<h3 id="计算卡方值-1"><a href="#计算卡方值-1" class="headerlink" title="计算卡方值"></a>计算卡方值</h3><img src="/.com//Clipboard_2021-05-28-08-46-15.png"><br>并不是所有时候都会直接把期望值列出来。拟合优度检测专注于寻找几种不同的分组(cell)的概率是否相同。我们需要利用求和之后的占比乘以该分组的总数才能获得期望值</li></ul><h3 id="计算p值"><a href="#计算p值" class="headerlink" title="计算p值"></a>计算p值</h3><p>首先计算df。同质性测试中，df的值为(R - 1)(C - 1)<br>根据df与卡方值，在卡方表中找到p值</p><h3 id="标准残差"><a href="#标准残差" class="headerlink" title="标准残差"></a>标准残差</h3><p>计算公式：<img src="/.com//Clipboard_2021-05-31-08-41-27.png"></p><blockquote><p>这些标准化残差就是我们为每个单元计算的分量的平方根，它们的符号表明我们观察到的情况是比我们预期的多，还是更少<br>即：最可能…和最不可能…<br>当我们拒绝卡方检验时，对标准化残差的检验有时可以揭示更多关于数据如何偏离零模型的信息</p></blockquote><h2 id="卡方独立性测试-Chi-Square-independence-test"><a href="#卡方独立性测试-Chi-Square-independence-test" class="headerlink" title="卡方独立性测试(Chi-Square independence test)"></a>卡方独立性测试(Chi-Square independence test)</h2><p>当问到在<strong>同一总体</strong>上测量的<strong>两个变量是否独立</strong>时，我们使用卡方独立性检验</p><blockquote><p>两个分类变量是否独立的检验检验了根据两个变量分类的一组个体的计数分布。<br>独立卡方检验通过假设知道边际总数就能告诉我们细胞频率，假设变量之间没有关联来发现预期计数。这和同质性测试的计算是一样的。我们从(#Rows - 1) * (#Cols - 1)自由度的卡方分布中找到一个p值，其中#Rows表示一个变量中的类别数，#Cols表示另一个变量中的类别数</p></blockquote><ul><li>原假设：两个变量独立</li><li>备择假设：两个变量不独立</li><li>自由度df = (r - 1)*(c - 1)</li><li>卡方值<br><img src="/.com//Clipboard_2021-05-28-08-46-15.png"></li><li>p值：和前面的算法一样</li></ul><p>这个卡方测试也是右尾测试，基本逻辑和前面一样</p><h2 id="容易犯错的点"><a href="#容易犯错的点" class="headerlink" title="容易犯错的点"></a>容易犯错的点</h2><h3 id="警惕大样本"><a href="#警惕大样本" class="headerlink" title="警惕大样本"></a>警惕大样本</h3><p>当样本数量过大时，自由度也随之上升，卡方表上得出的结论</p><h3 id="依赖？"><a href="#依赖？" class="headerlink" title="依赖？"></a>依赖？</h3><p>当两个变量是相关的时候，你只能说他们有联系，而不应该说他们是相互依赖的</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>卡方检验要求变量有计数，如果一个测试的cell值是定量的，那么它不适合用于卡方测试</p><h2 id="判断使用哪种卡方测试"><a href="#判断使用哪种卡方测试" class="headerlink" title="判断使用哪种卡方测试"></a>判断使用哪种卡方测试</h2><p>首先，你应该分析题干是针对一个变量分析还是两个变量</p><blockquote><ul><li>一个变量：卡方拟合优度测试</li><li>两个变量：卡方同质性检测或卡方独立性检测</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 统计学导论 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ch23: 对比数据检测</title>
      <link href="/2021/05/27/Ch23%EA%9E%89%20%E5%AF%B9%E6%AF%94%E6%95%B0%E6%8D%AE%E6%A3%80%E6%B5%8B/"/>
      <url>/2021/05/27/Ch23%EA%9E%89%20%E5%AF%B9%E6%AF%94%E6%95%B0%E6%8D%AE%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Ch23-对比数据检测"><a href="#Ch23-对比数据检测" class="headerlink" title="Ch23: 对比数据检测"></a>Ch23: 对比数据检测</h1><p>书本p647~p660</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>对于对比数据检测，第一步需要判断实验是否满足对比检测的三个假设条件<br>使用<strong>t测试</strong>，而不是z测试。计算出t值之后，再<strong>求p值</strong>，然后进行判断能否推翻原假设</p><h2 id="对比数据"><a href="#对比数据" class="headerlink" title="对比数据"></a>对比数据</h2><p>对比数据指的是<strong>同一组数据</strong>前后的变化、内外的变化一流</p><ol><li>当观察结果成对收集或一组的观察结果自然地与另一组的观察结果相关时，数据就是成对的。</li><li>配对最简单的形式是对每个受试者进行两次测量——通常是在治疗前和治疗后。在实验中更复杂的配对形式是一种阻塞形式，在其他情况下也会出现。</li><li>观测数据和调查数据的配对是一种匹配形式。</li><li>我们感兴趣的是每对的差异。</li></ol><h2 id="对比检测的假设条件"><a href="#对比检测的假设条件" class="headerlink" title="对比检测的假设条件"></a>对比检测的假设条件</h2><ul><li>数据配对条件: 必须<strong>对数据进行配对</strong>。</li><li>独立性假设: 如果数据是成对的，则组不是独立的。对于这些方法，必须是<strong>彼此独立</strong>的差异。<blockquote><p>统计学中的勾股定理只适用于独立的随机变量，当变量不独立时，勾股定理不起作用</p></blockquote></li><li>接近正态分布: 我们需要假设<strong>差异(difference,指的是两组样本数据的差值)的总体</strong>接近<strong>正态分布模型</strong>。我们不需要检查每一组。这种情况可以用差异的直方图或正态概率图来检查，但不能用个体组来检查。一般来说，即使你的原始测量是倾斜的或双峰的，差异可能是接近正态的。</li></ul><h2 id="对比检测步骤"><a href="#对比检测步骤" class="headerlink" title="对比检测步骤"></a>对比检测步骤</h2><h3 id="原假设与备择假设"><a href="#原假设与备择假设" class="headerlink" title="原假设与备择假设"></a>原假设与备择假设</h3><p>这个跟题干关系比较大…如果题干问的是“能否证明不变”，那么备择假设就是<br>H<sub>A</sub>: p = 0(z-test)或者H<del>A</del>: μ<del>d</del> = 0(t-test)</p><h3 id="计算差值均值与标准差"><a href="#计算差值均值与标准差" class="headerlink" title="计算差值均值与标准差"></a>计算差值均值与标准差</h3><p>μ<del>d</del> = Σd/n<br>S<sub>d</sub> = 根号下Σ(x-x<sub>d</sub>)<sup>2</sup>)/(n-1)</p><h3 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h3><h4 id="配对T-测试-Paired-T-test"><a href="#配对T-测试-Paired-T-test" class="headerlink" title="配对T-测试(Paired T-test)"></a>配对T-测试(Paired T-test)</h4><ul><li>计算自由度df<br>df = n - 1，其中n为配对数(count of pairs)</li><li>计算t值<br>计算公式：<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedane20210704182728.png" style="zoom:67%;"><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedane20210704182749.png" style="zoom:67%;"><br>其中d<sup>-</sup>与S<sub>d</sub>就是前面计算得到的均值<br>S<del>d</del>/根号n 是差值d的标准误差(SE(d<sup>-</sup>))</li><li>计算P值<br>需要使用t表查询。配对测试似乎都是双尾测试，所以P = 2P(t<del>n-1</del>&gt;t*)<br>得出P值之后，判断P值与α的关系：</li><li>若P小于α则拒绝原假设</li><li>若P大于α，不一定能拒绝原假设</li></ul><h3 id="求置信区间CI"><a href="#求置信区间CI" class="headerlink" title="求置信区间CI"></a>求置信区间CI</h3><p>ME = t*<del>n-1</del> SE(d^-)</p><p>公式：<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedane20210704183022.png" style="zoom:80%;"></p><p>CI区间的含义：<br>我们有95%(或者别的数值)的信心认为，μ<sub>d</sub>落于这个区间范围</p><h2 id="请注意不要对对比数据使用两组数据检测的方法"><a href="#请注意不要对对比数据使用两组数据检测的方法" class="headerlink" title="请注意不要对对比数据使用两组数据检测的方法"></a>请注意不要对对比数据使用两组数据检测的方法</h2><p>当<strong>样本不是独立</strong>的时候，不要使用两样本方法。<br>当这种独立性假设被违反时，这些方法给出了错误的答案。<br>良好的随机抽样通常是独立群体的最佳保证。<strong>确保这两个群体之间没有关系</strong>。配对设计经常出现，也很重要，但不能用本章的方法进行分析。</p>]]></content>
      
      
      <categories>
          
          <category> 统计学导论 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>L8-设计模式</title>
      <link href="/2021/05/25/L8-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/05/25/L8-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="L8-设计模式"><a href="#L8-设计模式" class="headerlink" title="L8-设计模式"></a>L8-设计模式</h1><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>设计模式描述了一个在我们的环境中反复出现的问题，然后描述了该问题的核心解决方案，以这种方式，您可以使用该解决方案一百万次，而不必以同样的方式进行两次</p><blockquote><p>Design pattern describes a problem which occurs over and over again in our environment, and then describes the core of the solution to that problem, in such a way that you can use this solution a million times over, without ever doing it the same way twice</p></blockquote><p>设计模式使得优秀的设计与架构被反复使用</p><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><ul><li>寻找合适的对象<blockquote><p>•在设计中需要考虑的因素太多，例如，继承、封装、多态、单一责任、接口编程等<br>•确定设计方法</p></blockquote></li><li>确定对象的粒度<blockquote><p>•系统中对象的大小和数量<br>•类设计中的层次结构<br>•组合vs.继承</p></blockquote></li><li>提升重用性</li><li>为变革而设计</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>四人组对设计模式的划分有经典的23种，按照目的和范围可以划分为</p><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><ul><li>创造性<br>处理对象的创建</li><li>结构性<br>处理类与对象的构成关系</li><li>行为性<br>处理类或对象的交互与分配职责<h4 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h4></li><li>类<br>类与子类之间的关系，编译时的静态关系</li><li>对象<br>对象之间的关系，运行时的动态关系</li></ul><h3 id="模式元素"><a href="#模式元素" class="headerlink" title="模式元素"></a>模式元素</h3><ul><li>模式名<br>一个有意义的名字</li><li>问题领域<br>在上下文中反复遇到的问题，或者说此设计模式适用的问题发生的情况</li><li>解决方案<br>构成设计的元素、关系、责任和协作</li><li>反馈<br>使用该种设计模式的利弊<blockquote></blockquote></li></ul><p><strong>上下文情形</strong><br>描述了解决方案适用的问题类型<br><strong>问题</strong><br>问题指的是重复出现在上下文情景中<br><strong>解决方案</strong><br>构成设计的元素、关系、责任和协作</p><h3 id="如何选择设计模式"><a href="#如何选择设计模式" class="headerlink" title="如何选择设计模式"></a>如何选择设计模式</h3><ul><li><p>考虑设计模式如何解决设计问题。</p><blockquote><p>•如何识别合适的对象，<br>•如何确定对象的粒度，<br>•如何指定对象接口，<br>•如何指定对象实现，<br>•如何平衡类继承和接口继承，<br>•考虑接口编程，而不是实现编程。</p></blockquote></li><li><p>查找设计模式的意图以找到匹配。</p></li><li><p>了解设计模式之间的相互关系。</p></li><li><p>考虑一下如何使您的设计可重用。</p></li></ul><h3 id="设计模式总结"><a href="#设计模式总结" class="headerlink" title="设计模式总结"></a>设计模式总结</h3><h4 id="创造型设计模式"><a href="#创造型设计模式" class="headerlink" title="创造型设计模式"></a>创造型设计模式</h4><ul><li>抽象工厂模式<br>可以改变产品对象的种类</li><li>建造者模式<br>可以改变符合对象的创建方式</li><li>工厂模式<br>可以改变被实例化对象的子类</li><li>原型模式<br>可以改变被实例化的对象的一个类</li><li>单例模式<br>可以改变一个类的唯一实例</li></ul><h4 id="结构型设计模式总结"><a href="#结构型设计模式总结" class="headerlink" title="结构型设计模式总结"></a>结构型设计模式总结</h4><ul><li>适配器模式<br>可以改变对象的接口</li><li>桥接模式<br>可以改变对象的实现。</li><li>组合器模式<br>可以改变对象的结构和组合。</li><li>探测者模式<br>可以改变对象的职责而不需要子类化。</li><li>外观模式<br>可以改变子系统的接口。</li><li>享元模式<br>可以改变物品的存储成本。</li><li>代理模式<br>可以改变对象访问方式(它的位置)的代理</li></ul><h4 id="行为型设计模式总结"><a href="#行为型设计模式总结" class="headerlink" title="行为型设计模式总结"></a>行为型设计模式总结</h4><ul><li>责任链模式<br>可以改变一个对象来满足一个请求。</li><li>命令模式<br>在何时以及如何满足一个请求时可能会有所不同。</li><li>解释器模式<br>能改变一种语言的语法和解释的人。</li><li>迭代器模式<br>可以改变访问和/或遍历聚合元素的方式的迭代器。</li><li>中继者模式<br>对象可以改变对象之间的交互方式和交互方式。</li><li>Memento模式<br>这可以改变存储在对象外部的私有信息以及存储时间。</li><li>观察者模式<br>可以改变依赖于另一个对象的对象的数量;如何将相关对象保持最新。</li><li>状态模式<br>可以改变一个对象的状态。</li><li>策略模式<br>可以改变算法使用的策略。</li><li>模板方法模式(?<br>可以改变算法的步骤。</li><li>访问者模式<br>可以改变应用于对象的操作而不改变它们的类</li></ul><h3 id="请注意-不要对简单问题使用设计模式"><a href="#请注意-不要对简单问题使用设计模式" class="headerlink" title="请注意, 不要对简单问题使用设计模式"></a><font color="red">请注意, 不要对简单问题使用设计模式</font></h3><ul><li>设计模式使代码难以阅读/理解/调试。</li><li>设计模式使软件结构变得复杂。</li><li>不恰当地使用设计模式会让事情变得更糟。</li><li>不要用设计模式来解决简单的问题。</li></ul><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>在整个程序生命周期中只实例化一个对象，防止多个对象存在造成冲突等问题，并且提供一个全局方法可供访问(GetInstance()之类的)</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li>操作系统使用文件系统来管理文件</li><li>访问硬件的接口</li><li>静态配置数据(配置文件)</li><li>日志记录对象(Logger)</li><li>访问缓存存储</li><li>线程池<blockquote><p><strong>同步锁 synchronized</strong><br>Synchronized关键字确保每次只有一个线程可以访问被该关键字修饰的方法。<br>Synchronized public static void 方法名(para ){}</p></blockquote></li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrinterDriver</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> PrinterDriver printerDriver;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">PrinterDriver</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PrinterDriver <span class="title">getPrinterDriver</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果不存在则实例化</span></span><br><span class="line"><span class="keyword">if</span> (printerDriver == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (PrinterDriver.class) &#123;</span><br><span class="line">    <span class="keyword">if</span> (printerDriver == <span class="keyword">null</span>) &#123;</span><br><span class="line">      printerDriver = <span class="keyword">new</span> PrinterDriver();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> printerDriver;</span><br><span class="line">&#125;</span><br><span class="line">…</span><br></pre></td></tr></table></figure><h3 id="单例模式与静态类的区别"><a href="#单例模式与静态类的区别" class="headerlink" title="单例模式与静态类的区别"></a>单例模式与静态类的区别</h3><h4 id="可访问性"><a href="#可访问性" class="headerlink" title="可访问性"></a>可访问性</h4><ul><li>静态方法: 每个类都可以自由访问静态变量。</li><li>单例方法:易于控制谁获得实例<h4 id="灵活性"><a href="#灵活性" class="headerlink" title="灵活性"></a>灵活性</h4></li><li>静态方法方法:只复制一份</li><li>单例方法:如果需要，它可以配置一个指定数量的实例<h4 id="清晰程度"><a href="#清晰程度" class="headerlink" title="清晰程度"></a>清晰程度</h4></li><li>静态方法方法:可能污染命名空间</li><li>单例方法:不需要创建全局可见变量</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>对客户端访问实例化的类能够直接控制</li><li>可以取代全局变量</li><li>创建的实例化数目是可控的<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4></li><li>在多线程模式中需小心使用</li></ul><h3 id="类图结构"><a href="#类图结构" class="headerlink" title="类图结构"></a>类图结构</h3><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-05-25-16-27-29.png"></p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p><a href="https://www.runoob.com/design-pattern/factory-pattern.html">https://www.runoob.com/design-pattern/factory-pattern.html</a></p><h3 id="扩展与应用"><a href="#扩展与应用" class="headerlink" title="扩展与应用"></a>扩展与应用</h3><p>工厂方法模式将特定于应用程序的类从具体类型的实例化<strong>解耦</strong><br><strong>使用接口创建对象，但让子类决定实例化哪个类</strong><br>在以下情况下考虑使用工厂模式:</p><ul><li>一个类不能预测它必须创建的对象的类。</li><li>一个类希望它的子类指定它创建的对象。</li><li>类将责任委托给几个helper子类中的一个，你想本地化哪个helper子类是委托的知识。</li></ul><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><ul><li>功能抽象类(或者接口)<br>包含了一些需要被实现的方法，比如Shape</li><li>具体的小东西<br>实现了接口方法，比如Circle、Rectangle等等</li><li>工厂(提货)<br>含有工厂方法(比如display、print之类的)，一般是用string进行匹配实例化？</li></ul><h3 id="类图结构-1"><a href="#类图结构-1" class="headerlink" title="类图结构"></a>类图结构</h3><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-05-25-21-26-18.png"></p><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p><a href="https://www.runoob.com/design-pattern/facade-pattern.html">https://www.runoob.com/design-pattern/facade-pattern.html</a></p><h3 id="扩展与应用-1"><a href="#扩展与应用-1" class="headerlink" title="扩展与应用"></a>扩展与应用</h3><p>外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性，使子系统更易于使用</p><ul><li>为复杂的子系统提供一个简单的接口。</li><li>由于客户端和抽象的实现类之间存在许多依赖关系，所以将子系统从客户端解耦。</li><li>使用façade为分层设计的每个子系统定义一个入口点</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>操作系统使用façade将多个框架组合成一个。</li><li>程序编译器使用façade，让程序员的生活更轻松。</li><li>Web服务使用façade作为入口点。</li><li>数据库连接器，例如Java数据库连接(JDBC)使用façade来隐藏连接建立的复杂性。<br>或者说：<br>1、为复杂的模块或子系统提供外界访问的模块<br>2、子系统相对独立<br>3、预防低水平人员带来的风险</li></ul><h3 id="代码结构-1"><a href="#代码结构-1" class="headerlink" title="代码结构"></a>代码结构</h3><ul><li>各种子类(或者说子系统们)<br>之间的关系挺独立的，各自有各自的功能</li><li>外观类<br>内部实例化了这几个类的对象，实现了对应方法并对外提供可调用的接口</li></ul><h3 id="类图结构-2"><a href="#类图结构-2" class="headerlink" title="类图结构"></a>类图结构</h3><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-05-25-22-03-46.png"><br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-05-25-22-03-27.png"><br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-05-25-22-10-33.png"></p><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p><a href="https://www.runoob.com/design-pattern/adapter-pattern.html">https://www.runoob.com/design-pattern/adapter-pattern.html</a></p><h3 id="扩展与应用-2"><a href="#扩展与应用-2" class="headerlink" title="扩展与应用"></a>扩展与应用</h3><p>将类的接口转换为客户期望的另一个接口。适配器可以让类一起工作，否则由于不兼容的接口而无法工作</p><ul><li>使用一个现有的类，但它的接口与你需要的不匹配。</li><li>创建一个可重用的类，与不相关的或不可预见的类协作，也就是那些不一定有兼容接口的类。</li><li>使用几个现有的子类，但通过子类化每个人来调整它们的接口是不切实际的。对象适配器可以适应其父类的接口。</li></ul><h3 id="继承vs对象组合"><a href="#继承vs对象组合" class="headerlink" title="继承vs对象组合"></a>继承vs对象组合</h3><h4 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h4><ul><li>当我们想要适应一个类及其所有子类时，类适配器将无法工作。</li><li>适配器覆盖被适配的类的一些行为。<h4 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h4></li><li>一个适配器可以与许多适配器一起工作</li><li>适配器还可以一次为所有适配器添加功能。</li><li>很难覆盖被覆盖对象的行为</li></ul><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>多个数据库访问器</li><li>使用具有不兼容接口的工具包类</li><li>其他与桥接不兼容接口相关的通用问题<blockquote><p>例如，手机充电器和适配器，存储卡适配器，电子插头和适配器等</p></blockquote></li></ul><h3 id="代码结构-2"><a href="#代码结构-2" class="headerlink" title="代码结构"></a>代码结构</h3><ul><li>基础类<br>包含了一些有点过时的无法涵盖所有潜在问题的方法</li><li>进阶类<br>包含了新的解决潜在问题的方法</li><li>适配器<br>连接基础类和进阶类的桥梁，总之是要把两个合一块(我们三个就要在一起.jpg)</li></ul><p>之后，客户端通过基础类就可以通过适配器调用进阶类的方法以实现对应功能</p><h3 id="类图结构-3"><a href="#类图结构-3" class="headerlink" title="类图结构"></a>类图结构</h3><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-25-22-27-13.png"><br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-25-22-27-49.png"></p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p><a href="https://www.runoob.com/design-pattern/observer-pattern.html">https://www.runoob.com/design-pattern/observer-pattern.html</a></p><h3 id="扩展与应用-3"><a href="#扩展与应用-3" class="headerlink" title="扩展与应用"></a>扩展与应用</h3><p>在对象之间定义一对多的依赖关系，这样当一个对象改变状态时，它的所有依赖关系都会被通知并自动更新(一个分发布者与多个订阅者)</p><ul><li>当改变一个对象需要改变未知数量的其他对象。</li><li>当一个对象应该能够通知其他对象，而不假设这些对象是谁。</li><li>当一个抽象有两个方面，其中一个依赖于另一个</li></ul><h3 id="代码结构-3"><a href="#代码结构-3" class="headerlink" title="代码结构"></a>代码结构</h3><ul><li>发布者类<br>当发布者的状态改变的时候，发布这一消息</li><li>订阅者类<br>当发布者发布消息的时候，接收该消息并作出对应的反馈(也可以不反馈)</li></ul><p><strong>观察者模式可以只存在发布者而不存在订阅者</strong></p><h3 id="类图结构-4"><a href="#类图结构-4" class="headerlink" title="类图结构"></a>类图结构</h3><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-26-14-26-04.png"><br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-26-14-26-33.png"></p>]]></content>
      
      
      <categories>
          
          <category> 软件工程与软件过程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ch22: 两组样本的假设检测</title>
      <link href="/2021/05/16/Ch22%EA%9E%89%20%E4%B8%A4%E7%BB%84%E6%A0%B7%E6%9C%AC%E7%9A%84%E5%81%87%E8%AE%BE%E6%A3%80%E6%B5%8B/"/>
      <url>/2021/05/16/Ch22%EA%9E%89%20%E4%B8%A4%E7%BB%84%E6%A0%B7%E6%9C%AC%E7%9A%84%E5%81%87%E8%AE%BE%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="z测试"><a href="#z测试" class="headerlink" title="z测试"></a>z测试</h2><h3 id="检测前提"><a href="#检测前提" class="headerlink" title="检测前提"></a>检测前提</h3><ul><li>随机抽取条件:理想情况下，每组的数据应该独立地、随机地从人群中抽取，或通过随机比较实验产生。</li><li>10%条件:如果数据未经替换抽样，则在不调整标准差的情况下，样本应**不超过人口的10%**。</li><li>独立组假设:我们正在比较的<strong>两组必须相互独立</strong>。</li><li>成功/失败条件:两组都足够大，每个组<strong>至少有10次成功和10次失败</strong>。</li></ul><h3 id="原假设与备择假设"><a href="#原假设与备择假设" class="headerlink" title="原假设与备择假设"></a>原假设与备择假设</h3><p>H<sub>0</sub> : p<sub>1</sub> = p<sub>2</sub><br>H<sub>A</sub> : p<sub>1</sub> ≠ p<sub>2</sub><br>p指的是样本所代表的总体成功的概率</p><h3 id="测试步骤"><a href="#测试步骤" class="headerlink" title="测试步骤"></a>测试步骤</h3><ol><li><p>计算<strong>总体成功概率p</strong>。p的计算公式为：<br>x<sub>1</sub> + x<sub>2</sub><br>———<br>n<sub>1</sub> + n<sub>2</sub></p></li><li><p>通过数据求得<strong>样本z值</strong>。样本z值的计算公式为：<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/dameClipboard_2021-05-16-20-14-21.png"></p></li><li><p>求P值，比较关系</p></li></ol><h3 id="置信区间"><a href="#置信区间" class="headerlink" title="置信区间"></a>置信区间</h3><p>通过p计算标准误差，有<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-09-00-00-39.png" style="zoom:67%;"><br>于是，置信区间为<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-09-00-01-08.png" style="zoom:67%;"></p><h2 id="t测试"><a href="#t测试" class="headerlink" title="t测试"></a>t测试</h2><h3 id="检测前提-1"><a href="#检测前提-1" class="headerlink" title="检测前提"></a>检测前提</h3><ul><li>随机抽取条件：数据是随机抽取的(确保独立性原则)</li><li>接近正态条件：数据来自一个单峰和对称的分布</li></ul><h3 id="原假设与备择假设-1"><a href="#原假设与备择假设-1" class="headerlink" title="原假设与备择假设"></a>原假设与备择假设</h3><p>H<sub>0</sub> : μ<sub>1</sub> = μ<sub>2</sub><br>H<sub>A</sub> : μ<sub>1</sub> ≠ μ<sub>2</sub><br>μ指的是样本所代表的总体的均值</p><h3 id="测试步骤-1"><a href="#测试步骤-1" class="headerlink" title="测试步骤"></a>测试步骤</h3><ol><li>首先计算<strong>df的值</strong>(前提是知道s与μ)。计算公式如下：<img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-05-16-20-48-54.png" style="zoom:70%;">阿哲，这也太恶心了吧(而且值不是整数)，所以通常用pooled的方法求df</li></ol><p><strong>df = (n<del>1</del> - 1) + (n<del>2</del> - 1)</strong></p><ol start="2"><li><p>计算<strong>样本t值</strong>，计算公式如下：<br>如果用的是pool：<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-07-04-17-10-10.png"><br>如果用的不是pool：</p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-07-04-17-13-13.png" style="zoom:67%;"><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-07-04-17-13-29.png" style="zoom:67%;"></li><li><p>求P值，比较关系</p></li></ol><h3 id="置信区间-1"><a href="#置信区间-1" class="headerlink" title="置信区间"></a>置信区间</h3><p>通过s(样本内标准差)计算标准误差，有<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-07-04-17-13-29.png" style="zoom:67%;"><br>于是，置信区间为<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-09-00-02-09.png" style="zoom:67%;"></p>]]></content>
      
      
      <categories>
          
          <category> 统计学导论 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>L7-系统分析与设计</title>
      <link href="/2021/04/27/L7-%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
      <url>/2021/04/27/L7-%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="L7-系统分析与设计"><a href="#L7-系统分析与设计" class="headerlink" title="L7-系统分析与设计"></a>L7-系统分析与设计</h1><markdwon>  <details>    <summary><center>目标1：context-DFD(上下文数据流图)</center></summary><p>用于分析系统中数据的流向。在这个阶段我们只考虑整个程序和外部实体之间的联系</p><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-02-13-59-37.png"></p><h3 id="图样分析"><a href="#图样分析" class="headerlink" title="图样分析"></a>图样分析</h3><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-04-27-21-32-06.png"></p><h4 id="进程-Processing"><a href="#进程-Processing" class="headerlink" title="进程(Processing)"></a>进程(Processing)</h4><ul><li><strong>主要功能</strong>：接收数据、处理数据(过程黑箱)、输出数据</li><li>可以有多个输入输出</li><li>规范命名(最好是名词收尾的形式)</li></ul><h4 id="数据流-Data-Flow"><a href="#数据流-Data-Flow" class="headerlink" title="数据流(Data Flow)"></a>数据流(Data Flow)</h4><ul><li><strong>主要功能</strong>：显示数据流动的路径</li><li>可以表示一个或多个数据项</li><li>规范命名</li><li>路上至少经过一个进程</li></ul><h4 id="数据存储-Data-Storage"><a href="#数据存储-Data-Storage" class="headerlink" title="数据存储(Data Storage)"></a>数据存储(Data Storage)</h4><ul><li><strong>主要功能</strong>：表示存储的一个或多个将由进程处理的数据</li><li>不能与其他数据存储相连</li><li>规范命名</li></ul><h4 id="外部实体-External-Entity"><a href="#外部实体-External-Entity" class="headerlink" title="外部实体(External Entity)"></a>外部实体(External Entity)</h4><ul><li>向系统提供数据</li><li>从系统获取数据</li></ul></details><markdown><details>  <summary><center>目标2：Level-0图</center></summary><h2 id="Level-0图"><a href="#Level-0图" class="headerlink" title="Level-0图"></a>Level-0图</h2><p>在上下文数据流图的基础上进行扩展，将被隐藏的系统显示出来</p><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-02-14-00-07.png"></p><ul><li>level-0图提供了系统所有组件的概述</li><li>显示主要内部进程、数据流和数据存储</li><li>在level-0图的层次包括上下文图中已识别的外部实体</li><li>进程号并不表示进程执行的顺序</li></ul></details></markdown><markdown><details><summary><center>目标3：Level-1图(低级dfd图)</center></summary><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-02-14-00-39.png"></p><p>•低级dfd的级别只能在所有功能原语被识别时才能确定(升级)<br>•所有低级dfd都基于上级确定的流程<br>•所有低级dfd的输入和输出数据流必须正确对齐(平衡)</p></details></markdown><h3 id="目标图表总结"><a href="#目标图表总结" class="headerlink" title="目标图表总结"></a>目标图表总结</h3><p>•数据流程图用于数据和流程建模。<br>•dfd显示系统中的数据移动和转换。<br>•dfd以层次结构组织细节层次。<br>•上下文图表示系统范围及其外部依赖关系。<br>•level-0图显示了系统的主要流程、数据存储、外部实体和数据流。<br>•低级图表(level-1图)显示了系统的附加细节。<br>•dfd应准确反映被建模的信息系统。<br>•dfd的完整集合应该扩展到原始层次，其中每个组件都反映了某些不可约的属性。这是一个迭代过程。</p><h2 id="面向对象-OOP"><a href="#面向对象-OOP" class="headerlink" title="面向对象(OOP)"></a>面向对象(OOP)</h2><h3 id="什么是面向对象编程-OOP"><a href="#什么是面向对象编程-OOP" class="headerlink" title="什么是面向对象编程(OOP)"></a>什么是面向对象编程(OOP)</h3><p>面向对象编程是一种实现方法，在这种方法中，程序被组织为对象的协作集合，每个对象代表某个类的实例，其类都是通过继承关系统一的类层次结构的成员</p><blockquote><p>”Object-oriented programming is a method of implementation in which programs are organized as cooperative collections of objects, each of which represents an instance of some class, and whose classes are all members of a hierarchy of classes united via inheritance relationships.” </p></blockquote><h3 id="什么是面向对象设计-OOD"><a href="#什么是面向对象设计-OOD" class="headerlink" title="什么是面向对象设计(OOD)"></a>什么是面向对象设计(OOD)</h3><p>面向对象设计是一种设计方法，包括面向对象的分解过程和描述被设计系统的逻辑和物理以及静态和动态模型的符号</p><blockquote><p>Object-oriented design is a method of design encompassing the process of object-oriented decomposition and a notation for depicting both logical and physical as well as static and dynamic models of the system under design</p></blockquote><h3 id="面向对象分析-OOA"><a href="#面向对象分析-OOA" class="headerlink" title="面向对象分析(OOA)"></a>面向对象分析(OOA)</h3><p>面向对象分析是一种分析方法，它从问题域词汇表中的类和对象的角度来检查需求</p><blockquote><p>Object-oriented analysis is a method of analysis that examines requirements from the perspective of the classes and objects found in the vocabulary of the problem domain</p></blockquote><h4 id="用例分析"><a href="#用例分析" class="headerlink" title="用例分析"></a>用例分析</h4><p>实际上是从用户故事中分析需要写哪些类、类与类之间的关系</p><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-06-10-54-43.png"><br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-06-10-55-28.png"></p><h4 id="类间分析"><a href="#类间分析" class="headerlink" title="类间分析"></a>类间分析</h4><ul><li>主要从经典范畴原则派生类和对象</li><li>关注问题领域的有形事物</li></ul><h4 id="行为分析"><a href="#行为分析" class="headerlink" title="行为分析"></a>行为分析</h4><ul><li><p>关注动态行为作为类和对象的主要来源。</p></li><li><p>基于具有相似行为的对象组的窗体类。</p></li><li><p>将有共同责任的事情分组。</p><blockquote><p>类的层次结构从一般的职责到专门的行为被创建</p></blockquote></li><li><p>由系统函数导出</p></li></ul><ol><li>将系统行为分配给系统的各个部分</li><li>了解谁发起这些行为，谁参与这些行为</li><li>起重要作用的发起者和参与者被视为对象。</li></ol><h4 id="类-职责-协作卡-CRC"><a href="#类-职责-协作卡-CRC" class="headerlink" title="类-职责-协作卡(CRC)"></a>类-职责-协作卡(CRC)</h4><p>图样：<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-06-11-00-28.png"></p><p>包含了类的继承关系(父类、子类)、对该类的描述、变量(变量名和它的描述)、职责</p><p>包含了：</p><ul><li>类的继承关系(父类、子类)</li><li>对该类的描述</li><li>变量(变量名和它的描述)</li><li>职责(不同于类的方法，但是方法履行职责)<br>执行对象的职责与了解对象的职责</li></ul><p>其分析作用是</p><ul><li>回顾用例图的描述</li><li>识别相关的参与者和对象</li><li>用例图场景的角色扮演</li><li>重复上面的步骤，直到所有的用例都被执行</li></ul><h2 id="结构分析"><a href="#结构分析" class="headerlink" title="结构分析"></a>结构分析</h2><h3 id="流程建模"><a href="#流程建模" class="headerlink" title="流程建模"></a>流程建模</h3><p>详见DFD图</p><h3 id="数据建模-Data-Modelling"><a href="#数据建模-Data-Modelling" class="headerlink" title="数据建模(Data Modelling)"></a>数据建模(Data Modelling)</h3><h4 id="什么是数据建模"><a href="#什么是数据建模" class="headerlink" title="什么是数据建模"></a>什么是数据建模</h4><p>数据建模指的是一个详细的模型，它捕获组织数据的整体结构，独立于任何数据库管理系统或其他实现考虑</p><ul><li>数据建模建立发展数据中的定义、结构和关系。</li><li>数据建模解释了需要组织做什么，以及管理在组织中执行的工作的规则。</li><li>数据模型不关心数据何时被处理或使用。</li><li>概念数据建模通常与其他需求分析和系统分析活动一起执行，如流程建模和逻辑建模。</li><li>工作和活动通常通过项目字典或由通用计算机辅助软件工程(CASE)软件工具维护的存储库进行协调和共享。</li><li>数据建模最常用的技术是实体关系(E-R)图</li></ul><h4 id="数据建模的重要性"><a href="#数据建模的重要性" class="headerlink" title="数据建模的重要性"></a>数据建模的重要性</h4><ul><li><p>在数据库、程序、计算机屏幕和打印报告的设计中，数据的特性是很重要的。</p></li><li><p>数据是许多现代信息系统中最复杂的方面。</p><blockquote><p>事务处理系统，如订单处理系统，在验证数据、协调错误和协调数据移动方面可能会有相当大的过程复杂性。</p></blockquote></li><li><p>数据的特征，如格式和实体关系，相对稳定，并且在同一业务领域的组织之间基本相同。</p><blockquote><p>基于面向数据而不是面向流程或逻辑的信息系统设计应该有更长的使用寿命。</p></blockquote></li></ul><h4 id="为数据建模收集信息！"><a href="#为数据建模收集信息！" class="headerlink" title="为数据建模收集信息！"></a>为数据建模收集信息！</h4><p>概念数据模型可以从头开始开发、从现有数据模型中提炼或购买(特定业务领域的标准数据模型)。数据建模通常是从多种角度进行的：</p><ul><li><p>自上而下的方法<br>从对业务性质的理解中获取数据模型的业务规则(面试，询问具体问题)</p></li><li><p>自下而上的方法<br>审阅特定的业务文件，如报告和收据等。</p></li></ul><h3 id="实体关系建模-E-R-Modelling"><a href="#实体关系建模-E-R-Modelling" class="headerlink" title="实体关系建模(E-R Modelling)"></a>实体关系建模(E-R Modelling)</h3><p>E-R图是实体关系模型的图形化展示，被用于数据建模。该建模方式是数据库设计中常用的方法，建模符号由三个主要的构造(数据实体、关系、相关属性)组成</p><h4 id="实体-Entities"><a href="#实体-Entities" class="headerlink" title="实体(Entities)"></a>实体(Entities)</h4><p>实体指的是存在于用户环境中的一个人、一个地方、一个事件、一个对象等等，拥有自己的身份，有别于其他实体。<br>实体类型(或实体类)是共享共同属性或特征(类似于OOD中的“类”)的实体的集合，比如各种品种的猫猫的实体组成猫的实体类型。<br>实体实例是实体类型的单一出现(类似于OOD中的“对象”)，比如从猫猫实体类中实例化出深红大猫猫，大猫猫是唯一的</p><p>对实体类型的定义应该包括：</p><ul><li>实体类型的每个实例的唯一特征(属性)是什么。</li><li>在实体类型中包含和不包含什么实体实例。<br>当- 创建和删除实体类型的实例时。当一个实例可能变成另一个实体类型的实例时。<br>例如:对建筑公司的投标一旦被接受就成为合同。</li><li>什么历史是可以保存的。</li></ul><h4 id="ER模型变量"><a href="#ER模型变量" class="headerlink" title="ER模型变量"></a>ER模型变量</h4><p>你就参考OOD里头类的变量来就完事了<br>比如员工类，变量有名字、年龄、技能、员工代码等等<br>每个实体类型都必须具有一个或一组属性，以区别同一个类型的其他实例。属性或属性的集合称为候选键(Candidate Key, 你是不是想到了数据库的键…差不多)</p><ul><li><p>一个可以包含多个值的属性称为多值属性(Multivalued Attribute)</p></li><li><p>几个重复到一起的属性称为重复组(Repeating Group)</p><blockquote><p>使用一对大括号括起重复组或多值属性</p></blockquote></li><li><p>对于每个实体实例必须有一个值的属性称为必选属性(Required Attribute)</p></li><li><p>一个不能为每个实体实例都有值的属性称为可选属性(Optional Attribute)</p></li><li><p>一个有意义的组成部分被称为复合属性(Composite Attribute)</p></li><li><p>可以从数据库中其他数据计算出的属性值称为派生属性(Derived Attribute)<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-28-17-29-28.png"></p></li></ul><h4 id="ER模型关系"><a href="#ER模型关系" class="headerlink" title="ER模型关系"></a>ER模型关系</h4><ul><li>关系是<strong>组织</strong>感兴趣的<strong>一个或多个实体类型的实例之间的关联</strong>。</li><li>关系通常意味着<strong>一个事件已经发生</strong>，或者<strong>实体实例之间存在一些自然的联系</strong>。</li><li>关系用动词短语来标记。</li><li>参与关系的实体类型的数量被称为关系的程度。<blockquote><ul><li>一元关系(或递归关系)、二元关系和三元关系是常见的。</li><li>更高程度的关系是可能的，但在实践中很少遇到。<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-28-17-32-45.png"></li></ul></blockquote></li></ul><h5 id="关系基数"><a href="#关系基数" class="headerlink" title="关系基数"></a>关系基数</h5><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-28-17-36-22.png"><br>首先我们来看一堆魔法棒，他英文名字挺直白的，叫牛脚符号(Crow’s Foot Symbols)。。<br>这堆奇奇怪怪的跟召唤恶魔的奇怪符号一样的符号指的是可以(或必须)与实体A的每个实例相关联的实体b的数量，自上而下分别是：</p><ul><li>一个或者更多个</li><li>要么一个，要么没有(欢迎来到0与1的世界)</li><li>就一个</li><li>要么0，要么1，要么一堆</li></ul><p>应用到实体实例中就是：<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-28-17-39-08.png"></p><h4 id="超类型-Supertypes-与子类型-Subtypes"><a href="#超类型-Supertypes-与子类型-Subtypes" class="headerlink" title="超类型(Supertypes)与子类型(Subtypes)"></a>超类型(Supertypes)与子类型(Subtypes)</h4><p>可以理解成OOD中的继承父类和子类</p><ul><li>子类型<br>实体类型中的实体的一个子组，它对组织具有完全意义，并具有不同于其他子组的公共属性或关系</li><li>超类型<br>与一个或多个子类型有关系的泛型实体类型<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-28-17-45-40.png"></li></ul><p>上图中，Employee是底下两个的父类</p><h5 id="关系规则"><a href="#关系规则" class="headerlink" title="关系规则"></a>关系规则</h5><p>为了避免出现超级老虎吃屎的问题，我们需要制定规则</p><ul><li><p>总专业化规则<br>•指定超类型的每个实体实例<strong>必须是关系的某个子类型</strong>的成员。例如，一个人必须是员工或学生或两者都是。<br>•从超类型到圆的双行</p></li><li><p>重叠规则:<br>•指定一个实体实例<strong>可以同时是两个或多个子类型的成员</strong>。一个人既可以是雇员也可以是学生<br>•在圈里写个“o”</p></li><li><p>局部特殊化规则<br>•指定父类型的实体实例<strong>不必属于任何子类型</strong>。例如，一个员工可以只是一个员工，一个员工不必是教员或员工。<br>•从超类型到圆的一行</p></li><li><p>不相交的规则:<br>•指定如果超类型的实体实例是一个子类型的成员，它<strong>不能同时是任何其他子类型的成员</strong>。例如，一个人必须是雇员或学生。<br>•在圈里写个“d”<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-28-18-02-06.png"></p></li></ul><h1 id="GRASP-General-Responsibility-Assignment-Software-Pattern-or-Principles-原则"><a href="#GRASP-General-Responsibility-Assignment-Software-Pattern-or-Principles-原则" class="headerlink" title="GRASP(General Responsibility Assignment Software Pattern or Principles)原则"></a>GRASP(General Responsibility Assignment Software Pattern or Principles)原则</h1><p>领域模型(Domain Model)是概念类或领域中实际情况对象的可视化表示</p><h2 id="GRASP-创造者-Creator"><a href="#GRASP-创造者-Creator" class="headerlink" title="GRASP-创造者(Creator)"></a>GRASP-创造者(Creator)</h2><p>创造者指：谁创造了谁？<br>如果A和B之间有以下关系中的一个，我们就可以认为B是A的创造者：</p><ul><li>B包含或复合聚合A</li><li>B记录A</li><li>B紧密使用A</li><li>B拥有A的初始化数据。</li></ul><p>举个例子，“项目”这个实体拥有“项目待办列表”这个实体的所有数据，所以我们认为项目是项目待办列表的创造者</p><h2 id="GRASP-信息专家-Information-Expert"><a href="#GRASP-信息专家-Information-Expert" class="headerlink" title="GRASP-信息专家(Information Expert)"></a>GRASP-信息专家(Information Expert)</h2><p>给对象分配职责的基本原则是将一个职责分配给具有完成该职责所需信息的类<br>说人话就是：谁能(有信息)干给谁干<br>比如说产品待办列表有所有的用户需求信息，所以它负责用户故事</p><h2 id="GRASP-低耦合-Low-Coupling"><a href="#GRASP-低耦合-Low-Coupling" class="headerlink" title="GRASP-低耦合(Low Coupling)"></a>GRASP-低耦合(Low Coupling)</h2><p>当系统的耦合度低时，我们改动系统的一部分代码时不会对其他部分造成太大的影响<br>低耦合的方法：分配职责，使不必要的耦合保持在较低水平。使用这个原则来评估替代方案</p><h2 id="GRASP-控制者-Controller"><a href="#GRASP-控制者-Controller" class="headerlink" title="GRASP-控制者(Controller)"></a>GRASP-控制者(Controller)</h2><p>谁是控制者？<br>将责任分配给代表以下选择之一的对象:</p><ul><li>表示整个系统，一个“根对象”，一个软件运行的设备，或一个主要子系统(façade控制器的变体)。</li><li>表示系统操作发生的用例场景(用例或会话控制器)。</li></ul><h2 id="GRASP-高内聚-High-Cohesion"><a href="#GRASP-高内聚-High-Cohesion" class="headerlink" title="GRASP-高内聚(High Cohesion)"></a>GRASP-高内聚(High Cohesion)</h2><p>如何保持对象集中、可理解和可管理，以及作为一个副作用，支持低耦合?这就需要高内聚，分配责任，保持高度的凝聚力。用它来评估替代方案<br>高内聚是指类与类之间的关系而定.高，意思是他们之间的关系要简单明了，不要有很强的关系<br>内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系</p><h2 id="GRASP-多态-Polymorphism"><a href="#GRASP-多态-Polymorphism" class="headerlink" title="GRASP-多态(Polymorphism)"></a>GRASP-多态(Polymorphism)</h2><p>如何基于类型处理备选方案? 如何创建可插拔的软件组件?<br>解决方法：多态</p><blockquote><p>当相关的替代方案或行为随类型而变化时，使用多态操作将行为的责任分配给行为所变化的类型<br>好处是新变体的扩展容易添加，并且可以在不影响客户机的情况下引入新的实现(热拔插)</p></blockquote><h2 id="GRASP-纯制造，间接和保护变异-Pure-Fabrication-Indirection-and-Protected-Variations"><a href="#GRASP-纯制造，间接和保护变异-Pure-Fabrication-Indirection-and-Protected-Variations" class="headerlink" title="GRASP-纯制造，间接和保护变异(Pure Fabrication, Indirection and Protected Variations)"></a>GRASP-纯制造，间接和保护变异(Pure Fabrication, Indirection and Protected Variations)</h2><h3 id="纯制造"><a href="#纯制造" class="headerlink" title="纯制造"></a>纯制造</h3><p>当你不想违背高内聚低耦合的原则，但是解决方案又不完美的时候该怎么办？<br>将一组高内聚的职责分配给一个不代表问题域概念的人工或方便类，以支持高内聚、低耦合和重用。如类(class)是一种虚构的想象。</p><h3 id="间接"><a href="#间接" class="headerlink" title="间接"></a>间接</h3><p>在哪里分配责任，以避免两个或多个事物之间的直接耦合?如何对对象进行解耦合，以支持低耦合，并保持较高的重用潜力?<br>解决方法是将责任分配给中间对象，以便在其他组件或服务之间进行中介，这样您的组件或服务就不会直接耦合<br>常见的应用在于适配器模式、桥接模式、观察者模式、中继器模式、外观模式</p><h3 id="突变保护"><a href="#突变保护" class="headerlink" title="突变保护"></a>突变保护</h3><p>如何设计对象、子系统和系统，使这些元素的变化或不稳定性不会对其他元素产生不良影响?<br>解决方法是识别预测的变化或不稳定点;为它们分配创建稳定接口(广义的访问视图)的职责<br>常见的应用在于许多设计原则中，比如多态、接口、封装与绝大多数设计模式</p><h1 id="面向对象五大原则-SOLID"><a href="#面向对象五大原则-SOLID" class="headerlink" title="面向对象五大原则(SOLID)"></a>面向对象五大原则(SOLID)</h1><h2 id="SOLID"><a href="#SOLID" class="headerlink" title="SOLID"></a>SOLID</h2><ul><li>SRP单一职责原则</li><li>OCP开闭原则</li><li>LSP里氏替换原则</li><li>ISP接口隔离原则</li><li>DIP依赖反转原则</li></ul><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>一个类干一件事并干好，每个模块或类都应该对软件提供的功能的单个部分负责(高内聚)</p><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>模块对于扩展是开放的，但是对于修改是封闭的</p><blockquote><p>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化（开）</p><p>而不是通过修改已有的代码来实现变化（闭）</p></blockquote><p>比如工厂模式，一个很好的符合开闭原则的设计模式<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-06-28-23-57-08.png"></p><h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>如果对于每个类型为S的对象o1，都有一个类型为T的对象o2，使得所有以T定义的程序P，当o1取代o2时，P的行为保持不变，那么S就是类型为T的子类型</p><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>不应该强迫客户端依赖于它们不使用的接口，只继承该用的接口</p><p>解决方法是从操作中创建不同的方法接口，然后让客户端实现需要的接口，如下图(感谢大鹏文档的回答)</p><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedane20210630103543.png"></p><h3 id="依赖反转原则"><a href="#依赖反转原则" class="headerlink" title="依赖反转原则"></a>依赖反转原则</h3><blockquote><p>对抽象接口的每一次更改都对应于对其具体实现的更改。相反，对具体实现的更改并不总是(甚至通常)需要对其实现的接口进行更改。</p></blockquote><p>依赖反转原则是指一种特定的解耦（传统的依赖关系创建在高层次上，而具体的策略设置则应用在低层次的模块上）形式，使得高层次的模块不依赖于低层次的模块的实现细节，依赖关系被颠倒（反转），从而使得低层次模块依赖于高层次模块的需求抽象。</p><h4 id="该原则规定"><a href="#该原则规定" class="headerlink" title="该原则规定"></a>该原则规定</h4><ul><li>高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口。</li><li>抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。</li><li>该原则颠倒了一部分人对于面向对象设计的认识方式。如高层次和低层次对象都应该依赖于相同的抽象接口</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>GRASP原则可以作为一个工具，帮助掌握OOD的基础知识，理解对象设计中的责任分配。</li><li>GRASP遵循责任驱动设计的理念，思考如何将责任分配给协作对象。</li><li>GRASP和SOLID基本重叠。</li></ul></markdwon>]]></content>
      
      
      <categories>
          
          <category> 软件工程与软件过程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ch20: 数据推断</title>
      <link href="/2021/04/26/Ch20%EA%9E%89%20%E6%95%B0%E6%8D%AE%E6%8E%A8%E6%96%AD/"/>
      <url>/2021/04/26/Ch20%EA%9E%89%20%E6%95%B0%E6%8D%AE%E6%8E%A8%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="Student-T-model"><a href="#Student-T-model" class="headerlink" title="Student-T model"></a>Student-T model</h2><h2 id="Student-T-model-1"><a href="#Student-T-model-1" class="headerlink" title="Student-T model"></a>Student-T model</h2><p>用于T测试的模型，长得和正态分布的样子挺像的但是稍有不同(指略胖)<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/dameClipboard_2021-04-29-20-26-30.png"><br>上一章节提到的z检测适用于知道原假设成功概率p与备择假设成功概率p的情况，而t检测适用于只知道均值的情况。由于可能不知道总体标准差，故使用标准误差SE替代SD<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/dameClipboard_2021-07-04-15-48-38.png"></p><h3 id="使用情况"><a href="#使用情况" class="headerlink" title="使用情况"></a>使用情况</h3><ul><li>随机化条件<br>如果数据来自随机样本或适当的随机化实验，则满足此条件</li><li>一般在样本容量n &lt; 30时使用<br>当n &gt; 30，一般使用的是正态分布</li><li>不知道原假设的标准差<br>这时候必用t测试，否则请使用z测试</li></ul><h3 id="相关变量"><a href="#相关变量" class="headerlink" title="相关变量"></a>相关变量</h3><ul><li>df：自由度，用来查表</li><li>t*：t值，用来查表</li><li>临界t值：处于true/false边缘的临界值，用于判断原命题真伪</li></ul><h3 id="置信区间"><a href="#置信区间" class="headerlink" title="置信区间"></a>置信区间</h3><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/dameClipboard_2021-07-04-15-49-24.png"><br><br></p><h2 id="假设条件"><a href="#假设条件" class="headerlink" title="假设条件"></a>假设条件</h2><ul><li>随机抽取条件(Randomization Condition)：数据是随机抽取的(确保独立性原则)</li><li>接近正态条件(Nearly Normal Condition)：数据来自一个单峰和对称的分布<br></li></ul><h2 id="假设检测"><a href="#假设检测" class="headerlink" title="假设检测"></a>假设检测</h2><h3 id="自由度df-Degree-of-Freedom"><a href="#自由度df-Degree-of-Freedom" class="headerlink" title="自由度df(Degree of Freedom)"></a>自由度df(Degree of Freedom)</h3><p>计算公式：n - 1, n为样本容量</p><h3 id="显著性水平α-Significant-Level"><a href="#显著性水平α-Significant-Level" class="headerlink" title="显著性水平α(Significant Level)"></a>显著性水平α(Significant Level)</h3><p>计算公式：1 - 置信水平CL</p><h3 id="查询临界t值-Critial-T"><a href="#查询临界t值-Critial-T" class="headerlink" title="查询临界t值(Critial T)"></a>查询临界t值(Critial T)</h3><p>横轴：df的值<br>纵轴：α的值<br>通过前面计算得到的两个值即可找到临界t值<br><strong>注意</strong>：t表中对应的α是往右边走的(z表中是左侧面积)，如下图：<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/dameClipboard_2021-04-29-14-35-00.png"></p><h3 id="样本t-值"><a href="#样本t-值" class="headerlink" title="样本t*值"></a>样本t*值</h3><p>计算公式：<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/dameClipboard_2021-07-04-15-48-20.png"></p><p><strong>需要注意的是</strong>，我们在实际操作过程中需要判断p值才能去否定原命题或者无法否定</p><p>也就是P-value(t*的某种关系)的值与α相比较</p>]]></content>
      
      
      <categories>
          
          <category> 统计学导论 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ch19: 区间假设检测</title>
      <link href="/2021/04/25/Ch19%EA%9E%89%20%E5%8C%BA%E9%97%B4%E5%81%87%E8%AE%BE%E6%A3%80%E6%B5%8B/"/>
      <url>/2021/04/25/Ch19%EA%9E%89%20%E5%8C%BA%E9%97%B4%E5%81%87%E8%AE%BE%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在做假设检测相关的题目的时候，请务必要写以下流程(防止过程分没)：</p><ol><li>列出原假设与备择假设<br>也就是H<del>0</del>：什么什么什么<br>   H<del>A</del>：什么什么什么</li><li>确定检测是否满足对应的假设条件</li></ol><ul><li>独立性假设</li><li>随机抽取条件</li><li>10%条件</li><li>成功失败条件</li></ul><ol start="3"><li>列出参数、画图、套用统计学公式<br>n = ;s = ; y^- = …<br>明确使用左尾测试还是右尾测试还是双尾</li><li>给出结论<br>请不要直接使用z值或者t值与临界的大小关系进行比较<br>按照课本的流程，请使用p值与α之间的关系进行比较(因为这样可以拒绝原假设，但是不能说原假设一定正确)<br></li></ol><h2 id="假设-Hypothesis"><a href="#假设-Hypothesis" class="headerlink" title="假设(Hypothesis)"></a>假设(Hypothesis)</h2><p>假设是我们用来检验的<strong>模型或命题</strong></p><blockquote><p>Hypothesis is a model or proposition that we adopt in order to test.</p></blockquote><h3 id="原假设-Null-Hypothesis"><a href="#原假设-Null-Hypothesis" class="headerlink" title="原假设(Null Hypothesis)"></a>原假设(Null Hypothesis)</h3><p>对于一个可测试的原假设，它必须为某个总体参数指定一个值，这个值可以作为假设一个检验统计量的抽样分布的基础。之所以叫null，因为它假设没有任何改变<br>通常写作H<sub>0</sub>: p = xx</p><h3 id="备择假设-Alternative-Hypothesis"><a href="#备择假设-Alternative-Hypothesis" class="headerlink" title="备择假设(Alternative Hypothesis)"></a>备择假设(Alternative Hypothesis)</h3><p>备择假设(我们表示HA)包含了拒绝零假设时我们认为合理的参数值，提出了如果我们拒绝原假设我们应该得出的结论<br>H<sub>A</sub>: p != xx (xx一般是原假设的值，这是双边测试)或p &gt; xx或p &lt; xx(这是单边测试)<br><br></p><h2 id="P值法-P-Value"><a href="#P值法-P-Value" class="headerlink" title="P值法(P-Value)"></a>P值法(P-Value)</h2><p>p值是在零假设为真时，观察到一个检验统计量的值与假设值的距离至少与实际观察到的统计量的距离的概率</p><h3 id="根据P值我们能得到什么结论？"><a href="#根据P值我们能得到什么结论？" class="headerlink" title="根据P值我们能得到什么结论？"></a>根据P值我们能得到什么结论？</h3><ul><li>小P值<br>较小的p值说明观测结果是不可能的，或者说明概率计算是基于错误的假设。原假设的假定真理是被怀疑的假设<br>对于一个足够小的p值，你应该<strong>推翻原假设</strong></li><li>大P值<br>当p值很高时，我们没有看到任何不可能或令人惊讶的事情。有高发生概率的事件经常发生<br>我们<strong>还没有证明原假设是正确的</strong>。我们最多只能说，它<strong>看起来不像是假的</strong><br>形式上，我们<strong>未能拒绝原假设</strong><br></li></ul><h2 id="检测步骤"><a href="#检测步骤" class="headerlink" title="检测步骤"></a>检测步骤</h2><ul><li>找到原假设与备择假设</li><li>建立模型(寻找p值、SD等等)</li><li>利用机制推理判断(计算z值、寻找p值)</li><li>得出结论————原假设是否应该被舍弃</li></ul><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a><strong>模型</strong></h3><p>看题目是单边还是双边模型进行建模</p><ul><li><p>单边：(H<del>A</del>: p ≠ p0)</p></li><li><p>双边：(H<del>A</del>: p &gt; p0 或 H<del>A</del>: p &lt; p0)</p></li></ul><h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a><strong>计算</strong></h3><ul><li>引入了一个新的区间α(显著性水平，Significant Level)，值为1-置信区间C</li><li>计算p值<br>p值是计算得出z之后，新的正态分布图像中拒绝部分的概率和(面积和)<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/dameClipboard_2021-04-25-21-07-27.png"><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/dameClipboard_2021-04-25-21-13-14.png"></li></ul><p>若p &lt; α，则p值过小，应当<font color="red">推翻原假设</font><br>若p ≥ α，则p值较大，我们<font color="red">不一定能拒绝原假设</font>(不能说它对也不能说它错)</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ul><li>列出原假设与备择假设</li><li>判断在一定置信比例下能否信任原假设</li></ul>]]></content>
      
      
      <categories>
          
          <category> 统计学导论 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>L6-架构设计</title>
      <link href="/2021/04/25/L6-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
      <url>/2021/04/25/L6-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="L6-架构设计"><a href="#L6-架构设计" class="headerlink" title="L6-架构设计"></a>L6-架构设计</h1><h2 id="什么是系统架构"><a href="#什么是系统架构" class="headerlink" title="什么是系统架构"></a>什么是系统架构</h2><ul><li><p>系统的软件架构是对系统进行推理所需的一组<strong>结构</strong>，这些结构包括<strong>软件元素</strong>、它们之间的<strong>关系</strong>以及两者的<strong>属性</strong></p><blockquote><p>“The software architecture of a system is the set of structures needed to reason about the system, which comprise software elements, relations among them, and properties of both</p></blockquote></li><li><p>系统架构是系统在其环境中的<strong>基本概念或属性的集合</strong>，体现在其元素、关系以及其设计和发展的原则中</p><blockquote><p>“The architecture of a system is the set of fundamental concepts or properties of the system in its environment, embodied in its elements, relationships, and the principles of its design and evolution</p></blockquote></li><li><p>架构设计关注的是如何<strong>组织软件系统</strong>并<strong>设计该系统的整体结构</strong></p><blockquote><p>Architectural design is concerned with understanding how a software system should be organized and designing the overall structure of that system</p></blockquote></li></ul><h2 id="系统架构的重要性"><a href="#系统架构的重要性" class="headerlink" title="系统架构的重要性"></a>系统架构的重要性</h2><ul><li>加强利益相关者之间的沟通</li><li>允许架构师和项目经理估算成本和进度</li><li>定义后续实现的约束</li><li>包含最基本和最难改变的设计决策</li><li>为软件产品创建可转移和可重用的模型</li><li>便于系统分析</li></ul><h2 id="架构层级"><a href="#架构层级" class="headerlink" title="架构层级"></a>架构层级</h2><p>架构本身是一种抽象</p><h3 id="微观层面"><a href="#微观层面" class="headerlink" title="微观层面"></a>微观层面</h3><p>指的是具体的一个小的程序的实现架构，这些小的程序通过接口可以组合成一个更大的程序。考虑如何实现它，如何分解成小组件<br>比如说四轮项目的玩家，包含了管理器、控制器；而四轮本体是一个更大的项目</p><h3 id="宏观层面"><a href="#宏观层面" class="headerlink" title="宏观层面"></a>宏观层面</h3><p>指的是整个系统的架构，关注如何使用组件组成这么一个大的系统<br>比如四轮本体，包含了玩家、敌人和放置这几个小的程序</p><h2 id="架构设计的声明周期"><a href="#架构设计的声明周期" class="headerlink" title="架构设计的声明周期"></a>架构设计的声明周期</h2><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-06-22-55-43.png"></p><h3 id="架构重要性需求（Architecturally-Significant-Requirements）：指在所有需求中一些对架构有特殊重要性的需求。"><a href="#架构重要性需求（Architecturally-Significant-Requirements）：指在所有需求中一些对架构有特殊重要性的需求。" class="headerlink" title="架构重要性需求（Architecturally Significant Requirements）：指在所有需求中一些对架构有特殊重要性的需求。"></a>架构重要性需求（Architecturally Significant Requirements）：指在所有需求中一些对架构有特殊重要性的需求。</h3><blockquote><p>设计是一种转换，从需求到解决方案，可以是由代码、框架和组件组成的结构。<br>结构的初步文档(草图)应该作为建筑设计的一部分。<br>如果正在开发的项目不是微不足道的，那么应该评估设计，以确保做出的决策适合于处理ASRs<br>架构师在实现过程中的职责是确保代码与设计的一致性。</p></blockquote><h2 id="原则性方法Principled-Methods"><a href="#原则性方法Principled-Methods" class="headerlink" title="原则性方法Principled Methods"></a>原则性方法Principled Methods</h2><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-06-22-57-56.png"></p><h3 id="Architectural-Views-4-1-："><a href="#Architectural-Views-4-1-：" class="headerlink" title="Architectural Views (4+1)："></a>Architectural Views (4+1)：</h3><ul><li>Logical View<br>逻辑视图将系统中的关键抽象显示为对象或对象类。<br>用于将系统需求与逻辑视图中的元素相关联。</li><li>Physical View<br>物理视图显示系统硬件和软件组件如何在系统中分布。<br>用于规划系统部署</li><li>Development View<br>开发视图显示了如何对软件进行开发分解。<br>有利于分配工作和规划发展。</li><li>Process View<br>流程视图显示了系统是如何在运行时由交互流程组成的。<br>用于判断非功能系统特征</li><li>Scenarios<br>用于说明和验证这4个视图。<h3 id="Structures-and-Views-ADD"><a href="#Structures-and-Views-ADD" class="headerlink" title="Structures and Views (ADD)"></a>Structures and Views (ADD)</h3></li><li>View：视图由一组元素和它们之间的关系的表示组成。<br>结构是元素本身的集合，因为它们存在于软件或硬件中</li><li>Module structures：如何将系统构建为一组必须构建或获取的代码或数据单元。</li><li>Component-and-connector structures: 如何将系统构建为一组具有运行时行为(组件)和交互(连接器)的元素。</li><li>Allocation structures：显示了软件元素及其操作环境中的元素之间的关系。<h4 id="Viewpoints-视图为视图的构造提供了一个模板。"><a href="#Viewpoints-视图为视图的构造提供了一个模板。" class="headerlink" title="Viewpoints: 视图为视图的构造提供了一个模板。"></a>Viewpoints: 视图为视图的构造提供了一个模板。</h4></li><li>Context viewpoint: 描述系统及其环境之间的关系、依赖关系和交互。</li><li>Functional viewpoint: 描述系统的功能元素、它们的职责、接口和交互。</li><li>Information viewpoint: 描述系统如何存储、操作、管理和分发信息。</li><li>Concurrency viewpoint: 描述系统的并发结构并将功能元素映射到并发单元。</li><li>Development viewpoint: 描述支持软件开发过程的体系结构。</li><li>Deployment viewpoint: 描述如何使用关联依赖项在其操作环境中安装和部署系统。</li><li>Operational viewpoint: 描述如何操作、管理和支持系统。</li><li>View Relationships:</li></ul><h2 id="Architectural-Patterns-体系结构模式"><a href="#Architectural-Patterns-体系结构模式" class="headerlink" title="Architectural Patterns(体系结构模式)"></a>Architectural Patterns(体系结构模式)</h2><p>体系结构模式描述了用于解决问题的元素类型及其交互形式。</p><h3 id="客户端-服务器结构-Client-Server-Architecture"><a href="#客户端-服务器结构-Client-Server-Architecture" class="headerlink" title="客户端-服务器结构(Client-Server Architecture)"></a>客户端-服务器结构(Client-Server Architecture)</h3><p>该模式由两部分构成：单个服务器端和多个客户端。服务器组件对多个客户端组件提供服务。客户端向服务器端请求服务，服务端提供对应服务给这些客户端。此外，服务器端继续监听客户端请求。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>服务器可以跨网络分布</li><li>一般功能可提供给所有客户<h4 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h4></li><li>客户端通过请求/应答连接器连接到服务器</li><li>服务器组件也可以是其他服务器的客户端<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4></li><li>服务器可能是一个性能瓶颈</li><li>服务器可能是单点故障</li><li>在系统建立之后，关于定位功能(客户端还是服务器端)的决定通常是复杂的，更改成本很高</li></ul><h3 id="分层结构-Layered-Architecture"><a href="#分层结构-Layered-Architecture" class="headerlink" title="分层结构(Layered Architecture)"></a>分层结构(Layered Architecture)</h3><p>该模式用于构建可分解为多组子任务的程序，每个子任务都在某个抽象层，每个层对上一个更高层提供服务。</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>如果要对界面进行维护，允许更换整个层</li><li>每层均可提供冗余设施，提高系统可靠性。<h4 id="限制-1"><a href="#限制-1" class="headerlink" title="限制"></a>限制</h4></li><li>每个软件都被精确分配到一个层</li><li>至少有两层(但通常是三层或更多)。允许使用的关系不应该是循环的(即较低的层不应该使用上面的层)。<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4></li><li>添加层次会增加系统的前期成本和复杂性</li><li>层会影响性能，带来功能损失。</li></ul><h3 id="Model-View-Controller-MVC-Architecture"><a href="#Model-View-Controller-MVC-Architecture" class="headerlink" title="Model-View-Controller (MVC) Architecture"></a>Model-View-Controller (MVC) Architecture</h3><p>划分交互程序为3个部分：</p><ul><li>模型——包含核心功能和数据</li><li>视图——显示信息给用户（多个视图可被定义）</li><li>控制器——处理用户输入<br>它通过分割用户信息的内部陈述和呈现、接受方式来实现，解耦组件并允许高效的代码复用。<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4></li><li>允许数据独立于其表示进行更改，反之亦然</li><li>支持以不同的方式呈现相同的数据。<h4 id="限制-2"><a href="#限制-2" class="headerlink" title="限制"></a>限制</h4></li><li>模型、视图和控制器必须至少有一个实例</li><li>模型组件不应该直接与控制器交互。<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4></li><li>对于简单的用户界面来说，复杂性可能不值得</li><li>它可能不适用于某些用户界面工具包。</li></ul><h2 id="参考架构"><a href="#参考架构" class="headerlink" title="参考架构"></a>参考架构</h2><h3 id="网页应用"><a href="#网页应用" class="headerlink" title="网页应用"></a>网页应用</h3><h3 id="移动应用"><a href="#移动应用" class="headerlink" title="移动应用"></a>移动应用</h3><h2 id="架构设计的经验法则"><a href="#架构设计的经验法则" class="headerlink" title="架构设计的经验法则"></a>架构设计的经验法则</h2><ul><li>软件体系结构应该是单个架构师或一小群架构师的产品</li><li>架构师应该将架构建立在定义良好的质量属性需求的优先级列表上</li><li>应该评估体系结构交付系统重要质量属性的能力。</li><li>架构不应该依赖于商业产品或工具的特定版本。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件工程与软件过程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ch18: 比例置信区间</title>
      <link href="/2021/04/22/Ch18%EA%9E%89%20%E6%AF%94%E4%BE%8B%E7%BD%AE%E4%BF%A1%E5%8C%BA%E9%97%B4/"/>
      <url>/2021/04/22/Ch18%EA%9E%89%20%E6%AF%94%E4%BE%8B%E7%BD%AE%E4%BF%A1%E5%8C%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="Ch18-比例置信区间"><a href="#Ch18-比例置信区间" class="headerlink" title="Ch18: 比例置信区间"></a>Ch18: 比例置信区间</h1><p>课本p489~p503</p><h2 id="置信区间-Confidence-Interval"><a href="#置信区间-Confidence-Interval" class="headerlink" title="置信区间(Confidence Interval)"></a>置信区间(Confidence Interval)</h2><p>标准误差(Standard Error)：当我们估计一个抽样分布的标准差时，我们称它为标准误差</p><blockquote><p>When we estimate the standard deviation of a sampling distribution, we call it a <strong>standard error</strong></p></blockquote><p>面对两种抽样分布模型，有以下两种计算标准误差的模型：                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/dameyoClipboard_2021-07-03-22-12-14.png" style="zoom:67%;"><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/dame20210704105610.png" style="zoom:67%;"><br>标准误差也可定义为<strong>残差的标准差</strong>，是描述样本平均数抽样分布的离散程度及衡量对应样本平均数抽样误差大小的尺度的数值</p><h3 id="95-置信区间-常用置信区间"><a href="#95-置信区间-常用置信区间" class="headerlink" title="95%置信区间(常用置信区间)"></a>95%置信区间(常用置信区间)</h3><p>我们有95%的信心认为抽样结果集中在该范围.</p><h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><ul><li>分布中心 ± ME</li><li>分布中心 ± z* * SE</li></ul><br><h2 id="误差幅度-Margin-of-Error"><a href="#误差幅度-Margin-of-Error" class="headerlink" title="误差幅度(Margin of Error)"></a>误差幅度(Margin of Error)</h2><p>又称ME，指的是从样本中心出发左右两侧的误差幅度<br>ME = z* * SE</p><blockquote><p>当我们知道误差幅度、样本成功概率p^和置信比例α的时候，我们可以逆推公式来求样本容量n</p></blockquote><h3 id="临界值-z"><a href="#临界值-z" class="headerlink" title="临界值(z*)"></a>临界值(z*)</h3><p>z*可以查表，或者使用A<sub>L</sub> = (1 + 置信比例)/2，然后通过数值在z表查找对应的z*<br>通常情况下，95%置信区间对应的z*为1.96；90%置信区间对应1.645<br><br></p><h2 id="需要满足的条件与假设"><a href="#需要满足的条件与假设" class="headerlink" title="需要满足的条件与假设"></a>需要满足的条件与假设</h2><ul><li>独立性假设</li><li>随机抽样条件</li><li>10%条件</li><li>成功/失败条件</li></ul>]]></content>
      
      
      <categories>
          
          <category> 统计学导论 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ch17: 抽样分布模型</title>
      <link href="/2021/04/15/Ch17%EA%9E%89%20%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83%E6%A8%A1%E5%9E%8B/"/>
      <url>/2021/04/15/Ch17%EA%9E%89%20%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="抽样分布"><a href="#抽样分布" class="headerlink" title="抽样分布"></a>抽样分布</h1><p>一个样本的抽样分布模型可以让我们量化这种变化并帮助我们判断相应的总体参数在哪里</p><blockquote><p>A sampling distribution model for how a statistic from a sample varies from sample to sample allows us to quantify that variation and to make statements about where we think the corresponding population parameter is</p></blockquote><h2 id="抽样分布直方图"><a href="#抽样分布直方图" class="headerlink" title="抽样分布直方图"></a>抽样分布直方图</h2><p align="center"><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/dameyoClipboard_2021-04-15-09-36-29.png"></p><p>上面的直方图模拟了所有可能样本的所有比例。这个分布有一个特殊的名称。它被称为比例的抽样分布</p><p>当抽样分布满足三个条件(见下文)时，可以用正态分布逼近，即<img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/dameyoClipboard_2021-04-15-10-27-03.png" style="zoom:67%;">。该情况下抽样分布满足65-97-99.5规则，可以用其来求概率</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="总体-Population"><a href="#总体-Population" class="headerlink" title="总体(Population)"></a>总体(Population)</h3><p>总体均值(μ)：总体的平均值<br>总体标准差(σ)：总体的标准差<br>总体成功概率(p)：总体的成功概率</p><h3 id="样本-Sample"><a href="#样本-Sample" class="headerlink" title="样本(Sample)"></a>样本(Sample)</h3><ul><li>样本容量(n)：单个样本内包含的个体数</li><li>样本均值(x^-)：sample mean，即<strong>单个样本</strong>中的均值</li><li>样本标准差(s)：即<strong>样本的</strong>标准差</li><li>样本成功概率(<img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/dameyoClipboard_2021-07-03-21-26-27.png" style="zoom:67%;">)：即样本成功数x/样本容量n，是样本的成功概率</li></ul><h3 id="抽样分布-Population-Distribution"><a href="#抽样分布-Population-Distribution" class="headerlink" title="抽样分布(Population Distribution)"></a>抽样分布(Population Distribution)</h3><p>抽样分布模型显示了在相同大小n的所有可能样本上统计量的行为，最终得到的结果是一个正态分布曲线，可以使用3σ法则计算样本概率</p><ul><li>均值(μ<sub>x^-</sub>)：计算的是所有样本得到的模型的均值，就是样本的均值</li><li>样本平均值的标准差(SD(x^-))：如果已知总体的标准差(σ)，那么抽取无限多份大小为 n 的样本，每个样本各有一个平均值，所有这个大小的样本之平均值的标准差为：<img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/dameyoClipboard_2021-07-03-22-10-17.png" style="zoom:67%;"><br>再由二项分布公式，当我们知道总体p和q的数据时有：<img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/dameyoClipboard_2021-07-03-22-19-28.png" style="zoom:67%;"></li><li>样本平均值的标准误(SE(x^-))：由于<strong>通常总体标准差 σ 未知</strong>，此时可以用研究中取得样本的标准差 s 和样本容量 n 来估计样本的标准差：<img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/dameyoClipboard_2021-07-03-22-12-14.png" style="zoom:67%;"><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/dame20210704105610.png" style="zoom:67%;"><br>标准误差也可定义为<strong>残差的标准差</strong>，是描述样本平均数抽样分布的离散程度及衡量对应样本平均数抽样误差大小的尺度的数值</li></ul><h2 id="使用正态分布逼近抽样分布"><a href="#使用正态分布逼近抽样分布" class="headerlink" title="使用正态分布逼近抽样分布"></a>使用正态分布逼近抽样分布</h2><h3 id="三个条件"><a href="#三个条件" class="headerlink" title="三个条件"></a>三个条件</h3><ul><li>独立性假设(The Independence Assumption)：n足够大，并且每个样本是独立的</li><li>10%条件(10% Condition)：样本数不能超过总体的10%。这是因为一旦你抽样了超过10%的人口，剩下的个体就不再相互独立了</li><li>成功/失败条件(Success/Failure Condition)：必须至少有10个成功和10个失败的情况，即满足np、nq≥10<br></li></ul><h2 id="中心极限定理-CLT"><a href="#中心极限定理-CLT" class="headerlink" title="中心极限定理(CLT)"></a>中心极限定理(CLT)</h2><ul><li>如果总体的分布本身就遵循正态分布，那么不论样本容量n为多少，抽样分布的结果都是正态分布</li><li>如果总体不遵循正态分布，那么只有当<strong>n足够大</strong>的时候，抽样分布的结果才能是正态分布<br>随着样本容量的增加，任何均值的抽样分布都变得更接近正态分布。我们所需要的就是观察结果是独立的，并且是随机收集的。我们甚至不关心人口分布的形状!当时，拉普拉斯定理引起了相当大的轰动(至少在数学圈内)，因为无论数据如何分布，它都能起作用这一事实似乎很了不起。拉普拉斯的结果称为中心极限定理<blockquote><p>The sampling distribution of any mean becomes more nearly Normal as the sample size grows. All we need is for the observations to be independent and collected with randomization. We don’t even care about the shape of the population distribution! At the time, Laplace’s theorem caused quite a stir (at least in mathematics circles) because the fact that it works no matter how the data are distributed seems remarkable. Laplace’s result is called the <strong>Central Limit Theorem</strong></p></blockquote></li></ul><h3 id="三个条件-1"><a href="#三个条件-1" class="headerlink" title="三个条件"></a>三个条件</h3><ul><li>独立性假设(Independence Assumption)：样本是随机抽取、彼此独立的</li><li>样本容量条件(Sample Size Condition)：样本容量需要足够大，但也不能太大</li></ul><h3 id="两种正态分布模型"><a href="#两种正态分布模型" class="headerlink" title="两种正态分布模型"></a><font color="red">两种正态分布模型</font></h3><p>中心极限定理说的是<strong>任意均值</strong>或<strong>任意比例</strong>的抽样分布都近似正态分布。但是具体用哪种正态模型呢?</p><ul><li><p><strong>占比数据，categories data</strong><br>在知道总体标准差σ、总体成功概率p与样本成功概率p^时，可以用如下公式(习题见p466)<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/dameClipboard_2021-07-04-09-46-19.png"><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/dameClipboard_2021-07-03-22-19-28.png" style="zoom:80%;"><br>抽样分布以总体占比(p)为中心<br>X~N(p, SD(p^))</p></li><li><p><strong>均值数据，quantitative data</strong><br>在知道总体标准差σ、总体均值μ、样本均值μ(y-)的时候，可以使用如下公式(习题见p473)<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/dameClipboard_2021-07-04-10-09-13.png" style="zoom:80%;"><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/dameyoClipboard_2021-07-03-22-10-17.png" style="zoom:80%;"><br>抽样分布以总体均值(μ)为中心<br>X~N(μ, SD(x-))</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 统计学导论 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>L5-系统建模</title>
      <link href="/2021/04/13/L5-%E7%B3%BB%E7%BB%9F%E5%BB%BA%E6%A8%A1/"/>
      <url>/2021/04/13/L5-%E7%B3%BB%E7%BB%9F%E5%BB%BA%E6%A8%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="L5-系统建模"><a href="#L5-系统建模" class="headerlink" title="L5-系统建模"></a>L5-系统建模</h1><markdown><details><summary><center>目标1: 上下文图(Context Diagram)编写</center></summary><p>结构如下：</p><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-02-10-58-18.png"></p><p>主要由两个结构组成</p><ul><li><p>系统或外部系统<br>由方框表示，上部分用&lt;&lt;&gt;&gt;括起来的是类型，用来描述模型元素<br>类型有use、include、import和system等等，一般用到的是system</p></li><li><p>联系<br>表示了系统与外部系统之间的联系，用实线表示</p></li></ul></details></markdown><markdown><details> <summary><center>目标2: 活动图(Activity Diagram)编写</center></summary><p>结构如下：</p><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-02-11-09-17.png"></p><p>好吧结构有点多，看一下图例吧：</p><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-02-11-11-05.png"></p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul><li>初始节点(Initial Node)<br>实心黑点，表示执行活动的起点</li><li>分支节点(Decision Node)<strong>异步</strong><br>菱形，一进二出。会因为真或假(比如接受或拒绝)产生两个分支，两个分支流向不同的结果</li><li>合并节点(Merge Node)<strong>异步</strong><br>菱形，多进一出。可以在不同步的情况下将多个流聚集在一起</li><li>分叉节点(Fork Node)<strong>同步</strong><br>长条，一进多出。并行操作的分支起始，从分叉节点可以开启多个并行操作</li><li>汇合节点(Join Node)<strong>同步</strong><br>长条，多进一出。可以在同步的情况下将多个流聚集在一起</li><li>对象节点(Object Node)<br>矩形框，上面有&lt;&lt;&gt;&gt;表示的对象类型，比如数据存储(datastore)、系统(system)等等</li><li>终止节点(Final Node)<br>实心黑点外面还有一个圆圈，表示活动的终点</li></ul><h3 id="关于分支合并（Decision-and-Merge-Nodes）与分叉汇合（Fork-and-Join-Nodes）"><a href="#关于分支合并（Decision-and-Merge-Nodes）与分叉汇合（Fork-and-Join-Nodes）" class="headerlink" title="关于分支合并（Decision and Merge Nodes）与分叉汇合（Fork and Join Nodes）"></a>关于分支合并（Decision and Merge Nodes）与分叉汇合（Fork and Join Nodes）</h3><p>这两个东西有点像，在上面的描述大概是同步和异步之间的区别</p><ul><li>分支同步：处理决策，决策的的结束不一定(或者说极小概率也行)是同步结束的，所以说它的异步的</li><li>分叉汇合：对象在运行时可能会存在两个或多个<strong>并发运行的控制流</strong>，为了对并发的控制流建模，UML中引入了分叉与汇合的概念。分叉用于将动作流分为两个或多个并发运行的分支，而汇合则用于<strong>同步</strong>这些并发分支，以达到共同完成一项事务的目的</li></ul></details></markdown><details>  <summary><center>目标3: 包图(Package Diagram)编写</center></summary>  <markdown><p>结构如下：</p><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-02-13-21-49.png"></p><h3 id="什么是包-Package"><a href="#什么是包-Package" class="headerlink" title="什么是包(Package)"></a>什么是包(Package)</h3><p>包被认为是其成员的名称空间，在java中是package，在C#中相对于namespace</p><h3 id="包图的作用"><a href="#包图的作用" class="headerlink" title="包图的作用"></a>包图的作用</h3><ul><li>当执行分析时，包图被用来组织开发的工件</li><li>提供封装和包容，并支持模块化</li><li>在复杂的系统开发中提供清晰和整洁的组织</li><li>支持版本控制<h3 id="图样"><a href="#图样" class="headerlink" title="图样"></a>图样</h3></li></ul><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-02-13-20-14.png"></p><p>上面有两种关系，从属(Dependency)与控制(Containment)。从属表示一个包在没有另一个包的情况下无法正常运行；控制表示一个包需要另一个包才能工作<br></p></markdown><p></p></details><details> <summary><center>目标4: 部署图(Deployment Diagram)编写</center></summary>  <markdown><p>结构如下：</p><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-02-13-24-39.png"></p><p>由六部分组成</p><ul><li>节点<br>表示硬件或者软件运行环境的元素</li><li>工件<br>上面有&lt;&lt;artifact&gt;&gt;标记，代表了物理世界中由软件开发过程或系统操作所使用或产生的一些具体元素。如可执行文件、源文件、数据库表、文档或消息等</li><li>设备<br>节点的子类型，上面有&lt;&lt;device&gt;&gt;标记。它被用来表示具有处理能力的物理计算资源，工件可以在其上部署以供执行。</li><li>通讯路径<br>用实线表示，是两个部署目标之间的一种关联类型，它们可以通过它交换信息</li><li>运行环境<br>节点的子类型，上面有&lt;&lt;excutionEnvironment&gt;&gt;标记，被用来表示一些支持工件执行的环境(主要是软件)。运行环境通常分配给设备或节点。例如，应用服务器、操作系统或数据库等</li><li>部署规范<br>上面有&lt;&lt;deployment spec&gt;&gt;标记部署规范指定了部署在节点上的工件的一组属性</li></ul></markdown></details><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ul><li>对一个已经存在的系统<br>帮助阐明现有系统做什么，以明确系统的优缺点。</li><li>对于一个新系统（还不存在的，准备开发的系统）<br>有助于解释需求，让需求更明确、有助于写出系统文档</li></ul><h2 id="系统建模四要素"><a href="#系统建模四要素" class="headerlink" title="系统建模四要素"></a>系统建模四要素</h2><ul><li><p>外部External:系统所处的外部环境和“上下文”（意思是系统的工作，比如说用了第三方接口，或者第三方服务，比如说用了百度地图服务，天气预报接口。运行的环境不只有自己，还有别的外部（external）工具，这就叫外部环境）</p><blockquote><p>使用Context Model与Business Model(就是活动图)来实现（见本节课目标）</p></blockquote></li><li><p>交互Interaction:系统与环境/与用户之间的交互，或是系统内部部件与部件之间的交互（比如说这个方法，调用了那个方法，方法就是内部的“部件”）</p><blockquote><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-06-22-46-38.png"></p></blockquote></li><li><p>结构Structural:系统的结构，或者系统要处理的数据的结构</p><blockquote><p>根据组件的功能，和他们的关系来建模；用于设计系统的整体架构；它使用Class Diagram来建模</p></blockquote></li><li><p>行为Behavioral: runtime  behavior就是系统运行过程中，如何对外界作出响应</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>模型(model)是系统的抽象视图，它故意忽略了一些系统细节</li><li><strong>上下文图</strong> 上下文模型(context model)显示了系统在操作环境中的位置。它有助于定义系统的边界</li></ul><p><strong>UML没有专门为上下文模型提供的图表！！！</strong></p><blockquote><p>•在需求工程的早期阶段创建<br>•了解并确定正在开发的系统的边界<br>•在没有细节的情况下，建立系统和运行环境之间交互的高层视图。<br>•使用简单的块图或空的类图</p></blockquote><ul><li><p><strong>活动图</strong> 商业处理模型<br>与商业业务有关的建模</p><blockquote><p>•建模业务流程<br>•描述系统在特定的业务流程中是如何被涉及的<br>•使用活动图或专用的业务流程模型和符号(BPMN)</p></blockquote></li><li><p><strong>用例图</strong> 描述外部参与者和要开发的系统之间的交互序列图用于显示系统对象之间的交互</p></li><li><p><strong>类图</strong> 定义系统的类及其关系的静态结构</p></li><li><p><strong>包图</strong> 用于组织开发过程的工件</p></li><li><p><strong>部署图</strong> 用于显示组件对物理节点的分配</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件工程与软件过程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图论</title>
      <link href="/2021/04/11/%E7%AC%AC16%E7%AB%A0-%E5%9B%BE%E8%AE%BA/"/>
      <url>/2021/04/11/%E7%AC%AC16%E7%AB%A0-%E5%9B%BE%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><h3 id="名词介绍"><a href="#名词介绍" class="headerlink" title="名词介绍"></a>名词介绍</h3><ul><li>图是一组对象的图形表示，其中一些对对象通过有指向的线连接起来<br>相互连接的对象由称为<strong>顶点(Vertex)<strong>的点表示，连接顶点的有向线段称为</strong>边(Edge)</strong></li><li>形式上，一个图是一对集合(V, E)，其中V是顶点的集合，E是连接顶点对的边的集合，注意边的方向</li><li>如果两个顶点通过边连接在了一起，那么可以说这两个顶点是<strong>相邻的(Adjacency)</strong></li><li>从一个顶点到达另一个顶点经过的通路被称为<strong>路径(Path)</strong>,比如说A到D的路径可以是ABCD<blockquote><p>A graph is a pictorial representation of a set of objects where some pairs of objects are connected by links. The interconnected objects are represented by points termed as vertices, and the links that connect the vertices are called edges.<br>Formally, a graph is a pair of sets (V, E), where V is the set of vertices and E is the set of edges, connecting the pairs of vertices. </p></blockquote><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3></li><li>添加顶点</li><li>添加边</li><li>矩阵展示<details><summary>相邻矩阵(Adjacency Matrix)</summary><markdown>用矩阵展示出可通行的边的情况。每个顶点都要一个自己的编号，并且可以用这些编号创建一个n*n的矩阵，如下图所示：![](https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-04-11-10-00-33.png)![](https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-04-11-10-00-38.png)0表示两点之间没有边，1表示两点之间有边</markdown></details></li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>查找很快，O(1)</li><li>显示很明白</li><li>移除也很快，O(1)<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4></li><li>添加一个新的顶点将会消耗O(n<sup>2</sup>)的时间<br>原因挺显而易见的，因为加入一个新的顶点意味着要创建一个新的二维数组O(n<sup>2</sup>)，同时要把原二维数组的内容复制过来</li></ul><details>  <summary>相邻数组链表(Adjacency List)</summary>  <markdown>用列表展示出可通行的边的情况(感觉有点像哈希表？或者说就是？)，如下图所示：<p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-04-11-10-08-53.png"><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-04-11-10-08-57.png"></p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>相对于前一个，链表非常节省空间</li><li>适合大量顶点存在的图，比如一个有数百万个顶点和边的图(虽然但是，这也太多了)</li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> numVertices; </span><br><span class="line"><span class="keyword">private</span> LinkedList&lt;integer&gt; adjLists[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>&lt;/markdown&gt;</code></pre></markdown></details><h2 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h2><p>常用的有两种，请不要用数组或者链表做图的遍历…</p><h3 id="深度优先-DFS-用Stack实现"><a href="#深度优先-DFS-用Stack实现" class="headerlink" title="深度优先(DFS,用Stack实现)"></a>深度优先(DFS,用Stack实现)</h3><p><font color="red">时间复杂度：O(V + E)</font><br>简单来说呢就是</p><ul><li>把顶点入栈，标记为已访问(为了防止反复循环操作)，然后把它的子元素按顺序入栈</li><li>如果没有找到相邻的顶点，就从堆栈中弹出一个顶点。(它将弹出堆栈中没有相邻顶点的所有顶点。)</li><li>重复上述过程，直到堆栈变空、所有的节点都访问过为止<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-04-11-10-32-39.png"></li></ul><h3 id="广度优先-BFS-用Queue实现"><a href="#广度优先-BFS-用Queue实现" class="headerlink" title="广度优先(BFS,用Queue实现)"></a>广度优先(BFS,用Queue实现)</h3><p><font color="red">时间复杂度：O(V + E)</font><br>简单来说呢就是</p><ul><li>把顶点、顶点的子元素入队</li><li>子元素入队完就可以dequeue了(这时候把顶点出队了)，如果没有子元素照样dequeue</li><li>重复上述过程</li></ul><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-04-11-10-32-49.png"></p><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h3 id="前提限制"><a href="#前提限制" class="headerlink" title="前提限制"></a>前提限制</h3><p>拓扑排序仅适用于有向非循环图(DAG)<br>如果不是DAG会造成没有输出或者输出不完全等等一系列问题，输出也不是拓扑排序</p><h3 id="用Stack实现拓扑排序"><a href="#用Stack实现拓扑排序" class="headerlink" title="用Stack实现拓扑排序"></a>用Stack实现拓扑排序</h3><p><a href="https://www.geeksforgeeks.org/topological-sorting/">用Stack实现拓扑排序</a></p><p>其实和DFS的思路完全一样</p><h3 id="用Queue实现拓扑排序"><a href="#用Queue实现拓扑排序" class="headerlink" title="用Queue实现拓扑排序"></a>用Queue实现拓扑排序</h3><p>这种实现方式又被称作Kahn’s algorithm(可汗算法吗?)</p><p><a href="https://www.geeksforgeeks.org/topological-sorting-indegree-based-solution/">用Queue实现拓扑排序</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字典树</title>
      <link href="/2021/04/07/%E7%AC%AC15%E7%AB%A0-%E5%AD%97%E5%85%B8%E6%A0%91/"/>
      <url>/2021/04/07/%E7%AC%AC15%E7%AB%A0-%E5%AD%97%E5%85%B8%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-04-07-23-27-26.png"></p><h2 id="字典树-前缀树"><a href="#字典树-前缀树" class="headerlink" title="字典树(前缀树)"></a>字典树(前缀树)</h2><p>一种数据结构，常用于搜索引擎、查询、输入法</p><ul><li>查找速度很快</li><li>占用空间很大。对于英文来说，一个节点最多能有字母表个数个子节点</li><li>根节点是NIL</li><li>字母表的大小与叶子节点的个数相同</li><li>时间复杂度: O(L), L为单词长度<blockquote><ul><li>长度为L的单词，存放在Tire Tree中时间复杂度为O(L)</li><li>存放在哈希表中的时间复杂度为O(L)，虽然时间复杂度与tire一样，但是由于数据结构问题(不用使用哈希函数)字典树更快<br>Trie的另一个优点是，我们可以很容易地<strong>按字母顺序</strong>打印所有的单词，这是用哈希法不容易做到的。这样的好处是我们可以通过前缀查找，或者使用自动补齐</li><li>存放在自平衡二叉树中的时间复杂度为O(L*log<del>2</del>n), n为单词总数，L是单词的长度</li></ul></blockquote></li></ul><h3 id="节点结构"><a href="#节点结构" class="headerlink" title="节点结构"></a>节点结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Map&lt;Character, TrieNode&gt; children;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> leaf;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        children = <span class="keyword">new</span> HashMap&lt;Character, TrieNode&gt;();</span><br><span class="line">        leaf = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="字典树查找"><a href="#字典树查找" class="headerlink" title="字典树查找"></a>字典树查找</h2><ul><li>搜索前缀</li><li>搜索整个单词</li><li>搜索具有相同前缀的单词<br>就是按顺序查找下去，如果查到null就返回不存在<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-04-07-23-34-31.png"></li></ul><h3 id="搜索前缀"><a href="#搜索前缀" class="headerlink" title="搜索前缀"></a>搜索前缀</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return true if there is any word in trie that starts with the given prefix</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (searchNode(prefix) == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> TrieNode <span class="title">searchNode</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    TrieNode current = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch = str.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (current.children.containsKey(ch)) &#123;</span><br><span class="line">            current = current.children.get(ch);</span><br><span class="line">        &#125; </span><br><span class="line"><span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="搜索整个单词"><a href="#搜索整个单词" class="headerlink" title="搜索整个单词"></a>搜索整个单词</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return true if the word is in trie</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    TrieNode tn = searchNode(word);</span><br><span class="line">    <span class="keyword">if</span> (tn != <span class="keyword">null</span> &amp;&amp; tn.leaf) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="搜索拥有相同前缀的词"><a href="#搜索拥有相同前缀的词" class="headerlink" title="搜索拥有相同前缀的词"></a>搜索拥有相同前缀的词</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return all words which start with the given prefix</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">searchWords</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">    TrieNode current = root;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch = prefix.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (!current.children.containsKey(ch)) &#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sb.append(ch);</span><br><span class="line">            current = current.children.get(ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    dfs(current, sb.toString(), list);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TrieNode node, String prefix, List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.leaf) &#123; list.add(prefix); &#125;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Character, TrieNode&gt; entry : node.children.entrySet()) &#123;</span><br><span class="line">        dfs(entry.getValue(), prefix + entry.getKey(), list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字典树插入"><a href="#字典树插入" class="headerlink" title="字典树插入"></a>字典树插入</h2><ul><li>从词根开始搜索给定的单词，直到找不到一个特定的字符</li><li>为找不到的字符创建新的节点</li><li>将最后一个节点的leaf属性设置为true<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Insert a word into trie</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    TrieNode current = root; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch = word.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (!current.children.containsKey(ch)) &#123;</span><br><span class="line">            current.children.put(ch, <span class="keyword">new</span> TrieNode());</span><br><span class="line">        &#125;</span><br><span class="line">        current = current.children.get(ch);</span><br><span class="line">    &#125;</span><br><span class="line">    current.leaf = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br></li></ul><h2 id="字典树删除"><a href="#字典树删除" class="headerlink" title="字典树删除"></a>字典树删除</h2><h3 id="Word是其他单词的前缀"><a href="#Word是其他单词的前缀" class="headerlink" title="Word是其他单词的前缀"></a>Word是其他单词的前缀</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// case 1: The to-be deleted word is prefix of another long word in trie.</span></span><br><span class="line"><span class="keyword">if</span> (current.children.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        current.leaf = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单词有其他单词的前缀"><a href="#单词有其他单词的前缀" class="headerlink" title="单词有其他单词的前缀"></a>单词有其他单词的前缀</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lastBranchNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// case 2: The to-be deleted word has other words as prefix</span></span><br><span class="line">        lastBranchNode.children.remove(lastBrachChar);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// case 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="词是独一无二的"><a href="#词是独一无二的" class="headerlink" title="词是独一无二的"></a>词是独一无二的</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lastBranchNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// case 2: </span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// case 3: The to-be deleted word present as unique word</span></span><br><span class="line">        root.children.remove(word.charAt(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    TrieNode current = root;</span><br><span class="line">    TrieNode lastBranchNode = <span class="keyword">null</span>;</span><br><span class="line">    Character lastBrachChar = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch = word.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (current.children.containsKey(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.children.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                lastBranchNode = current;</span><br><span class="line">                lastBrachChar = ch;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.children.get(ch);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// word not found</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (current.children.size() &gt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">// case 1: 要删除的词是其他词的前缀</span></span><br><span class="line">        current.leaf = <span class="keyword">false</span>;                         <span class="comment">// 取消叶子性</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;                                  <span class="comment">// 删除成功</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lastBranchNode != <span class="keyword">null</span>) &#123; </span><br><span class="line">        <span class="comment">// case 2: 要删除的词有一部分是其他词作为前缀</span></span><br><span class="line">        lastBranchNode.children.remove(lastBrachChar); <span class="comment">// 删除前缀之后的内容</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// case 3: 完整的单词</span></span><br><span class="line">        root.children.remove(word.charAt(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ch16: 概率模型</title>
      <link href="/2021/03/30/Ch16%EA%9E%89%20%E6%A6%82%E7%8E%87%E6%A8%A1%E5%9E%8B/"/>
      <url>/2021/03/30/Ch16%EA%9E%89%20%E6%A6%82%E7%8E%87%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="伯努利试验-Bernoulli-Trials"><a href="#伯努利试验-Bernoulli-Trials" class="headerlink" title="伯努利试验(Bernoulli Trials)"></a>伯努利试验(Bernoulli Trials)</h2><p>每个事件必须相互独立<br>一件事有成功或者失败两个结果，你知道成功的概率p与失败的概率q<br>你做这件事情做了n次<br>你需要满足一些假设与条件(独立性假设等等)<br><br></p><h2 id="几何分布-Geometric-Model"><a href="#几何分布-Geometric-Model" class="headerlink" title="几何分布(Geometric Model)"></a>几何分布(Geometric Model)</h2><p>几何分布一般记为Geom(p)<br>使用场景：</p><ul><li>适用于<strong>不停试验直到成功</strong>的概率。只有一次成功<br>比如投掷骰子，问在第4次掷到6的概率是多少?</li><li>由p(成功概率)、q(q = 1−p, 指失败概率)、x(总试验次数)表示</li><li>概率、均值以及标准差的计算公式:<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaClipboard_2021-04-05-14-47-14.png"><blockquote><p>均值可以用来估计当你达成成功条件之前，你需要进行多少次伯努利试验</p></blockquote></li></ul><h3 id="条件检查"><a href="#条件检查" class="headerlink" title="条件检查"></a>条件检查</h3><ul><li>10%条件</li></ul><p>**样本总数不能超过总体的10%**，否则几何分布模型不再适用于该样本分布分析</p><ul><li>独立性条件(不必要)<br>模型下<strong>每个事件必须是相互独立</strong>的，一件事情的发生不会影响到另一件事情的发生。<strong>但是如果这个假设被违背了，只要样本小于总体的10%，几何模型仍然可以继续下去</strong><blockquote><p> Bernoulli trials must be independent. If that assumption is violated, it is still okay to proceed as long as the sample is smaller than 10% of the population. </p></blockquote></li></ul><blockquote><p>当问及“第一次成功是前x次试验之一的概率是多少?”的时候，计算公式是P(X ≤ x) = P(X = 1) + P(X = 2) + … + P(X = x)</p></blockquote><br><h2 id="二项分布-Binomial-Model"><a href="#二项分布-Binomial-Model" class="headerlink" title="二项分布(Binomial Model)"></a>二项分布(Binomial Model)</h2><p>二项分布可以记为Binom(n, p)，模型描述了在特定数量的试验中成功的次数<br>使用场景：</p><ul><li>计算n次试验中x次成功的概率。不止一次成功<br>比如投掷骰子，问连续投掷n次，其中连续投出4次4的概率是多少？在5次试验中成功2次的概率是多少？</li><li>类似几何分布，p是成功的概率(q = 1−p是失败的概率)，n是试验次数，x是成功的次数</li><li>计算公式<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaClipboard_2021-04-05-15-21-46.png"></li></ul><h3 id="组合数的计算方法"><a href="#组合数的计算方法" class="headerlink" title="组合数的计算方法"></a>组合数的计算方法</h3><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaClipboard_2021-07-03-17-22-53.png"></p><h3 id="条件检查-1"><a href="#条件检查-1" class="headerlink" title="条件检查"></a>条件检查</h3><ul><li>10%条件</li></ul><p>**样本总数不能超过总体的10%**，否则几何分布模型不再适用于该样本分布分析</p><ul><li>独立性条件(不必要)<br>模型下<strong>每个事件必须是相互独立</strong>的，一件事情的发生不会影响到另一件事情的发生。<strong>但是如果这个假设被违背了，只要样本小于总体的10%，几何模型仍然可以继续下去</strong><blockquote><p> Bernoulli trials must be independent. If that assumption is violated, it is still okay to proceed as long as the sample is smaller than 10% of the population. </p></blockquote></li></ul><h3 id="几何分布和二项分布"><a href="#几何分布和二项分布" class="headerlink" title="几何分布和二项分布"></a>几何分布和二项分布</h3><p>两者都涉及伯努利试验，但问题是不同的</p><ul><li>如果你重复试验直到第一次成功，那就是几何分布的问题。你不知道你需要多少次试验——理论上这可能会永远持续下去</li><li>如果你在计算特定次数的试验中成功的次数，那就是二项分布的问题<br></li></ul><h2 id="利用正态分布逼近二项分布"><a href="#利用正态分布逼近二项分布" class="headerlink" title="利用正态分布逼近二项分布"></a>利用正态分布逼近二项分布</h2><p>我们可以将二项分布视作正态分布，如果满足以下条件：</p><ul><li>成功/失败条件<br>至少有十次成功与十次失败，即：<br>np &gt;= 10; nq &gt;= 10</li></ul><p>这意味着我们在通过二项公式获得均值与标准差之后，就可以用z表来求二项分布模型的概率。<br>当数值很大时，用二项分布提供的公式计算概率是不切实际的，因为计算量太大。使用z表是一个明智的选择。<br><br></p><h2 id="泊松分布-Poisson-Model"><a href="#泊松分布-Poisson-Model" class="headerlink" title="泊松分布(Poisson Model)"></a>泊松分布(Poisson Model)</h2><p>泊松分布适合于描述单位时间内随机事件发生的次数的概率分布。如某一服务设施在一定时间内受到的服务请求的次数，电话交换机接到呼叫的次数、汽车站台的候客人数、机器出现的故障数、自然灾害发生的次数、DNA序列的变异数、放射性原子核的衰变数、激光的光子数分布等等<br>使用场景：</p><ul><li><p>出现平均数，问精确值<br>比如一家公司平均每天接待20个顾客(平均成功数)，问一天接待到8个人的概率(成功数)</p></li><li><p>泊松模型以λ为平均成功数，X为成功数</p><blockquote><p>λ是单位时间（或单位面积）内随机事件的平均发生率</p></blockquote></li><li><p>计算公式(非通用)：<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/dameyoClipboard_2021-04-05-15-43-20.png"></p></li><li><p>计算公式(通用)：<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/dameyoClipboard_2021-04-05-21-59-58.png"></p></li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>泊松模型可以用λ = np作为均值来近似p小n大的二项分布<br>当我们无法用正态分布逼近二项分布(不满足成功/失败条件)时，计算变得棘手。为了解决这种问题，需要引入泊松分布来逼近二项分布。<br>当n ≥ 20且p ≤ 0.05或n ≥ 100且p ≤ 0.10时，泊松分布是二项分布的一个相当好的近似！</li><li>泊松也可以用来模拟各种各样的现象。它只要求事件是独立的，并且在数据收集的过程中，事件的<strong>平均出现次数保持不变</strong>。</li><li>泊松模型的一个很好的特点是它根据样本大小进行缩放。例如，如果我们一个有35000人的小镇上平均发生的次数是3.85，那么在一个只有3500人的小镇上平均发生的次数依然是0.385。</li><li>泊松模型的结果之一是，只要平均发生率保持不变，过去事件的发生不会改变未来事件的概率。<br></li></ol><h2 id="均匀分布-Uniform-Model"><a href="#均匀分布-Uniform-Model" class="headerlink" title="均匀分布(Uniform Model)"></a>均匀分布(Uniform Model)</h2><p>使用场景：</p><ul><li>出现了均匀分布这几个字</li><li>相同大小的区间给出相同的概率</li><li>计算公式：<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/dameyoClipboard_2021-04-05-16-11-53.png"></li></ul><h3 id="公式解释"><a href="#公式解释" class="headerlink" title="公式解释"></a>公式解释</h3><p>f(x)是概率密度函数，当处于可行的区间内时满足每个片段发生的概率相同<br>当离开可行的区间，f(x)=0，事件不会发生</p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li>求概率密度函数f(x)</li><li>求某个区间的概率(其实就是求面积)</li><li>利用公式求平均值和标准差</li><li>与条件概率相结合(图画清楚就会做)</li></ul><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/dameyoClipboard_2021-04-05-16-20-24.png"></p><ul><li>求百分数为x时的具体值(如下图)</li></ul><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/dameyoClipboard_2021-04-05-16-24-59.png"><br><br></p><h2 id="指数分布-Exponential-Model"><a href="#指数分布-Exponential-Model" class="headerlink" title="指数分布(Exponential Model)"></a>指数分布(Exponential Model)</h2><p>使用场景：指数分布解决的问题是“要等到一个随机事件发生，需要经历多久时间”, 也就是<strong>时间间隔的问题</strong>。指数分布可以用来表示独立随机事件发生的时间间隔，比如旅客进入机场的时间间隔、电话打进客服中心的时间间隔、中文维基百科新条目出现的时间间隔、机器的寿命等<br>指数分布和泊松分布一起使用</p><ul><li>计算公式：<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/dameyoClipboard_2021-04-05-16-30-35.png"><blockquote><p>μ的值是两次事件之间的时间间隔<br>P(s~t)指的是s~t时间内发生随机事件的概率</p></blockquote></li></ul><h3 id="泊松分布与指数分布"><a href="#泊松分布与指数分布" class="headerlink" title="泊松分布与指数分布"></a>泊松分布与指数分布</h3><p><a href="https://www.jianshu.com/p/6ee90ba47b4a">https://www.jianshu.com/p/6ee90ba47b4a</a><br>泊松分布解决的问题是<strong>单位时间内随机事件发生的次数</strong>的概率分布<br>指数分布解决的问题是“<strong>要等到一个随机事件发生，需要经历多久时间</strong>”</p><blockquote><p>两种分布往往结合在一起使用，比如：<br>在接下来的十分钟之内都没有人来的概率：指数分布P(0 ≤ x ≤ 1/6)<br>在接下来十分钟之内来了两个人的概率：泊松分布P(x = 2)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 统计学导论 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ch15: 随机变量</title>
      <link href="/2021/03/29/Ch15%EA%9E%89%20%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F/"/>
      <url>/2021/03/29/Ch15%EA%9E%89%20%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>书本p406~423</p><h1 id="离散随机变量"><a href="#离散随机变量" class="headerlink" title="离散随机变量"></a>离散随机变量</h1><h2 id="期望值-Except-Value"><a href="#期望值-Except-Value" class="headerlink" title="期望值(Except Value)"></a>期望值(Except Value)</h2><h3 id="随机变量-Random-Variable"><a href="#随机变量-Random-Variable" class="headerlink" title="随机变量(Random Variable)"></a>随机变量(Random Variable)</h3><p>随机变量: 其数值基于随机事件的结果。我们用大写字母(比如X)来表示随机变量。</p><ul><li>离散随机变量(Discrete Random Variable)<br>我们可以列出随机变量的所有结果，我们可以正式称这个随机变量为离散随机变量。所有可能的值和它们发生的概率的集合被称为离散随机变量的概率模型。</li><li>连续随机变量(Continuous Random Variable)<br>我们不能列出随机变量的所有结果，它是连续的、无穷的</li></ul><h3 id="期望值"><a href="#期望值" class="headerlink" title="期望值"></a>期望值</h3><ul><li>可以用μ来表示，也可以用E(x)表示</li><li>计算一个(离散的)随机变量的期望值很简单！只要把每个可能的值乘以它发生的概率，然后求出总和即可</li><li>关于连续随机数(之后章节会提到的几种分布模型)的期望值求法，我们之后再提</li></ul><p>随机变量的期望值是其理论长期均值，是其模型的中心</p><blockquote><p>The expected value of a random variable is its theoretical long-run average value, the center of its model.</p></blockquote><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p>每个离散变量的<strong>数值</strong>与其<strong>概率</strong>相乘再求和</p><center>μ = E(X) = X<sub>1</sub>P(X<sub>1</sub>)+X<sub>2</sub>P(X<sub>2</sub>)+...+X<sub>n</sub>P(X<sub>n</sub>)</center><br><h2 id="标准偏差-Standard-Deviation"><a href="#标准偏差-Standard-Deviation" class="headerlink" title="标准偏差(Standard Deviation)"></a>标准偏差(Standard Deviation)</h2><h3 id="方差-Variance"><a href="#方差-Variance" class="headerlink" title="方差(Variance)"></a><em>方差(Variance)</em></h3><p>可以用σ<sup>2</sup>表示，不过一般写作Var(X)</p><h4 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h4><p>真实值与期望值的<strong>偏差的平方</strong>乘以这一离散变量发生的<strong>概率</strong>，再求和</p><center>Var(X) = (X<sub>1</sub>-μ)<sup>2</sup>P<sub>1</sub>+(X<sub>2</sub>-μ)<sup>2</sup>P<sub>2</sub>+...+(X<sub>n</sub>-μ)<sup>2</sup>P<sub>n</sub></center><h3 id="标准差"><a href="#标准差" class="headerlink" title="标准差"></a><em>标准差</em></h3><p>可以用σ表示，不过一般写作SD(X)<br>标准差就是<strong>对方差开根号</strong>处理的结果</p><h4 id="计算公式-1"><a href="#计算公式-1" class="headerlink" title="计算公式"></a>计算公式</h4><center>SD(X) = 根号下(X<sub>1</sub>-μ)<sup>2</sup>P<sub>1</sub>+(X<sub>2</sub>-μ)<sup>2</sup>P<sub>2</sub>+...+(X<sub>n</sub>-μ)<sup>2</sup>P<sub>n</sub></center><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><p style="text-decoration: underline;">总结</p></h3><p align="center"><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaClipboard_2021-07-03-15-38-07.png"></p><h2 id="随机变量的位移和组合"><a href="#随机变量的位移和组合" class="headerlink" title="随机变量的位移和组合"></a>随机变量的位移和组合</h2><ul><li>随机变量的每个值加或减去一个常数<strong>会改变均值</strong>，但<strong>不会改变方差或标准差</strong>，这对于随机变量也是如此<br>E(X ± a) = E(X) ± a<br>Var(X ± a) = Var(X)</li><li>随机变量的每个值乘以一个常数，<strong>均值乘以这个常数</strong>，<strong>方差乘以这个常数的平方</strong><br>E(X * a) = a * E(X)<br>Var(X * a) = Var(X) * a<sup>2</sup></li><li>两组随机变量的和或差的期望值是其期望值的和或差；两组随机变量的和或差的期望值是其期望值的和<br>E(X ± Y) = E(X) ± E(Y)<br>Var(X ± Y) = Var(X) + Var(Y)</li></ul><h1 id="连续随机变量"><a href="#连续随机变量" class="headerlink" title="连续随机变量"></a>连续随机变量</h1><p>正态随机变量不同于我们已经讨论过的离散随机变量，因为正态随机变量可以取任何值(所以说，它是一个连续随机数模型)<br>对于一个正态曲线，我们通过寻找正态曲线下的面积来找到它位于两个值之间的概率。我们用来处理正态分布的曲线叫做正态模型。正态分布曲线满足68-95-99.7(3σ)原则</p><h2 id="正态分布"><a href="#正态分布" class="headerlink" title="正态分布"></a>正态分布</h2><h3 id="正态分布模型"><a href="#正态分布模型" class="headerlink" title="正态分布模型"></a>正态分布模型</h3><p>正态分布模型的一般表达式为：X ~ N(μ, σ)<br>其中μ为连续随机数模型的平均值，σ为连续随机数模型的标准差。X指的是随机数，而N代表的是Normal，指正态分布</p><h3 id="正态分布曲线图像"><a href="#正态分布曲线图像" class="headerlink" title="正态分布曲线图像"></a>正态分布曲线图像</h3><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaClipboard_2021-04-05-14-26-31.png"><br>如图所示，μ(模型的平均值)正好位于整个图像的中心位置，也就是曲线最突出的地方</p><h2 id="68-95-99-7规则-3σ原则"><a href="#68-95-99-7规则-3σ原则" class="headerlink" title="68-95-99.7规则(3σ原则)"></a>68-95-99.7规则(3σ原则)</h2><p>这三个数值分别对应μ ± σ(对应z = ±1)、μ ± 2σ(对应z = ±2)、μ ± 3σ(对应z = ±3)时曲线面积所对应的概率值<br>什么是z?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">     x - μ </span><br><span class="line">z = ———————— </span><br><span class="line">       σ</span><br></pre></td></tr></table></figure><p>当知道z值时，这个公式反过来可以推x。我们通过z值来寻找随机数x为某个特定的值时正态分布曲线所划往左分出的面积。正态分布的面积即表示概率<br>z表会提供对应z值的概率，请注意这个概率对应的是z<strong>左侧的面积</strong><br>如下图的蓝色部分<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaClipboard_2021-04-05-14-24-42.png"></p><p>z表：<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaClipboard_2021-04-05-14-25-45.png"></p><h3 id="推论"><a href="#推论" class="headerlink" title="推论"></a>推论</h3><ul><li>如果随机数X满足N(μ，σ)，那么Y = (X-μ)/σ满足N(0,1)</li><li>把两个都是正态分布的连续随机数相加，得到的正态分布模型会与最开始的完全不一样。虽然完全不一样，但是它的分布依然遵守正态分布模型</li></ul><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><p><a href="https://www.youtube.com/watch?v=CjF_yQ2N638">https://www.youtube.com/watch?v=CjF_yQ2N638</a></p><ul><li>给定Z问X</li><li>给定X问Z</li><li>Z值正负造成的不同(在平均值的左右)</li><li>利用平均值、标准差、利用68-95-99.7规则来求概率和人数</li><li>利用z表求概率和人数</li><li>通过概率，利用z表逆推求z</li></ul>]]></content>
      
      
      <categories>
          
          <category> 统计学导论 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>红黑树</title>
      <link href="/2021/03/25/%E7%AC%AC14%E7%AB%A0-%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
      <url>/2021/03/25/%E7%AC%AC14%E7%AB%A0-%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h2><ul><li>节点只有两种颜色，红色和黑色</li><li>根节点一定是黑色的</li><li>红色节点的父节点和子节点必须是黑色的</li><li>从当前节点(包括它本身)出发走到null，不论哪条路径所经过的黑色节点数目相同<br>因为这些原则的存在，红黑树中不可能存在三个节点的链状结构<blockquote><p><strong>黑高度(Black Height)</strong><br>黑高度指的是从一个节点出发到NIL节点上的黑节点个数<br>如果一个红黑树节点的高度为h，那么这个节点的<strong>黑高度 ≥ h/2</strong></p></blockquote></li></ul><blockquote><p><strong>高度(Height)与黑色节点</strong><br>一个有n个节点的红黑树，其高度<strong>h ≤ 2 log<del>2</del>(n + 1)</strong><br>一个有n个节点的红黑树，<strong>从根节点到NIL的路径上黑色节点最多有log<del>2</del>(n+1)个</strong>，黑色节点<strong>一共最多n/2的下界个</strong></p></blockquote><h3 id="为什么使用红黑树？"><a href="#为什么使用红黑树？" class="headerlink" title="为什么使用红黑树？"></a>为什么使用红黑树？</h3><p>在数据量庞大的时候，红黑树依然能快速搜索出想要寻找的元素，而且它是自平衡的二叉搜索树<br><strong>插入/删除/搜索的时间复杂度均为O(logn)</strong></p><blockquote><p> 相较于AVL树？<br>二者都是自平衡的BST，但各有利弊和擅长的领域<br>从自平衡角度出发，红黑树不如AVL平衡，但红黑树相较于AVL树在插入与删除中不用操作太多次旋转<br>因此，如果大量需要插入与删除，请使用红黑树作为数据结构<br>但是如果对搜索的需求更高，那么请使用AVL树</p></blockquote><br><h2 id="红黑树查找"><a href="#红黑树查找" class="headerlink" title="红黑树查找"></a>红黑树查找</h2><p>红黑树是一种特殊的BST，它的查找和AVL以及一般BST一样<br><br></p><blockquote><p><strong>节点关系</strong><br>在谈操作之前，看看这张图大概了解一下兄弟姐妹爸爸叔叔爷爷<br><strong>注意!!!</strong><br>Nil也可以作为叔叔，而且他一定是黑色的</p><p align="center"><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-04-06-22-55-14.png" style="zoom:50%;"></p></blockquote><h2 id="红黑树旋转与重新填色"><a href="#红黑树旋转与重新填色" class="headerlink" title="红黑树旋转与重新填色"></a>红黑树旋转与重新填色</h2><h3 id="重新填色"><a href="#重新填色" class="headerlink" title="重新填色"></a>重新填色</h3><p>重新填色的优先级永远比旋转高。当重新填色无法解决问题，我们才考虑旋转<br>NIL(真正的叶子节点)永远是黑色的<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-07-06-21-48-46.png" style="zoom:67%;"></p><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>旋转的方式与AVL树一样<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-07-06-21-46-30.png" style="zoom:67%;"><br><br></p><h2 id="红黑树新增"><a href="#红黑树新增" class="headerlink" title="红黑树新增"></a><font color="red">红黑树新增</font></h2><p><a href="https://www.youtube.com/watch?v=5IBxA-bZZH8">5min教学视频</a></p><ul><li>所有新插入的节点默认都是红色的</li><li>重新着色并旋转以平衡</li><li>插入操作中违反的主要性质是两个连续的红色节点</li><li>插入操作中，最重要的是父节点、叔叔节点的颜色</li><li>先看位置(case1)，然后看父节点的颜色(case2)，然后看叔叔节点的颜色(case3)，最后是叔叔节点的位置(case4、case5)<h3 id="插入位置为根节点"><a href="#插入位置为根节点" class="headerlink" title="插入位置为根节点"></a>插入位置为根节点</h3>这是红黑树新增里最简单的一种情况，直接把新增节点涂成黑色就好了</li></ul><h3 id="爸爸是黑色的"><a href="#爸爸是黑色的" class="headerlink" title="爸爸是黑色的"></a>爸爸是黑色的</h3><p>你不用做任何修改，因为红色节点不会影响红黑树的性质</p><h3 id="爸爸是红色的，叔叔是红色的"><a href="#爸爸是红色的，叔叔是红色的" class="headerlink" title="爸爸是红色的，叔叔是红色的"></a>爸爸是红色的，叔叔是红色的</h3><p>比较简单的一种情况，对叔叔、爸爸和爷爷重新上色<br>叔叔和爸爸改为黑色，爷爷改为红色</p><div align="center"><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-04-06-23-01-59.png" style="zoom:50%; display:inline;"><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-04-06-23-02-23.png" style="zoom:50%; display:inline;"></div><h3 id="爸爸是红色的，叔叔是黑色的-直线情况"><a href="#爸爸是红色的，叔叔是黑色的-直线情况" class="headerlink" title="爸爸是红色的，叔叔是黑色的(直线情况)"></a>爸爸是红色的，叔叔是黑色的(直线情况)</h3><p>在这种情况中，实际上子节点与他爸和他爷爷形成了一种直线关系：<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-04-06-23-17-45.png" style="zoom:50%;"></p><ul><li>解法是旋转爸爸和爷爷，旋转方向与子节点所在方向相反</li><li>旋转完之后，<strong>重新着色爸爸和爷爷</strong>，得到最终结果：<img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-04-06-23-21-15.png" style="zoom:50%;"></li></ul><h3 id="爸爸是红色的，叔叔是黑色的-三角形情况"><a href="#爸爸是红色的，叔叔是黑色的-三角形情况" class="headerlink" title="爸爸是红色的，叔叔是黑色的(三角形情况)"></a>爸爸是红色的，叔叔是黑色的(三角形情况)</h3><p>在这这种情况中，实际上子节点与他爸和他爷爷形成了一种三角恋(不是)关系：<br>解法是两次旋转</p><ul><li><p>旋转父节点与自己，使三角形折现变成直线</p></li><li><p>旋转爷爷与自己(交换位置)，<strong>重新着色爷爷和自己</strong></p><div align="center"><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-04-06-23-07-51.png" style="zoom:50%;"><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-07-06-22-11-35.png" style="zoom: 80%;"></div></li></ul><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p>看看就好(<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-04-06-23-40-02.png"></p><h2 id="红黑树删除"><a href="#红黑树删除" class="headerlink" title="红黑树删除"></a><font color="red">红黑树删除</font></h2><ul><li>重新着色并旋转以平衡</li><li>删除操作中，最重要的观测对象是兄弟节点的颜色</li><li>删除操作中主要违反的性质是：删除一个黑色节点会改变子树的黑高度，从而导致一个根到叶路径的黑高度降低<blockquote><p><strong>回顾BST删除</strong><br>BST的删除主要有三种：</p></blockquote></li><li>无子节点，直接删除</li><li>单子节点，子节点替换本身</li><li>双子节点，取左子树最小或右子树最大替换自己</li></ul><p>假设v是要删除的节点，u是要替换的新节点(NIL也是节点，并且他是黑色的)</p><h3 id="u或v是红色的"><a href="#u或v是红色的" class="headerlink" title="u或v是红色的"></a>u或v是红色的</h3><ul><li><p>将要被替换的节点u涂成黑色<br>这样做的目的是不影响到黑高度的大小</p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-07-07-00-21-22.png" style="zoom:67%;"></li></ul><h3 id="uv都是黑色的"><a href="#uv都是黑色的" class="headerlink" title="uv都是黑色的"></a>uv都是黑色的</h3><ul><li><p>将要被替换的节点u再涂一层黑色，变成双重黑色(Double Black)</p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-07-07-00-22-33.png" style="zoom: 80%;">#### 双重黑色问题</li><li><p>当当前节点u是双重黑色且不是根节点时，执行以下操作。设节点的兄弟结点为s，有如下三种情况：</p></li></ul><ol><li>s是黑色的，并且s至少有一个子节点是红色的</li></ol><ul><li><p>首先让s的红色子节点与爷爷处于“直线型”关系，在旋转之后重新涂色，使s变成红色，红子节点变黑</p></li><li><p>旋转原本的红子节点，使其处于爷爷的位置</p><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-07-07-00-28-24.png"></p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-07-07-00-29-15.png" style="zoom:80%;"></li></ul><ol start="2"><li>s是黑色的，并且它的两个子节点都是黑色的</li></ol><ul><li><p>将u身上的双重黑色转移到其父节点身上，涂红s</p></li><li><p>旋转s与p，重新涂色</p><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-07-07-00-28-29.png"></p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-07-07-00-29-24.png" style="zoom:80%;"></li></ul><ol start="3"><li>s是红色的</li></ol><ul><li>旋转s与p，使s成为爷爷</li><li>重新涂色小三角结构<img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-07-07-00-28-33.png"><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-07-07-00-29-31.png" style="zoom:80%;"></li></ul><h3 id="u是根节点"><a href="#u是根节点" class="headerlink" title="u是根节点"></a>u是根节点</h3><p>如果u是根节点，把它涂黑并返回(整树的黑高度减少1)</p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AVL算法</title>
      <link href="/2021/03/24/%E7%AC%AC13%E7%AB%A0-AVL%E7%AE%97%E6%B3%95/"/>
      <url>/2021/03/24/%E7%AC%AC13%E7%AB%A0-AVL%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a><font color="red">定义</font></h2><p>动机：因为有的时候二叉树简直退化成了链表，所以为了得到相对平衡的二叉树，发明了诸如AVL/RBT/Splay这样的平衡二叉树算法<br>节点创建：在创建的时候带上高度(height)这一新的参数，并写一个与高度有关的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AVL tree implementation in Java </span></span><br><span class="line"><span class="comment">// Create node </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123; </span><br><span class="line"><span class="keyword">int</span> item, height; </span><br><span class="line">Node left, right; </span><br><span class="line">Node(<span class="keyword">int</span> d) &#123; </span><br><span class="line">item = d;       <span class="comment">// 节点的值</span></span><br><span class="line">height = <span class="number">1</span>;     <span class="comment">// 节点高度，不是BF</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取节点高度</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(Node N)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (N == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">return</span> N.height; </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取最大的数</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> (a &gt; b) ? a : b; </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取平衡系数</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getBalanceFactor</span><span class="params">(Node N)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (N == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">return</span> height(N.left) - height(N.right); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AVL算法的目的是通过旋转让树每个节点的平衡系数BF的绝对值≤1。这样直接的好处是，<strong>AVL树的插入、搜索和删除的时间复杂度都是O(log<del>2</del>N)</strong></p><blockquote><p>平衡系数(Balance Factor)<br>BF是衡量一个节点的平衡情况的系数。一个节点的BF值 = 该节点左子树的高度 - 该节点右子树的高度<br>当树中所有节点的BF的绝对值都≤1时，我们认为这棵树是平衡的</p></blockquote><h2 id="AVL旋转"><a href="#AVL旋转" class="headerlink" title="AVL旋转"></a><font color="red">AVL旋转</font></h2><h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><p>将一个节点的父节点变为自己的左节点<br>如果该节点本身以及有两个节点：</p><ul><li>如果y有一个左子树，将x赋值为y的左子树的父节点</li><li>如果x的父节点为空，则让y作为树的根</li><li>否则如果x是p的左子节点，让y是p的左子节点</li><li>否则将y赋值为p的右子节点</li><li>让y作为x的父节点<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-03-24-23-37-49.png"></li></ul><h4 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h4><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-03-24-23-34-31.png"></p><h4 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node <span class="title">leftRotate</span><span class="params">(Node x)</span> </span>&#123; </span><br><span class="line">Node y = x.right; </span><br><span class="line">Node T2 = y.left; </span><br><span class="line">y.left = x; </span><br><span class="line">x.right = T2; </span><br><span class="line">x.height = max(height(x.left), height(x.right)) + <span class="number">1</span>; </span><br><span class="line">y.height = max(height(y.left), height(y.right)) + <span class="number">1</span>; </span><br><span class="line"><span class="keyword">return</span> y; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><p>和左旋类似，但是不同的是把操作放到了右边</p><ul><li>如果x有一个右子树，将y赋值为x右子树的父节点。</li><li>如果y的父节点为空，则让x作为树的根。</li><li>否则如果y是其父p的右子节点，那么x就是p的右子节点。</li><li>否则，将x赋值为p的左子节点。</li><li>让x作为y的父节点。<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-03-25-10-19-02.png"></li></ul><h4 id="图示-1"><a href="#图示-1" class="headerlink" title="图示"></a>图示</h4><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-03-25-10-18-11.png"></p><h4 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node <span class="title">rightRotate</span><span class="params">(Node y)</span> </span>&#123; </span><br><span class="line">Node x = y.left; </span><br><span class="line">Node T2 = x.right; </span><br><span class="line">x.right = y; </span><br><span class="line">y.left = T2; </span><br><span class="line">y.height = max(height(y.left), height(y.right)) + <span class="number">1</span>; </span><br><span class="line">x.height = max(height(x.left), height(x.right)) + <span class="number">1</span>; </span><br><span class="line"><span class="keyword">return</span> x; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="左右旋"><a href="#左右旋" class="headerlink" title="左右旋"></a>左右旋</h3><p>顾名思义，先左旋再右旋的一种方法。有时仅通过左旋或者右旋并没有办法达成目标，比如有拐点的二叉树，此时需要通过左右旋或者右左旋<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-07-06-17-00-10.png"></p><h3 id="右左旋"><a href="#右左旋" class="headerlink" title="右左旋"></a>右左旋</h3><p>左右旋的反过程，先右旋再左旋的一种方法<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-03-25-10-46-43.png"><br><br></p><h2 id="AVL新增"><a href="#AVL新增" class="headerlink" title="AVL新增"></a><font color="red">AVL新增</font></h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul><li>正常插入新节点</li><li>更新BF，判断是否为平衡二叉树</li><li>如果不是的话那么开始旋转吧！！！<h3 id="伪代码-2"><a href="#伪代码-2" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node <span class="title">insertNode</span><span class="params">(Node node, <span class="keyword">int</span> item)</span> </span>&#123; </span><br><span class="line">  <span class="comment">// 正常的插入新节点</span></span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> (<span class="keyword">new</span> Node(item)); </span><br><span class="line"><span class="keyword">if</span> (item &lt; node.item) node.left = insertNode(node.left, item); </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (item &gt; node.item) node.right = insertNode(node.right, item); </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> node; </span><br><span class="line">  <span class="comment">//更新节点的BF</span></span><br><span class="line">node.height = <span class="number">1</span> + max(height(node.left), height(node.right)); </span><br><span class="line"><span class="keyword">int</span> balanceFactor = getBalanceFactor(node); </span><br><span class="line">  <span class="comment">// 旋转开始</span></span><br><span class="line"><span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span>) &#123;                    <span class="comment">// 当节点的BF大于1，右旋</span></span><br><span class="line"><span class="keyword">if</span> (item &lt; node.left.item) &#123; </span><br><span class="line">      <span class="keyword">return</span> rightRotate(node); </span><br><span class="line">    &#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (item &gt; node.left.item) &#123; </span><br><span class="line">node.left = leftRotate(node.left); </span><br><span class="line"><span class="keyword">return</span> rightRotate(node); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line"><span class="keyword">if</span> (balanceFactor &lt; -<span class="number">1</span>) &#123;                  <span class="comment">// 当节点的BF小于-1，左旋</span></span><br><span class="line"><span class="keyword">if</span> (item &gt; node.right.item) &#123; </span><br><span class="line">        <span class="keyword">return</span> leftRotate(node); </span><br><span class="line">      &#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (item &lt; node.right.item) &#123; </span><br><span class="line">node.right = rightRotate(node.right); </span><br><span class="line"><span class="keyword">return</span> leftRotate(node); </span><br><span class="line">      &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> node; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br></li></ul><h2 id="AVL删除"><a href="#AVL删除" class="headerlink" title="AVL删除"></a><font color="red">AVL删除</font></h2><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ul><li>正常删除</li><li>更新BF，判断是否为平衡二叉树</li><li>如果不是那么开始旋转吧！！！<h3 id="伪代码-3"><a href="#伪代码-3" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Delete a node </span></span><br><span class="line"><span class="function">Node <span class="title">deleteNode</span><span class="params">(Node root, <span class="keyword">int</span> item)</span> </span>&#123; </span><br><span class="line"><span class="comment">// Find the node to be deleted and remove it </span></span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> root; </span><br><span class="line"><span class="keyword">if</span> (item &lt; root.item) root.left = deleteNode(root.left, item); </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (item &gt; root.item) root.right = deleteNode(root.right, item); </span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line"><span class="keyword">if</span> ((root.left == <span class="keyword">null</span>) || (root.right == <span class="keyword">null</span>)) &#123; </span><br><span class="line">Node temp = <span class="keyword">null</span>; </span><br><span class="line"><span class="keyword">if</span> (temp == root.left) temp = root.right; </span><br><span class="line"><span class="keyword">else</span> temp = root.left; </span><br><span class="line"><span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123; temp = root; root = <span class="keyword">null</span>; &#125; </span><br><span class="line"><span class="keyword">else</span> root = temp; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line">Node temp = nodeWithMimumValue(root.right); </span><br><span class="line">root.item = temp.item; </span><br><span class="line">root.right = deleteNode(root.right, temp.item); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> root; </span><br><span class="line">  <span class="comment">// Update the balance factor of each node and balance the tree </span></span><br><span class="line">  root.height = max(height(root.left), height(root.right)) + <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">int</span> balanceFactor = getBalanceFactor(root); </span><br><span class="line">  <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (getBalanceFactor(root.left) &gt;= <span class="number">0</span>) &#123; </span><br><span class="line">      <span class="keyword">return</span> rightRotate(root); </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root.left = leftRotate(root.left); </span><br><span class="line">        <span class="keyword">return</span> rightRotate(root); </span><br><span class="line">        &#125; </span><br><span class="line">      &#125; <span class="keyword">if</span> (balanceFactor &lt; -<span class="number">1</span>) &#123; </span><br><span class="line">        <span class="keyword">if</span> (getBalanceFactor(root.right) &lt;= <span class="number">0</span>) &#123; </span><br><span class="line">          <span class="keyword">return</span> leftRotate(root); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">          root.right = rightRotate(root.right); </span><br><span class="line">          <span class="keyword">return</span> leftRotate(root); </span><br><span class="line">          &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> root; </span><br><span class="line">      &#125;</span><br><span class="line">      root.height = max(height(root.left), height(root.right)) + <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">int</span> balanceFactor = getBalanceFactor(root); </span><br><span class="line">  <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span>) &#123; </span><br><span class="line">  <span class="keyword">if</span> (getBalanceFactor(root.left) &gt;= <span class="number">0</span>) &#123; <span class="keyword">return</span> rightRotate(root); &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123; </span><br><span class="line">  root.left = leftRotate(root.left); </span><br><span class="line">  <span class="keyword">return</span> rightRotate(root); </span><br><span class="line">  &#125; </span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">if</span> (balanceFactor &lt; -<span class="number">1</span>) &#123; </span><br><span class="line">  <span class="keyword">if</span> (getBalanceFactor(root.right) &lt;= <span class="number">0</span>) &#123; <span class="keyword">return</span> leftRotate(root); &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123; </span><br><span class="line">  root.right = rightRotate(root.right); </span><br><span class="line">  <span class="keyword">return</span> leftRotate(root); </span><br><span class="line">  &#125; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> root; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="AVL查找"><a href="#AVL查找" class="headerlink" title="AVL查找"></a>AVL查找</h2><p>AVL过的树也是BST，所以不用多说了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node <span class="title">nodeWithMimumValue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">Node current = node; </span><br><span class="line"><span class="keyword">while</span> (current.left != <span class="keyword">null</span>) </span><br><span class="line">current = current.left; </span><br><span class="line"><span class="keyword">return</span> current; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>L4-需求工程</title>
      <link href="/2021/03/19/L4-%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/"/>
      <url>/2021/03/19/L4-%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="L4-需求工程"><a href="#L4-需求工程" class="headerlink" title="L4-需求工程"></a>L4-需求工程</h1><markdown>  <details>    <summary><center>目标: 用例图(Use-Case Diagram)编写</center></summary><p>结构如下：</p><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-04-11-16-33-39.png"></p><h3 id="基本构成"><a href="#基本构成" class="headerlink" title="基本构成"></a>基本构成</h3><p>由五个部分组成</p><ul><li>包边界<br>大的项目边界，包含了用例、角色和主题</li><li>角色(小人+底下的角色名)<br>是所有可能与这个系统交互的人或系统</li><li>主体边界<br>显示的是被考虑的主体的边界。边界内的是所有该系统包含的用例</li><li>用例<br>用例指定主体可以是一个或多个角色<br>用例的外观是一个椭圆，定义了主体的行为而不去考虑其内部结构，指定了主体提供给用户的有用功能的一个单元</li><li>联系<br>角色与样例之间的联系，用实线表示</li></ul><h3 id="用例图的扩展"><a href="#用例图的扩展" class="headerlink" title="用例图的扩展"></a>用例图的扩展</h3><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-06-22-44-22.png"><br>use case不够用，有其他use case要加入，就extend,注意辨析extending use case和extended use case的先后关系（上面图里有)</p><h3 id="用例图的包含"><a href="#用例图的包含" class="headerlink" title="用例图的包含"></a>用例图的包含</h3><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-06-22-45-50.png"></p></details></markdown><h2 id="概念性定义"><a href="#概念性定义" class="headerlink" title="概念性定义"></a>概念性定义</h2><h3 id="需求工程"><a href="#需求工程" class="headerlink" title="需求工程"></a>需求工程</h3><p>发现、分析、记录和检查软件系统的服务和约束的过程称为需求工程(RE)</p><blockquote><p>The process of finding out, analyzing, documenting and checking the services and constraints of a software system is called requirements engineering (RE</p></blockquote><h3 id="利益相关者"><a href="#利益相关者" class="headerlink" title="利益相关者"></a>利益相关者</h3><p>利益相关者是与系统成功有利害关系的任何人:客户、最终用户、开发人员、项目经理、维护人员，甚至是那些营销系统的人</p><blockquote><p>A stakeholder is anyone who has a stake in the success of the system: the customer, the end users, the developers, the project manager, the maintainers, and even those who markets the system for example</p></blockquote><p>其中，还存在潜在利益相关者这一概念</p><h2 id="需求工程过程"><a href="#需求工程过程" class="headerlink" title="需求工程过程"></a>需求工程过程</h2><p>总体来说，需求工程可以划分为以下三个阶段</p><h2 id="需求抽出与分析"><a href="#需求抽出与分析" class="headerlink" title="需求抽出与分析"></a><font color="red">需求抽出与分析</font></h2><p>与涉众交互，发现用户和系统需求<br>评估项目的可行性+必要时做一个雏形（prototype）+审查要求</p><h3 id="需求抽出"><a href="#需求抽出" class="headerlink" title="需求抽出"></a>需求抽出</h3><ul><li>理解项目的方方面面</li><li>确定要做的工作</li><li>确定为这次项目提供功能性服务的部件（比如类，接口，方法等）</li><li>确定系统特性</li><li>确定限制因素（如：必须用MySQl做数据库，预算限制等）</li><li>确定系统的环境</li><li>确定新系统如何使用，如何帮助用户</li></ul><h3 id="需求分析模型"><a href="#需求分析模型" class="headerlink" title="需求分析模型"></a>需求分析模型</h3><ul><li>确定宏观需求和技术性需求</li><li>把需求细分为小需求，把可以一起搞的小需求放一组</li><li>确定不同需求实现的优先次序</li><li>做文档</li></ul><h3 id="领域需求"><a href="#领域需求" class="headerlink" title="领域需求"></a>领域需求</h3><p>由技术层、应用层得出，而不是由用户得出。因为不同的用户或利益相关者不知道他们确切想从计算机中得到什么，他们只会用自己贴近生活的语言描述，都是需要从技术层出发进行一次抽象，从现实生活到计算机能做到的需求的一次抽象</p><h3 id="由需求得出的三步走"><a href="#由需求得出的三步走" class="headerlink" title="由需求得出的三步走"></a>由需求得出的三步走</h3><h4 id="采访"><a href="#采访" class="headerlink" title="采访"></a><strong>采访</strong></h4><p> 在这一阶段，开发人员可以进行<strong>采访</strong>这一活动，以获得相关信息，比如“我要做什么”<br>访谈可以分为两种形式: </p><ol><li>开放式访谈，不预先准备问题，完全由利益相关者拿捏</li><li>封闭式访谈，预先准备一组问题，比如“你将使用这个项目来做什么工作流”一类的</li></ol><h4 id="民族志-这是什么"><a href="#民族志-这是什么" class="headerlink" title="民族志(???这是什么"></a><strong>民族志</strong>(???这是什么</h4><p> 总的来说，民族志是一种观察技术，可以用来理解操作过程，并帮助导出支持这些过程的软件需求<br> 比如说：你要写一个搬砖机器人的软件，你就要自己去搬砖，来观察搬砖操作流程，来知道软件具体要做什么，可以更好的提出需求</p><ol><li>让自己沉浸在搬砖的工作环境中</li><li>观察每天的搬砖工作并做笔记</li><li>发现人们实际上是如何搬砖的，而不是预定义的(标准的)业务流程</li><li>发现搬砖机器人系统的隐含需求</li></ol><h4 id="用户故事-Stories-与用户情节-Scenarios"><a href="#用户故事-Stories-与用户情节-Scenarios" class="headerlink" title="用户故事(Stories)与用户情节(Scenarios)"></a><strong>用户故事(Stories)与用户情节(Scenarios)</strong></h4><ul><li>Stories:叙事性描述，描述了系统的使用，描述了系统大致的架构。</li><li>Scenarios:在story的基础上，更细化，把里面的信息更结构化，、<blockquote><p>比如，stories只说了：用户打开电视，看到了视频。<br>Scenario则更加细化地说：开关按钮传入高电平信号到主板，系统分析后传出哪一个频道的图像信号，比Stories更加细化，结构化。</p></blockquote></li></ul><p>用户故事：设想一个人在使用你的软件。他的目的是什么？希望通过这个软件获得什么？可以写成有故事场景的记叙文(有点类似UI课)，主要囊括以下几个细节：</p><ol><li>描述系统如何用于某些特定的任务</li><li>描述人们做什么以及他们如何与系统交互</li><li>描述他们使用和生产什么信息</li><li>描述他们在这个过程中可能使用什么系统<details><summary>用户需求与系统需求</summary><markdown>### 用户需求</markdown></details></li></ol><ul><li>通常用图表用自然语言编写抽象声明的服务,系统应该提供或约束系统</li><li>通常是为非技术人员编写的<h3 id="系统需求"><a href="#系统需求" class="headerlink" title="系统需求"></a>系统需求</h3></li><li>详细描述软件系统的服务和操作约束</li><li>定义具体要实现的内容</li><li>它可能是系统投资者和软件之间的合同的一部分</li><li>通常是为技术人员编写的</li></ul><details>  <summary>功能需求与非功能需求</summary>  <markdown><h3 id="功能需求"><a href="#功能需求" class="headerlink" title="功能需求"></a>功能需求</h3><ul><li>表现为系统所需要实现的功能</li><li>根据要开发的系统的性质，重点可能会转移到系统的其他方面<blockquote><p>规定开发人员必须在产品中实现的软件功能，用户利用这些功能来完成任务，满足业务需求。功能需求有时也被称作行为需求 （behavīoral requirement），因为习惯上总是用“应该”对其进行描述：“系统应该发送电子邮件来通知用户已接受其预定”。功能需求描述是开发人员需要实现什 么。注意：用户需求不总是被转变成功能需求。产品特性，所谓特性（feature），是指一组逻辑上相关的功能需求，它们为用户提供某项功能，使业务目标 得以满足。对商业软件而言，特性则是一组能被客户识别，并帮助他决定是否购买的需求，也就是产品说明书中用着重号标明的部分。客户希望得到的产品特性和用 户的任务相关的需求不完全是一回事。一项特性可以包括多个用例，每个用例又要求实现多项功能需求，以便用户能够执行某项任务</p></blockquote></li></ul><h3 id="非功能需求"><a href="#非功能需求" class="headerlink" title="非功能需求"></a>非功能需求</h3><ul><li>将系统的特性作为一个整体来指定</li><li>非功能性需求比单独的功能性需求更重要</li><li>更难实现</li><li>具体表现在运行速度、安全性、可靠性、扩展性等等方面<blockquote><p>指依一些条件判断系统运作情形或其特性，而不是针对系统特定行为的需求。包括安全性、可靠性、互操作性、健壮性、易使用性、可维护性、可移植性、可重用性、可扩充性</p></blockquote></li></ul><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p>非功能性需求主要有三种：</p><ul><li><p>产品需求-指定或约束软件的运行时行为<br>  可用性、安全性、效率、独立性</p>  <img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedane20210629154933.png" width="450px/">  </li><li><p>组织需求-来自客户和开发人员组织的政策和程序的广泛系统需求</p><p>   组织的愿景、目标、目标和优先事项。<br>   业务和绩效计划。<br>   质量保证的系统、过程和要求。<br>   具体的变更计划。</p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedane20210629155105.png" width="450px/"></li><li><p>额外需求-源于系统的外部因素及其发展过程<br>  监管、法律、伦理、隐私等等</p>  <img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedane20210629155333.png" width="450px/"></li></ul><h4 id="可测量的非功能性需求"><a href="#可测量的非功能性需求" class="headerlink" title="可测量的非功能性需求"></a>可测量的非功能性需求</h4><p>非功能性需求的用户故事可以抽象成以下流程(质量属性场景，Quality Attribute Scenarios)：<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedane20210629133435.png"><br>刺激源 –传递刺激–&gt; 工件(环境) –反馈–&gt; 应对措施</p><ul><li><p>刺激源(Source of stimulus)：产生刺激的实体(人、计算机系统或任何其他执行器)</p></li><li><p>刺激（stimulus）：类似于一种输入或者事件，当它发生时，系统需要响应</p></li><li><p>环境（Environment）：在什么情况下，使用与应对刺激</p></li><li><p>工件（Artifact）：来应对刺激的东西</p></li><li><p>响应（response）：作为刺激到来的结果而进行的活动</p></li><li><p>反应测量（Response measure）：当响应发生时，它应该在某些方面是可测量的，以便对需求进行测试。<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedane20210629133625.png"></p></li></ul></markdown></details><details>  <summary>效用树(Utility Tree)</summary>  <markdown><h3 id="什么是效用树"><a href="#什么是效用树" class="headerlink" title="什么是效用树"></a>什么是效用树</h3><p>一种判断非功能性需求优先级的树，以确定在不惹利益相关者生气的情况下(?)率先实现哪些需求</p><h3 id="搭建效用树"><a href="#搭建效用树" class="headerlink" title="搭建效用树"></a>搭建效用树</h3><ul><li>根节点(2333)是被称作Utility的占位符标签</li><li>根节点的子节点，也就是树的第二层包含广泛的质量属性类别</li><li>树的第三个层次精炼了这些类别，把大类细分化小</li><li>需求被捕获为场景，装进用户故事<br>每个场景都由系统买家和架构师进行评级，级别分别为低(L)、中(M)或高(H)。•具有(H,H)评级的场景是最值得关注的场景</li></ul><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-04-11-16-20-43.png"></p>  </markdown></details><details>  <summary>可行性分析(Feasibility Study)</summary>  <markdown><p>主要分为两块：</p><h3 id="商业可行性分析"><a href="#商业可行性分析" class="headerlink" title="商业可行性分析"></a>商业可行性分析</h3><ul><li><p>运行可行性<br>拟议的系统将如何影响组织结构、工作程序和人员</p></li><li><p>经济可行性<br>评估项目的成本和收益，也被称作<strong>成本-收益分析(cost-benifit analysis)</strong></p><h3 id="技术可行性分析"><a href="#技术可行性分析" class="headerlink" title="技术可行性分析"></a>技术可行性分析</h3></li><li><p>技术可行性<br>评估所提议的技术解决方案的实用性以及技术技能、专门知识和资源的可用性</p></li><li><p>计划可行性<br>研究是否能在规定的时间内按时完成</p></li></ul></markdown></details><h2 id="需求规范"><a href="#需求规范" class="headerlink" title="需求规范"></a><font color="red">需求规范</font></h2><p>将需求转换为标准形式(系统、用户、商业)<br>主要有三个规范方式</p><ul><li>结构化自然语言(Structured Natural Language)<br>列一个很漂亮的表格，比如大鹏在lab2中提供的用户故事表，里面详细列出了该用户故事所要拎出来的重点：</li></ul><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-04-11-16-30-39.png"></p><p>结构化自然语言的要点：清晰、没有歧义、不要让人听不懂</p><ul><li>图形标记(Graphical Notation )<br>就是UML的用例图<br>人物(使用者，也被称作Actor)、他所能做的操作(UseCase，放到不同圈圈里了)、连线(Association，连接角色和他能做的事)</li></ul><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-04-11-16-33-39.png"></p><ul><li>数学规范<br>有限状态机？课件上给的例子是这个<br>状态和转移<br>从一个状态到下一个所需要的条件、执行的操作等等</li></ul><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-04-11-16-37-37.png"></p><h2 id="需求验证"><a href="#需求验证" class="headerlink" title="需求验证"></a><font color="red">需求验证</font></h2><p>评估项目的可行性;如有需要，建立<strong>原型</strong>; 评审需求</p><h3 id="领域需求-1"><a href="#领域需求-1" class="headerlink" title="领域需求"></a>领域需求</h3><p>领域需求来自于系统的应用领域，而不是来自于系统用户的特定需求</p><blockquote><p>Domain requirements are derived from the application domain of the system rather than from the specific needs of system users</p></blockquote><h4 id="检测方面"><a href="#检测方面" class="headerlink" title="检测方面"></a>检测方面</h4><ul><li>有效性检查<br>需求是否反映了系统用户的真实需求</li><li>一致性检查<br>识别冲突和混乱需求</li><li>完整性检查<br>文档化的需求是否定义了所有的功能和约束</li><li>现实检查<br>软件系统是否可以在建议的预算范围内实现或由现有技术支持</li><li>可验证性<br>功能和质量属性是否可验证</li></ul><h4 id="检测方法"><a href="#检测方法" class="headerlink" title="检测方法"></a>检测方法</h4><ul><li>测试用例(软件测试)<br>为有挑战性的需求实现测试用例</li><li>原型<br>开发系统的可执行模型</li><li>评审<br>分为内部评审和外部评审</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件工程与软件过程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ch14: 概率规则</title>
      <link href="/2021/03/19/Ch14%EA%9E%89%20%E6%A6%82%E7%8E%87%E8%A7%84%E5%88%99/"/>
      <url>/2021/03/19/Ch14%EA%9E%89%20%E6%A6%82%E7%8E%87%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="Ch14-概率规则"><a href="#Ch14-概率规则" class="headerlink" title="Ch14: 概率规则"></a>Ch14: 概率规则</h1><p>书本p383~p399<br>参考视频：<a href="https://www.youtube.com/watch?v=aVqmWW3xmdU">https://www.youtube.com/watch?v=aVqmWW3xmdU</a></p><h2 id="一般加法规则"><a href="#一般加法规则" class="headerlink" title="一般加法规则"></a>一般加法规则</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P(A or B) = P(A) + P(B) - P(A and B)</span><br></pre></td></tr></table></figure><ul><li>如果AB两个事件存在相交的部分，那么P(A或B)的概率就需要减去重复的那部分来<strong>去重</strong></li><li>如果AB两个事件是互斥的，那么P(A与B)的概率本身就为0，P(A或B)的概率可以简写成P(A)+P(B)<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaClipboard_2021-06-19-10-35-37.png"><br>Venn图是判断事件是否相交的有力工具<blockquote><p><strong>例题</strong><br>一项调查显示，50%的同学参加了学生会，28%的同学参加了魔法部，11%的同学两个部门都参加了。请问参加了学生会或者魔法部的同学有多少</p><blockquote><p>于是Venn图上有两个相交的圈，一个代表参加学生会的同学，另一个是参加魔法部的同学，它们相交的部分为11%。<br>圈子外的部分指的是两个会都没有参加的同学</p></blockquote></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P(参加了学生会或魔法部) = P(参加了学生会) + P(参加了魔法部) - P(同时参加了学生会和魔法部)</span><br><span class="line">                       = 0.5 + 0.28 - 0.11</span><br><span class="line">                       = 0.67</span><br></pre></td></tr></table></figure><h3 id="警惕自然语言与统计学术语之间的差异"><a href="#警惕自然语言与统计学术语之间的差异" class="headerlink" title="警惕自然语言与统计学术语之间的差异"></a>警惕自然语言与统计学术语之间的差异</h3>在统计学语言中，A或B的概率意味着A或B或两者的概率，指的是<strong>包含了两者的一个更为大的概念</strong>，有点只可意会不可言传…<br>但在日常语言中，“或”通常是唯一的版本，意思是<strong>其中之一</strong>，但不是两者都是<br>所以，不要让自然语言影响你的统计思维</li></ul><br><h2 id="条件概率与一般乘法规则"><a href="#条件概率与一般乘法规则" class="headerlink" title="条件概率与一般乘法规则"></a>条件概率与一般乘法规则</h2><h3 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h3><p>当我们想从一个声明条件A的分布中得到一个事件B的概率时，我们写P(B | A)，发音为” the probability of B given a.(当A作为前提的情况下发生B的概率) “<br>考虑到一个给定的条件的概率就叫做条件概率。简单的条件分布会直接告诉你P(A)、P(B)与P(A and B)<br>当涉及因素变量与分布变量时，最直观的解决条件概率的方法是列出联表(一般有两个因素变量作为横轴，其他的分布变量作为纵轴)</p><blockquote><p>因素变量是指采样的因素，比如男性和女性、老人和小孩、年龄分层等等<br>分布变量是指因素变量群体的具体选择，比如男性群体中有多少人选择参加学生会，有多少人选择参加魔法部</p></blockquote><h4 id="条件概率公式"><a href="#条件概率公式" class="headerlink" title="条件概率公式"></a>条件概率公式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">              P(A and B)</span><br><span class="line">P(B | A) =  ———————————————</span><br><span class="line">                 P(A)</span><br></pre></td></tr></table></figure><h3 id="一般乘法规则"><a href="#一般乘法规则" class="headerlink" title="一般乘法规则"></a>一般乘法规则</h3><p>对于不要求复合事件事件独立的一般乘法规则，通用的条件概率公式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P(A and B) = P(A) * P(B | A)</span><br><span class="line">P(A and B) = P(B) * P(A | B)</span><br></pre></td></tr></table></figure><p>当且仅当A与B互相为独立事件(事件A发生后不会影响事件B发生的概率，比如摸球放回)时，P(B | A) = P(B)；P(A | B) = P(A)<br>此时，乘法规则可以简单的写成P(A) * P(B)的形式<br>于是，当我们无法判断两个事件是否独立时，我们可以用一般乘法规则计算出其条件概率，再直接计算P(A) * P(B)，如果两个概率值一致则两个事件相互独立</p><br><h2 id="独立与互斥"><a href="#独立与互斥" class="headerlink" title="独立与互斥"></a>独立与互斥</h2><h3 id="独立性-Independence"><a href="#独立性-Independence" class="headerlink" title="独立性(Independence)"></a>独立性(Independence)</h3><p align="center"><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaST221-3.png" width="400px"></p><ul><li>两个事件独立<br>事件A发生之后不会影响到事件B发生的概率，比如摸球放回</li><li>两个事件不独立<br>事件A发生之后事件B发生的概率随之改变，比如摸球不放回</li></ul><h3 id="互斥-不相交-Mutually-Exclusive-Disjoint"><a href="#互斥-不相交-Mutually-Exclusive-Disjoint" class="headerlink" title="互斥/不相交(Mutually Exclusive/Disjoint)"></a>互斥/不相交(Mutually Exclusive/Disjoint)</h3><p align="center"><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaST221-2.png" width="400px"></p><p>看Venn图是最直接的，只要两个事件的圈不相交那么它们就是互斥的<br>换句话说，两个事件无法同时发生。比如丢出点数为1的骰子和点数为3的骰子无法同时发生</p><h3 id="独立不等同于不相交"><a href="#独立不等同于不相交" class="headerlink" title="独立不等同于不相交"></a>独立不等同于不相交</h3><p>两个事件独立与否，相当于两个面<br>独立的事件依然可以相交，虽然是两个面，但是向下投影如果能够重合那么就可以认定为是相交的(被我描述的极其抽象)</p><blockquote><p>听歌和下雨这两个事件相互独立，听歌位于“人的层面”，下雨位于“天气的层面”<br>当然可以一边下雨一边听歌，两件事情是可以同时发生的</p></blockquote><h3 id="不相交不等同于独立"><a href="#不相交不等同于独立" class="headerlink" title="不相交不等同于独立"></a>不相交不等同于独立</h3><p>不相交指两个事件无法同时发生，这两个事件一定是不独立的</p><blockquote><p>在路口遇到红灯和在路口遇到绿灯是两个事件，它们发生的概率各位50%<br>假设行人遭遇红灯，他不可能在遭遇红灯的同时遭遇绿灯，所以绿灯发生的概率为0。因为概率发生改变，所以两个事件不独立，但也不相交</p></blockquote><br><h2 id="概率问题的图形化求解"><a href="#概率问题的图形化求解" class="headerlink" title="概率问题的图形化求解"></a>概率问题的图形化求解</h2><h3 id="表格与Venn图"><a href="#表格与Venn图" class="headerlink" title="表格与Venn图"></a>表格与Venn图</h3><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaClipboard_2021-06-19-16-59-47.png"><br>71%的成年人在线使用Facebook, 18%使用Twitter, 15%两者都使用</p><h3 id="树状图"><a href="#树状图" class="headerlink" title="树状图"></a>树状图</h3><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaClipboard_2021-06-19-17-02-05.png"><br>树状图把事件序列表示为看起来像树的分支的路径<br>树状图的用武之地在于将复杂的与或关系用分支的形式展现了出来。这样，在求许多条件概率问题的时候树状图显得非常直观方便</p><br><h2 id="贝叶斯规则"><a href="#贝叶斯规则" class="headerlink" title="贝叶斯规则"></a>贝叶斯规则</h2><p>贝叶斯规则是条件概率的一种很复杂的写法，公式如下</p><p align="center"><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaST221-4.png" width="600"></p><p>他展示了条件概率的另一种求法。不过，一般我们通过树形图都可以得出正常需要的概率值</p>]]></content>
      
      
      <categories>
          
          <category> 统计学导论 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>L3-敏捷开发</title>
      <link href="/2021/03/18/L3-%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/"/>
      <url>/2021/03/18/L3-%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="L3-敏捷开发"><a href="#L3-敏捷开发" class="headerlink" title="L3-敏捷开发"></a>L3-敏捷开发</h1><markdown><details><summary><center>目标: 用户故事(User Story)编写</center></summary><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>用户故事是系统用户可能经历的使用场景</p><blockquote><p> a user story is a scenario of use that might be experienced by a system user</p></blockquote><h3 id="编写原则与格式"><a href="#编写原则与格式" class="headerlink" title="编写原则与格式"></a>编写原则与格式</h3><ul><li>(Who)作为一个角色(比如患者、总裁)</li><li>(Why)我想要(使用该软件的某个功能)…这样我就可以(达成某个想要实现的目标)…</li><li>用户故事还可能包括验收标准和意见</li></ul></details></markdown><h2 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a>敏捷开发</h2><blockquote><p>敏捷开发是目前最主流的软件开发方法<br>主要的两种敏捷开发模式：XP(极限开发)与Scrum</p></blockquote><h3 id="敏捷开发宣言"><a href="#敏捷开发宣言" class="headerlink" title="敏捷开发宣言"></a>敏捷开发宣言</h3><ul><li>个人和交互胜过过程和工具</li><li>工作软件胜过全面文档</li><li>客户协作胜于合同谈判</li><li>响应变化而不是遵循计划<h3 id="敏捷开发原则"><a href="#敏捷开发原则" class="headerlink" title="敏捷开发原则"></a>敏捷开发原则</h3></li><li>客户协助<br>用户应该与开发团队密切合作<br>用户应对系统进行反馈，并提出需求/改进建议</li><li>拥抱变革<br>对需求的更改可以在开发过程中的任何时候发生<br>随着需求的快速变化，计划可能很快变得不准确</li><li>增量提交<br>交付软件比遵循计划更重要<br>软件应该以增量和迭代的方式开发，每次交付都包含更多的功能</li><li>维护简单<br>对于软件和软件过程，保持一切简单<br>专注于向客户交付有价值的软件，而不是编写全面的文档</li><li>面向用户而非面向过程<br>关注团队中的人。工具和实践是第二<br>人们应该去发展他们自己的工作方式，而不是给予指令性的过程<br>发掘和探索团队成员的技能和知识，并信任他们</li></ul><ol><li>最重要的是通过尽早和不断交付有价值的软件满足客户需要。</li><li>我们欢迎需求的变化，即使在开发后期。敏捷过程能够驾驭变化，保持客户的竞争优势。</li><li>经常交付可以工作的软件，从几星期到几个月，时间尺度越短越好。</li><li>业务人员和开发者应该在整个项目过程中始终朝夕在一起工作。</li><li>围绕斗志高昂的人进行软件开发，给开发者提供适宜的环境，满足他们的需要，并相信他们能够完成任务。</li><li>在开发小组中最有效率也最有效果的信息传达方式是面对面的交谈。</li><li>可以工作的软件是进度的主要度量标准。</li><li>敏捷过程提倡可持续的开发速度。出资人、开发人员和用户应该保持长期，恒定的节奏。</li><li>对卓越技术与良好设计的不断追求将有助于提高敏捷性。</li><li>简单至关重要。</li><li>最好的架构、需求和设计都源自自我组织的团队。</li><li>每隔一定时间，团队都要反省，总结如何更有效率，然后相应地调整自己的行为。</li></ol><hr><h3 id="极限开发-XP"><a href="#极限开发-XP" class="headerlink" title="极限开发(XP)"></a><center>极限开发(XP)</center></h3><hr><blockquote><p>“XP is a style of software development focusing on excellent application of programming techniques, clear communication, and teamwork…”<br><strong>XP是一种专注于编程技术的优秀应用、清晰沟通和团队合作的软件开发风格……</strong></p></blockquote><h4 id="XP14大原则"><a href="#XP14大原则" class="headerlink" title="XP14大原则"></a>XP14大原则</h4><ul><li>关注成员<br>平衡团队需求和个人需求</li><li>关注价值<br>时间价值和系统和团队的期权价值</li><li>互惠互利<br>每一项活动都应使有关各方受益<br>编写自动化测试，帮助设计和实现更好的今天;把测试作为“文档”留给未来的程序员</li></ul><p><strong>别搞内部文档，好东西要分享，这是开源运动的核心原则之一</strong><br>重构以提高简洁性、清晰度和连贯性</p><ul><li>自相似性<br>将一个解决方案的结构运用到一个新的环境中，即使是在不同的尺度上</li><li>改进<br>立即开始一项活动，然后随着时间的推移改进结果</li><li>多样性<br>程序员应该一起解决问题，所有的意见都应该得到重视</li><li>反射<br>重温并分析为什么会导致成功/失败</li><li>活动流<br>持续的活动流而不是离散的阶段(小的增量，持续的集成)</li><li>机遇<br>将遇到的问题视作改变的机遇，有助于个人成长、加深关系、改进软件</li><li>冗余</li></ul><p><strong>软件开发中的困难问题应该用几种不同的方法来解决</strong></p><ul><li>失败<br>如果您有三种方法来实现<strong>user story</strong>，但您不知道该使用哪一种，那么尝试所有的方法</li><li>质量<br>质量可以通过缺陷、设计质量和开发经验来衡量</li><li>小的一步<br>每次进行一个测试，并一次集成和测试几个小时的更改</li><li>职责<br>无法指定责任，它<strong>只能被接受</strong><h3 id="XP工作流"><a href="#XP工作流" class="headerlink" title="XP工作流"></a>XP工作流</h3></li></ul><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-01-15-31-28.png"></p><ol><li>开启项目，编写user story<br>在项目开发的开始，产品经理和用户编写故事(程序员也可能参与)</li><li>估计故事和任务<br>如果story太大，产品经理可以将user story进行分割<br>如果程序员不理解主题，user story前将加上首字母大写的单词“Spike”</li><li>周期主题(冲刺目标)<br>产品经理和/或用户决定季度周期的“主题”(大画面)实现，直到整个项目完成</li><li>选定user story<br>产品经理/用户/程序员为每周主题选定合理数量的用户故事，并添加一些stack<br>迭代直到项目开发完成</li></ol><h4 id="XP流程中程序员的工作流"><a href="#XP流程中程序员的工作流" class="headerlink" title="XP流程中程序员的工作流"></a>XP流程中程序员的工作流</h4><p>日常临时会议：确定面临的问题以及解决方案<br>与同事配对，并进行快速设计（XP要求程序员两两配对一起写代码，会定期切换任务，你做他的他做你的）<br>测试：写每个小模块的单元测试<br>写代码，写能通过单元测试的代码。如果对需求有疑问，问用户去<br>重构：代码应通过所有单元测试，没有重复逻辑，确保良好的编码规范<br>问答：软件系统的用户应在现场回答问题，来帮助程序员更好地开发。用户和产品经理都能够做出决策。<br>整合各个部分，并通过系统测试<br>丢弃：丢掉不能用的部分<br>结束</p><hr><h3 id="Scrum框架"><a href="#Scrum框架" class="headerlink" title="Scrum框架"></a><center>Scrum框架</center></h3><hr><p>Scrum是一个软件开发的框架。在这个框架中，人们可以解决复杂的适应性问题，同时富有生产力和创造性地交付最高可能价值的产品</p><blockquote><p>A framework within which people can address complex adaptive problems, while productively and creatively delivering products of the highest possible value</p></blockquote><h4 id="Scrum框架-1"><a href="#Scrum框架-1" class="headerlink" title="Scrum框架"></a>Scrum框架</h4><ul><li>价值观<br>Scrum团队成员通过Scrum角色、事件和工件学习和探索承诺、勇气、专注、开放和尊重的价值</li><li>原则<br>将所有组件绑定在一起</li><li>团队<br>一个典型的Scrum团队包括一个产品负责人、一个开发团队和一个Scrum管理员</li><li>事件<br>对于所有Scrum团队来说，有四种正式的活动是共同的: Sprint(冲刺)计划、每日Scrum、Sprint复习和Sprint回顾</li><li>产品<br>产品待办事项、冲刺待办事项、投资组合待办事项、计划待办事项</li></ul><h4 id="Scrum工作流"><a href="#Scrum工作流" class="headerlink" title="Scrum工作流"></a>Scrum工作流</h4><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-01-15-30-52.png"></p><ul><li><p>愿景(Vision)<br>在这一阶段确定要实现的功能和目标等</p></li><li><p>产品待办事项列表管理人(Product Backlog Management)<br>产品负责人管理产品待办事项列表，也就是产品<strong>待定项</strong>、<strong>可用性</strong>和<strong>订购</strong><br>开发团队负责所有的评估，但是*<strong>所有的变更必须由产品所有者进行</strong></p></li></ul><p>什么是产品待办事项列表?</p><blockquote><p>所有特性、功能、增强和修复<br>这些建议可能会在评审、sprint评审或回顾之后从用户那里得到<br>这个列表是不断变化的，因为需求可能一直在改变。应该按照优先级排序，并给出一个值判断其实现与否</p></blockquote><ul><li>迭代计划(Sprint Planning)<br>整个Scrum团队共同为迭代工作创建一个计划，产品负责人给出了此迭代的目标，开发团队从产品待办事项列表中选择项目(没有人告诉团队该做什么)</li></ul><p>Sprint Backlog</p><blockquote><p>“Sprint Backlog是为Sprint选择的一组产品Backlog项，以及交付产品增量和实现Sprint目标的计划。”<br>选择Sprint Backlog中的条目来满足Sprint目标。sprint Backlog应该至少包含一个在前一个sprint的回顾会议中确定的高优先级的过程改进。Sprint Backlog中的计划应该有足够的细节来指导Daily Scrum<br>Sprint Backlog中的项目可以更改，但只能由开发团队更改Sprint Backlog可以用来监控Sprint进程。</p></blockquote><ul><li><p>冲刺回顾(Sprint Review)<br>Scrum团队和相关的涉众评审已经完成的工作<br>Scrum Master负责组织会议产品负责人解释已经做了什么和什么还没有做<br><strong>目的</strong><br>回顾时间线、预算和潜在能力回顾一下下一步最有价值的事情是什么<br>讨论产品待办事项列表的状态演示完成的工作并回答问题</p></li><li><p>冲刺回溯(Sprint Retrospective)<br>Scrum Master负责组织会议<br>Scrum Master鼓励团队进行改进<br>Scrum团队成员计划如何提高产品质量</p></li></ul><p><strong>目的</strong><br>检查上一次Sprint在人员、关系、过程和工具方面的进展情况，确定潜在的改进制定一个实施<strong>改进</strong>的计划</p><h4 id="Scrum角色"><a href="#Scrum角色" class="headerlink" title="Scrum角色"></a>Scrum角色</h4><p><strong>Scrum主持人(Scrum Master)</strong><br><em>职责</em></p><ul><li>帮助团队理解项目</li><li>促进事件</li><li>指导开发团队使用Scrum</li><li>消除障碍</li><li>规划Scrum实现</li><li>帮助产品负责人<blockquote><p>• Helping the team to understand the project<br>• Facilitating events<br>• Coaching the Development Team for Scrum<br>• Removing impediments<br>• Planning Scrum implementations<br>• Helping the Product Owner</p></blockquote></li></ul><p><strong>产品所有者(Product Owner)</strong><br>提出产品需求的人，或者说甲方</p><p><strong>开发团队(Development Team)</strong><br>咱，打工人罢了</p><hr><h3 id="XP与Scrum的区别"><a href="#XP与Scrum的区别" class="headerlink" title="XP与Scrum的区别"></a><center>XP与Scrum的区别</center></h3><hr><h4 id="四大不同点"><a href="#四大不同点" class="headerlink" title="四大不同点"></a>四大不同点</h4><ul><li>迭代长度不同<br>XP的一个迭代周期为1~2周，而Scrum则是2~4周</li><li>修改要求<br>在迭代过程中，Scrum不允许替换未能实现的User Story。而XP在一个迭代中，如果一个User Story还没有实现，则可以考虑用另外的需求将其替换，替换的原则是需求实现的时间量是相等的</li><li>User Story优先级<br>XP的实现必须遵守User Story的优先级，但是Scrum在这点上很灵活，因为在实现上可能存在依赖性的问题</li><li>是否采用严格的工程方法以保证进度或者质量<br>Scrum没有对软件的整个实施过程开出养个工程实践的处方，要求开发者自觉保证<br>而XP对整个流程方法定义非常严格，规定需要采用TDD,自动测试，结对编程，简单设计，重构等约束团队的行为</li></ul><p>不难发现，这四个区别显见的是：Scrum非常突出自我管理,而XP注重强有力的工程实践约束</p><h3 id="敏捷开发的问题"><a href="#敏捷开发的问题" class="headerlink" title="敏捷开发的问题"></a>敏捷开发的问题</h3><p>敏捷方法可能不适合嵌入式系统工程或大型复杂系统的开发</p><ul><li>敏捷的非正式性与大企业中常用的法律方法是不相容的(合同问题)</li><li>敏捷通常用于新软件系统开发，而不是软件维护</li><li>敏捷方法是为位于同一地点的小型团队设计的。对于具有多个地理分布的团队的大型项目，管理和协调的复杂性显著增加，因此敏捷方法的有效性变得可疑</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件工程与软件过程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>L2-软件过程</title>
      <link href="/2021/03/17/L2-%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B/"/>
      <url>/2021/03/17/L2-%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="L2-软件过程"><a href="#L2-软件过程" class="headerlink" title="L2-软件过程"></a>L2-软件过程</h1><markdown><details><summary><center>目标: 类图(Class Diagram)编写</center></summary><p>结构如下：</p><p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-02-09-56-57.png?token=APFFA5ID65ZB3QUI2NVLA5TAZBIZW"><br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/Clipboard_2021-05-02-10-30-38.png?token=APFFA5MHGUU2RLKM7NOWI5TAZBIZ4"></p><p>由三个结构组成：类名(位于1层)、变量名(位于2层)、方法(位于3层)</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li>公有变量<br>-变量名 : 类型</li><li> 保护变量<br>#变量名 : 类型</li><li> 私有变量</li></ul><p>+变量名 : 类型</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>-/#/+方法名(输入参数in : 类型，或者没有) : 返回值(没有就不写)</p><h3 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h3><p>抽象类跟类长得差不多，接口需要在1层上写&lt;&lt;interface&gt;&gt;</p><h3 id="类间关系"><a href="#类间关系" class="headerlink" title="类间关系"></a>类间关系</h3><p><a href="https://blog.csdn.net/K346K346/article/details/59582926">https://blog.csdn.net/K346K346/article/details/59582926</a></p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedane20210629214143.png" style="float:right; " width="200px;/"><ul><li><p>继承(Generalization)<br>由子类指向父类</p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedane20210629214253.png" style="float:right; " width="200px;/"></li><li><p>实现(Realization)<br>比如接口的方法被实现，由实现方指向接口</p></li></ul><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedane20210629214334.png" style="float:right; " width="200px;/"><ul><li><p>依赖(Dependency)<br>指的是使用另一个类的对象作为 返回值或输入值</p></li><li><p>关联、聚合与组合(Association, Aggregation and Composition)<br>组合相较于聚合更广，而聚合相较于关联更广</p></li></ul><blockquote><p>关联(Association)表示系统中对象之间的连接或关联，如学生与老师。他的依赖程度比依赖关系要强，比如学生可以没有电脑（虽然会导致部分以电脑为参数或者返回电脑的方法无法使用），但是学生不能没有老师（类A成为类B的属性(或者说变量)，而属性是一种更为紧密的耦合，更为长久的持有关系）</p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedane20210629214410.png"></blockquote><blockquote><p>聚合(Aggregation)是关联关系的一个子类型。它可以被描述为一种关系的“一部分(成员变量)”，如学生和班级。在聚合关系中，对象有独立的生命周期，使用者知道两个对象的存在</p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedane20210629214502.png"></blockquote><blockquote><p>组合(Composition)是聚合关系的一个子类型。它代表了一种“整体/部分”关系(在构造函数中实例化)，如学生和他的心。二者生命周期相同，存在一种封装关系，如果一个组合被删除，那么它的所有相关部分也将随之被删除</p><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedane20210629214527.png"></blockquote></details></markdown><h2 id="瀑布流模型-Waterfall-Model"><a href="#瀑布流模型-Waterfall-Model" class="headerlink" title="瀑布流模型(Waterfall Model)"></a>瀑布流模型(Waterfall Model)</h2><h3 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h3><p><strong>需求/定义 - 系统/软件设计 - 实现/单元测试 - 集成/系统测试 - 使用操作/维护</strong></p><blockquote><p>收集信息、需要实现的功能，分析是否可行，创建规格<br>将需求分配给硬件或软件系统，建立一个整体的系统架构<br>具体实现与单元测试<br>集成后进行系统测试；测试完之后即可交付用户<br>投入使用；后期维护与更新</p></blockquote><ul><li>最早发布的软件开发过程</li><li>源自大型军事系统工程中的工程流程<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3>适合：嵌入式系统、关键系统（对安全性要求高）、大型软件系统<br>不适合：必须应对变化的软件<br>原因：瀑布流模型充满了单向性，它使得变化难以发生</li></ul><h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p align="center"><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/imagesCS335-1.png"></p><h2 id="V模型-V-Model"><a href="#V模型-V-Model" class="headerlink" title="V模型(V-Model)"></a>V模型(V-Model)</h2><h3 id="核心思想与特点"><a href="#核心思想与特点" class="headerlink" title="核心思想与特点"></a>核心思想与特点</h3><p><strong>特点</strong>：简单、易于管理<br><strong>核心思想</strong>：鼓励在所有阶段进行测试，认为开发和测试同等重要</p><h3 id="图示-1"><a href="#图示-1" class="headerlink" title="图示"></a>图示</h3><p align="center"><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/imagesCS335-2.png"></p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>不适合需求经常变更的软件项目</li><li>对时间跨度长，复杂的面对对象程序也不合适</li></ul><h2 id="增量开发"><a href="#增量开发" class="headerlink" title="增量开发"></a>增量开发</h2><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ul><li>从软件系统最简单的部分开始实现</li><li>随着每次增量，产品不断发展，每次都添加增强功能，直到最终版本完成</li><li>代码被分割成小块，便于在开发流程中测试</li><li>在开发过程中很容易更改<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3></li><li>节省了需求变更时改变的开销<br>相对于瀑布流模型，需要写的文档比较少</li><li>快速接受反馈<br>容易获取反馈，用户可以评论，并给出有用的建议(感觉很像github)</li><li>提早交付部分可工作的产品<br>用户可以使用早期版本并伴随着整个开发周期<br>然而，增量式开发并不意味着每个增量都需要交付给用户<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3></li><li>流程不可视<br>需要定期交付来衡量进度<br>如果增量的迭代周期很短，为系统的每个版本生成文档是不划算的</li><li>系统结构会随着新增量的增加而降低<br>频繁的变更会给源代码和项目管理带来额外的负担，这可能对软件系统架构造成损害<br>随着更多的功能组件被添加到系统中，现有的架构可能需要相应修改，这可能会导致级联效应。<br>因此增量开发经常要重构</li></ul><p><strong>不适合开发大型、复杂和长生命周期的软件系统项目</strong></p><h2 id="螺旋模型-Spiral-Model"><a href="#螺旋模型-Spiral-Model" class="headerlink" title="螺旋模型(Spiral Model)"></a>螺旋模型(Spiral Model)</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><strong>初期需求 - 原型1 - 新需求 - 检验/验证 - 研发计划- 原型2 - 草图 - 检验/验证 - 测试计划 - 操作原型（检测和解决潜在的风险） - （开发和测试）细节设计 - 编写代码 - 集成 - 测试 - 实现 - 交付（计划接下来的限制）</strong></p><h3 id="图示-2"><a href="#图示-2" class="headerlink" title="图示"></a>图示</h3><p align="center"><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/imagesCS335-3.png"></p><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><h4 id="原型Prototype"><a href="#原型Prototype" class="headerlink" title="原型Prototype"></a>原型Prototype</h4><blockquote><p>“A prototype is a temporary implementation of some functional subset of the system, often presented to users for feedback and validation, which is then discarded when the validation exercise is complete.”<br><strong>原型是系统某些功能子集的临时实现，通常呈现给用户以获得反馈和验证，然后当验证工作完成时就会丢弃</strong></p></blockquote><h4 id="概念验证阶段Proof-of-Concept"><a href="#概念验证阶段Proof-of-Concept" class="headerlink" title="概念验证阶段Proof-of-Concept"></a>概念验证阶段Proof-of-Concept</h4><blockquote><p>”A proof-of-concept is some code designed to prove that a risky element of the proposed architecture is feasible and to highlight any problems and pitfalls. A proof-of-concept is also a temporary implementation, which is discussed when it has served its purpose and the risk under investigation is understood.”<br><strong>概念证明是一些代码，用来证明所提议的架构中的风险元素是可行的，并突出任何问题和缺陷。概念验证也是一种临时的实施，当它达到目的并了解调查中的风险时才会讨论</strong></p></blockquote><p>说人话大概是：证明一个有风险的代码块有可能作妖，并且突出有缺陷的部分（就一个纠错代码）</p><h4 id="骨架系统Skeleton-System"><a href="#骨架系统Skeleton-System" class="headerlink" title="骨架系统Skeleton System"></a>骨架系统Skeleton System</h4><blockquote><p>”A skeleton implements the system’s main architectural structures but contains only a minimal subset of the system’s functionality. A skeleton system is retained rather than discarded and becomes the basis for the construction phase.” A skeleton system is sometimes called an “evolutionary prototype”.<br><strong>一个框架实现系统的主要架构结构，但只包含系统功能的最小子集。一个骨架系统被保留而不是丢弃，并成为构建阶段的基础。骨骼系统有时被称为“进化原型</strong></p></blockquote><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>降低风险</li><li>降低需要开发的软件总量</li><li>快速交付</li></ul><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul><li>需求妥协可能会改变系统的原始想法</li><li>对系统进化的控制有限</li></ul><h2 id="集成-amp-配置"><a href="#集成-amp-配置" class="headerlink" title="集成&amp;配置"></a>集成&amp;配置</h2><p>原理：注重重复使用已有部件（接口，类，方法等）</p><h3 id="开发过程"><a href="#开发过程" class="headerlink" title="开发过程"></a>开发过程</h3><p><strong>需求确定 -&gt; software discovery evaluation:确定需要的部件和子系统 -&gt; 提取出可以重用的部件 -&gt; Application System Configuration:如果有现成部件可以用，则优先考虑使用 -&gt; Component Adaptation &amp; Integration：没有现成部件能用，才考虑开发新部件</strong></p><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul><li>复用组件，减少开发工作量</li><li>减少开销和风险</li><li>开发速度快</li></ul><h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><ul><li>要用已有的部件，但已有部件的功能又不是很符合需求，需求可能会妥协，进而改变了需求</li><li>你用了已有部件，结果部件更新了，更新前合适，更新后不合适</li></ul><h2 id="理性统一过程-Rational-Unified-Process"><a href="#理性统一过程-Rational-Unified-Process" class="headerlink" title="理性统一过程(Rational Unified Process)"></a>理性统一过程(Rational Unified Process)</h2><p>包括以下四点：</p><ul><li>   起始<strong>Inception</strong>: 分析部分use case的非功能性需求（安全性，可扩展性等），创建business case，做开发环境的准备工作</li><li>细化<strong>Elaboration</strong>: 对核心，有风险软件的结构进行了编程和测试，大部分需求都确定，不会变了。主要风险被减轻；包含迭代。</li><li>   架构<strong>Construction</strong>: 涉及系统设计、实现和测试，系统的部分被开发或集成了，完成此阶段后，应准备好部分工作系统和相关文件并交付给用户。</li><li>   转变<strong>Transition</strong>: 可以被用到现实中去，在此过程完成后，项目应能正常运行，文档也写好了。</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h4 id="没有什么软件开发模型适合所有项目"><a href="#没有什么软件开发模型适合所有项目" class="headerlink" title="没有什么软件开发模型适合所有项目"></a>没有什么软件开发模型适合所有项目</h4>]]></content>
      
      
      <categories>
          
          <category> 软件工程与软件过程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树</title>
      <link href="/2021/03/17/%E7%AC%AC12%E7%AB%A0-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>/2021/03/17/%E7%AC%AC12%E7%AB%A0-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>BST在二叉树的基础上引入了左小右大的规则<br>一个父节点，它左边的元素必然小于其本身，而右边的元素则大于其本身</p><h3 id="推理"><a href="#推理" class="headerlink" title="推理"></a>推理</h3><ul><li>BST中<strong>最小</strong>的元素是叶子节点中最左边的那个</li><li>BST中<strong>最大</strong>的元素是叶子节点最右边的那个</li><li>搜索元素的平均时间复杂度为O(log<sub>2</sub>n)，这同时也是BST的平均高度</li><li>退化的BST的高度可以达到n，这也是最坏的情况，O(n)</li><li>最好的情况是要找的元素是根节点，O(1)</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>BST中的每个元素有一个特殊的键值，其中根节点的key为1，<strong>注意不是0</strong></p><p align="center"><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneCS211-5.png" width="600"></p><p>节点代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> value;</span><br><span class="line">  Node left;</span><br><span class="line">  Node right;</span><br><span class="line">  Node(<span class="keyword">int</span> value)&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    right = <span class="keyword">null</span>; </span><br><span class="line">    left = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个用于定义Node属性的类，构造函数为Node赋值，Node类里定义了两种类型的Node（左节点或右节点）<br><br></p><h2 id="BST插入"><a href="#BST插入" class="headerlink" title="BST插入"></a>BST插入</h2><ul><li>时间复杂度: O(log<del>2</del>N)</li><li>从根节点开始尝试插入。如果新node的值小于当前节点,插入到左子节点</li><li>如果新节点的值大于当前节点,插入到右子节点</li><li>当前节点为空时,我们已经达到了一个叶子节点,可以把新node插入在这个位置<br>代码实现如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node current, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(current == <span class="keyword">null</span>)&#123;                        <span class="comment">// 找到了自己的位置，返回一个新的Node对象，构造函数内输入value值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node(value);</span><br><span class="line">  &#125;<span class="keyword">if</span>(value &gt; current.value)&#123;                 <span class="comment">// 新插入的值比当前node的值更大，往右走</span></span><br><span class="line">    current.right = add(current.right,value);</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(value &lt; current.value)&#123;            <span class="comment">// 新插入的值比当前node的值更小，往左走</span></span><br><span class="line">    current.left = add(current.left,value)</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;                                      <span class="comment">// 这个数已经存在于BST中了</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>本质是<strong>递归思想</strong></li></ul><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>嗯，最好封装一下，新的方法里面只有一句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; </span><br><span class="line">root = addRecursive(root, value);         <span class="comment">// root就是根节点，因为是从根节点开始插入的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>于是，我们创建一个BST，可以这么写：</p><p align="center"><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneCS211-6.png" width="600"></p><br><h2 id="BST搜索"><a href="#BST搜索" class="headerlink" title="BST搜索"></a>BST搜索</h2><ul><li>时间复杂度: O(log<del>2</del>N)<br>代码实现：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">containsNodeRecursive</span><span class="params">(Node current, <span class="keyword">int</span> value)</span> </span>&#123; </span><br><span class="line"><span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> <span class="keyword">false</span>; &#125;              <span class="comment">// 找到底了还没找到，这个节点不在BST中</span></span><br><span class="line"><span class="keyword">if</span> (value == current.value) &#123;                       <span class="comment">// 找到了</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> value &lt; current.value                        <span class="comment">// 三元判别式</span></span><br><span class="line">? containsNodeRecursive(current.left, value)      <span class="comment">// 如果要查找的值比当前节点的值小，那么往当前节点的左子树查找</span></span><br><span class="line">: containsNodeRecursive(current.right, value);    <span class="comment">// 如果要查找的值比当前节点的值大，那么往当前节点的右子树查找</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>还是用了<strong>递归</strong>的思想</li></ul><h3 id="封装-1"><a href="#封装-1" class="headerlink" title="封装"></a>封装</h3><p>这毕竟是面向对象的五大原则之一(单一职责)，这样我们调用的时候就比较方便</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; </span><br><span class="line"><span class="keyword">return</span> containsNodeRecursive(root, value); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="BST删除"><a href="#BST删除" class="headerlink" title="BST删除"></a>BST删除</h2><ul><li>时间复杂度: O(log<del>2</del>N)<br>删除比较麻烦。是三种操作中最麻烦的，分以下三种情况：<h3 id="无子节点"><a href="#无子节点" class="headerlink" title="无子节点"></a>无子节点</h3></li><li>如果这个节点没有子节点，那么可以直接删除该节点<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(current.left == <span class="keyword">null</span> &amp;&amp; current.right == <span class="keyword">null</span>)&#123;    <span class="comment">// 两个子节点都不存在</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;                                        <span class="comment">// 删除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="单子节点"><a href="#单子节点" class="headerlink" title="单子节点"></a>单子节点</h3><ul><li>如果这个节点有一个子节点，那么<strong>唯一的子节点将替代它的位置</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(current.right == <span class="keyword">null</span>)&#123;              <span class="comment">// 右子节点不存在</span></span><br><span class="line">  <span class="keyword">return</span> current.left;                  <span class="comment">// 返回左子节点替代自己</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(current.left == <span class="keyword">null</span>)&#123;               <span class="comment">// 左子节点不存在</span></span><br><span class="line">  <span class="keyword">return</span> current.right;                 <span class="comment">// 返回右子节点替换自己</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="双子节点"><a href="#双子节点" class="headerlink" title="双子节点"></a>双子节点</h3><ul><li>如果这个节点有两个子节点，那么<strong>取这个节点的左子树叶子的最大值或者这个节点的右子树叶子的最小值替换被删除的节点</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> smallestValue = findSmallestValue(current.right);             <span class="comment">// 找到右子树的最小值</span></span><br><span class="line">current.value = smallestValue; </span><br><span class="line">current.right = deleteRecursive(current.right, smallestValue); </span><br><span class="line"><span class="keyword">return</span> current;</span><br><span class="line"><span class="comment">// 找到右子树的最小值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findSmallestValue</span><span class="params">(Node root)</span> </span>&#123; </span><br><span class="line"><span class="keyword">return</span> root.left == <span class="keyword">null</span> ? root.value : findSmallestValue(root.left); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最后一种其实也不难，因为左子树的最大值就是左子树叶子节点中最右边的元素。实际上可以嵌套一个Find</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">deleteRecursive</span><span class="params">(Node current, <span class="keyword">int</span> value)</span></span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;<span class="keyword">if</span> (value == current.value)&#123;                             <span class="comment">// 找到了要删除的元素</span></span><br><span class="line">    <span class="comment">//.. code to delete the node will go here</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无子节点</span></span><br><span class="line">    <span class="keyword">if</span>(current.left == <span class="keyword">null</span> &amp;&amp; current.right == <span class="keyword">null</span>)&#123;      <span class="comment">// 两个子节点都不存在</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;                                          <span class="comment">// 删除</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单子结点</span></span><br><span class="line">    <span class="keyword">if</span>(current.right == <span class="keyword">null</span>)&#123;              <span class="comment">// 右子节点不存在</span></span><br><span class="line">      <span class="keyword">return</span> current.left;                  <span class="comment">// 返回左子节点替代自己</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(current.left == <span class="keyword">null</span>)&#123;               <span class="comment">// 左子节点不存在</span></span><br><span class="line">      <span class="keyword">return</span> current.right;                 <span class="comment">// 返回右子节点替换自己</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双子节点</span></span><br><span class="line">    <span class="keyword">if</span>(current.left != <span class="keyword">null</span> &amp;&amp; current.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">int</span> smallestValue = findSmallestValue(current.right);             <span class="comment">// 找到右子树的最小值</span></span><br><span class="line">      current.value = smallestValue;                                    <span class="comment">// 替换自己</span></span><br><span class="line">      current.right = deleteRecursive(current.right, smallestValue);    <span class="comment">// 删除右子树的最小值</span></span><br><span class="line">      <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">if</span> (value &lt; current.value)&#123;</span><br><span class="line">        current.left = deleteRecursive(current.left, value);</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">  &#125;</span><br><span class="line">  current.right = deleteRecursive(current.right, value);</span><br><span class="line">  <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="BST遍历"><a href="#BST遍历" class="headerlink" title="BST遍历"></a>BST遍历</h2><h3 id="广度优先遍历-BFS"><a href="#广度优先遍历-BFS" class="headerlink" title="广度优先遍历(BFS)"></a>广度优先遍历(BFS)</h3><p>这种一般是用Queue实现的</p><ul><li>Level-Order</li><li>遍历顺序是逐层遍历</li><li>**时间复杂度：O(n)**，n为节点个数<br>伪代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printLevelOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">      Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">      queue.add(root);</span><br><span class="line">      <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">          TreeNode temp = queue.poll();</span><br><span class="line">          System.out.print(temp.data + <span class="string">&quot; &quot;</span>);</span><br><span class="line">          <span class="comment">/*add left child to the queue */</span></span><br><span class="line">          <span class="keyword">if</span> (temp.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">              queue.add(temp.left);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">/*add right right child to the queue */</span></span><br><span class="line">          <span class="keyword">if</span> (temp.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">              queue.add(temp.right);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="代码挺好理解"><a href="#代码挺好理解" class="headerlink" title="代码挺好理解"></a>代码挺好理解</h4><ul><li>把根节点丢尽queue里</li><li>dequeue根节点，同时把根节点的左右子节点enqueue</li><li>继续dequeue和enqueue，就完成了广度优先遍历</li></ul><hr><h3 id="深度优先遍历-DFS"><a href="#深度优先遍历-DFS" class="headerlink" title="深度优先遍历(DFS)"></a>深度优先遍历(DFS)</h3><ul><li><strong>时间复杂度: O(n)</strong>, n为节点个数<br><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneClipboard_2021-07-06-14-47-46.png"><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4></li><li>Pre-Order</li><li>遍历顺序是父节点-左子树-右子树</li><li>时间复杂度：O(n)，n为节点个数<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode root, List &lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 访问节点。在这里把它加到一个list里去了，你也可以把它打印出来</span></span><br><span class="line">    list.add(root.val);</span><br><span class="line">    <span class="comment">// 遍历左子节点</span></span><br><span class="line">    preorder(root.left, list);</span><br><span class="line">    <span class="comment">// 遍历右子节点</span></span><br><span class="line">    preorder(root.right, list);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>实际上，这是BST相关算法题里比较常用到的遍历方法，因为<strong>中序遍历BST得到的结果是一个有序的数组/列表</strong></p><ul><li>In-Order</li><li>遍历顺序是左子树-父节点-右子树</li><li>时间复杂度：O(n)，n为节点个数</li></ul><p><strong>中序遍历结合列表的写法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, List &lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 遍历左子节点</span></span><br><span class="line">    inorder(root.left, list);</span><br><span class="line">    <span class="comment">// 访问节点。在这里把它加到一个list里去了，你也可以把它打印出来</span></span><br><span class="line">    list.add(root.val);</span><br><span class="line">    <span class="comment">// 遍历右子节点</span></span><br><span class="line">    inorder(root.right, list);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><hr><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><ul><li>Post-Order</li><li>遍历顺序是左子树-右子树-父节点</li><li>时间复杂度：O(n)，n为节点个数<br>伪代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode root, List &lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 遍历左子节点</span></span><br><span class="line">    postorder(root.left, list);</span><br><span class="line">    <span class="comment">// 遍历右子节点</span></span><br><span class="line">    postorder(root.right, list);</span><br><span class="line">    <span class="comment">// 访问节点。在这里把它加到一个list里去了，你也可以把它打印出来</span></span><br><span class="line">    list.add(root.val);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><p>使用迭代的方式进行遍历：利用stack的结构，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode biTree)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//非递归实现</span></span><br><span class="line">Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line"><span class="keyword">while</span>(biTree != <span class="keyword">null</span> || !stack.isEmpty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(biTree != <span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(biTree.value);</span><br><span class="line">stack.push(biTree);</span><br><span class="line">biTree = biTree.left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!stack.isEmpty())</span><br><span class="line">&#123;</span><br><span class="line">biTree = stack.pop();</span><br><span class="line">biTree = biTree.right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我觉得我是需要一些可视化理解</p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>L1-软件工程介绍</title>
      <link href="/2021/03/16/L1-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%BB%8B%E7%BB%8D/"/>
      <url>/2021/03/16/L1-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="L1-软件工程介绍"><a href="#L1-软件工程介绍" class="headerlink" title="L1-软件工程介绍"></a>L1-软件工程介绍</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="软件工程的定义"><a href="#软件工程的定义" class="headerlink" title="软件工程的定义"></a>软件工程的定义</h3><blockquote><p>“Software engineering is an engineering discipline that is concerned with all aspects of software production from initial conception to operation and maintenance.”<br><strong>软件工程是一门工程学科，涉及软件生产的各个方面，从最初的概念到操作和维护</strong></p></blockquote><ul><li>选择最佳的<em>理论</em> 和<em>工具</em> 用于开发</li><li>在<em>财务限制</em> 的范围内开发（好惨，但是现实如此</li><li>在这些限制条件下找到解决方案</li></ul><h3 id="软件过程的定义"><a href="#软件过程的定义" class="headerlink" title="软件过程的定义"></a>软件过程的定义</h3><blockquote><p>“The systematic approach that is used in software engineering is sometimes called a software process. A software process is a sequence of activities that leads to the production of a software product.”<br><strong>在软件工程中使用的系统方法有时被称为软件过程。软件过程是导致软件产品生产的一系列活动</strong></p></blockquote><p>软件过程可以被称作软件过程模型，就是瀑布、V那些开发框架</p><h2 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h2><h3 id="软件工程基础"><a href="#软件工程基础" class="headerlink" title="软件工程基础"></a>软件工程基础</h3><ul><li><p>可靠性</p><blockquote><p>没有故障<br>在需要的时候可以用<br>安全可靠</p></blockquote></li><li><p>满足需求</p><blockquote><p>理解不同利益相关者的期望<br>平衡冲突需求<br>在分配的预算和时间内交付软件系统</p></blockquote></li><li><p>复用管理</p><blockquote><p>有效利用现有资源，包括员工、技能、可用技术和软件</p></blockquote></li><li><p>流程</p><blockquote><p>使用管理和理解的开发过程，这可能取决于要开发的软件类型<br>组织和计划开发过程</p></blockquote></li></ul><h2 id="软件过程"><a href="#软件过程" class="headerlink" title="软件过程"></a>软件过程</h2><h3 id="软件过程的基本流程"><a href="#软件过程的基本流程" class="headerlink" title="软件过程的基本流程"></a>软件过程的基本流程</h3><p>这是一个循环</p><ul><li><b>软件规范：</b>需求/制约</li><li><b>软件开发：</b>设计/开发</li><li><b>软件确认：</b>全面的软件测试</li><li><b>软件进化：</b>修正/应对变化发展</li></ul><h3 id="评价一个软件的质量"><a href="#评价一个软件的质量" class="headerlink" title="评价一个软件的质量"></a>评价一个软件的质量</h3><p>主要从四个方面衡量</p><ul><li>兼容性<blockquote><p>软件需要被目标用户群体兼容<br>软件是可懂的、可用的，与系统兼容</p></blockquote></li><li>安全可靠性<blockquote><p>软件是可信赖的、安全可靠的<br>在出现故障时不应该造成物理或经济上的损害</p></blockquote></li><li>效率<blockquote><p>软件不应该占用浪费太多系统资源<br>效率包括响应性、处理时间和资源利用率等</p></blockquote></li><li>可维护性<blockquote><p>软件的开发应该以一种能够适应客户不断变化的需求的方式进行（版本更迭）</p></blockquote></li></ul><h2 id="软件类型"><a href="#软件类型" class="headerlink" title="软件类型"></a>软件类型</h2><h4 id="独立系统"><a href="#独立系统" class="headerlink" title="独立系统"></a>独立系统</h4><ul><li>运行在个人电脑、移动设备或大型机上的应用程序<br>如：Adobe Photoshop, Windows Calculator等</li></ul><h4 id="交互式系统"><a href="#交互式系统" class="headerlink" title="交互式系统"></a>交互式系统</h4><ul><li>运行在远程计算机上，但用户可以从自己的计算机访问的应用程序<br>如：网络应用、淘宝应用、云服务等</li></ul><h4 id="嵌入式系统"><a href="#嵌入式系统" class="headerlink" title="嵌入式系统"></a>嵌入式系统</h4><ul><li>控制和管理硬件设备的软件<br>如：冰箱温度控制，微波炉烹饪功能，油泵控制等</li></ul><h4 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h4><ul><li>大批量处理数据的应用系统<br>如：手机计费系统、员工工资支付系统、银行交易处理系统等</li></ul><h4 id="娱乐系统"><a href="#娱乐系统" class="headerlink" title="娱乐系统"></a>娱乐系统</h4><ul><li>这些系统大多是可以在个人电脑或特殊主机硬件上运行的游戏<br>如：Xbox、PS4、任天堂</li></ul><h4 id="建模-仿真系统"><a href="#建模-仿真系统" class="headerlink" title="建模/仿真系统"></a>建模/仿真系统</h4><ul><li>为科学家和工程师开发的应用系统<br>以模拟物理过程、化学反应、蛋白质折叠、可视化等</li></ul><h4 id="数据收集-分析系统"><a href="#数据收集-分析系统" class="headerlink" title="数据收集/分析系统"></a>数据收集/分析系统</h4><ul><li>从环境中收集数据并将数据发送到其他系统进行处理的软件系统<br>如：数据仓库、数据湖、大数据分析系统、传感器数据处理系统等</li></ul><h4 id="为系统搭建的系统"><a href="#为系统搭建的系统" class="headerlink" title="为系统搭建的系统"></a>为系统搭建的系统</h4><ul><li>大型企业或组织中使用的系统或子系统。<br>如：企业资源计划(ERP)系统，或由其他离散系统组成的系统。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件工程与软件过程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>哈希表</title>
      <link href="/2021/03/16/%E7%AC%AC11%E7%AB%A0-%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>/2021/03/16/%E7%AC%AC11%E7%AB%A0-%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是哈希表"><a href="#什么是哈希表" class="headerlink" title="什么是哈希表"></a>什么是哈希表</h2><blockquote><p>A hash table is a collection of items which are stored in such a way as to make it easy to find them later.<br><strong>哈希表是一组项的集合，这些项的存储方式便于以后查找.key的命名从0开始</strong></p></blockquote><ul><li>有Hash Function(计算Hash Value)</li><li>得出Hash Value之后，真正的key值为hv%数组的长度</li><li>有一个结构存放数据，最佳情况是使用键值对组成的哈希表（链表数组）</li></ul><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>哈希表搜索的时间复杂度是O(1)，因为每个元素都有对应的key值，直接抓出key值就是对应元素了</p><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>数经过哈希函数获得哈希值(hash)，随后哈希值%数组长度获得index<br>一个好的hash function应该具有以下几种功能：</p><ul><li>容易计算</li><li>均匀分布</li><li>减少碰撞</li></ul><h3 id="余数法"><a href="#余数法" class="headerlink" title="余数法"></a>余数法</h3><ul><li>拿到需要hash的数x(或者说<strong>key</strong>)，使用hash函数获得哈希值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash = x % 数组长度</span><br><span class="line">h(key) = key % D</span><br></pre></td></tr></table></figure></li><li>hash即x的键(在数组中的index)。值为x本身</li></ul><h3 id="中间平方法"><a href="#中间平方法" class="headerlink" title="中间平方法"></a>中间平方法</h3><ul><li>拿到需要hash的数，对其平方</li><li>取平方完的数中间的数字再次平方</li><li>重复多次上述操作，直到得到你想要的key。这种情况下得到的key具有极大的随机性（如果初始输入很大的话）<p align="center"><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneCS211-1.png" width="600"></p></li></ul><p>最终得到的键为7307</p><blockquote><p>负荷系数(Load Factor)<br>负荷系数是衡量哈希表的负荷情况的系数，记作λ<br>当哈希表装满时，λ = 1；当哈希表装了一半时，λ = 0.5</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">       已经填入哈希表的元素个数</span><br><span class="line">λ = ————————————————————————————</span><br><span class="line">             哈希表的大小</span><br></pre></td></tr></table></figure><h2 id="哈希碰撞"><a href="#哈希碰撞" class="headerlink" title="哈希碰撞"></a>哈希碰撞</h2><p>由于Hash函数没选好而导致value的key重叠碰撞。遇到这种情况</p><blockquote><p>实际上，最简单的观察一个hash function是否会发生碰撞的方法就是看这个函数是否是<strong>单调递增/单调递减</strong>的</p></blockquote><p>有这么几种寻找碰撞的方法：</p><h3 id="断开链表"><a href="#断开链表" class="headerlink" title="断开链表"></a>断开链表</h3><ul><li>首先，该hash使用的<strong>数据结构是链表</strong></li><li>如果出现冲突，请把另一个元素继续放进来形成一个数组链表<p align="center"><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneCS211-2.png" width="400"></p></li></ul><hr><h3 id="线性探测"><a href="#线性探测" class="headerlink" title="线性探测"></a>线性探测</h3><ul><li>hash的<strong>结构是数组</strong></li><li>当遇到碰撞时，在原本计算得到的key的基础上+1%数组大小<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(h(key) + 1) % table_size</span><br></pre></td></tr></table></figure></li><li>如果再遇到，那就在<strong>最开始得到的key上</strong>+2%数组大小</li><li>相同思想递归<h4 id="线性探测难题：删除问题"><a href="#线性探测难题：删除问题" class="headerlink" title="线性探测难题：删除问题"></a>线性探测难题：删除问题</h4><blockquote><p>当在同一个key处存在相同的碰撞，可能会导致连续的一个范围内都是这个key的线性延伸<br>此时，当我们删掉了这个线性延伸中间的一部分时，就可能会导致程序认为这个key的延伸已经没有了。请问怎么办呢？</p></blockquote></li></ul><p>正确做法是使用<strong>tombstone</strong>（墓碑，只是一个比喻）标记该单元格是空的，并且之前被占用过</p><ul><li>查找时，不要停留在墓碑前，继续寻找</li></ul><ul><li>需要小心环绕</li></ul><ul><li>当插入时，请随意替换你遇到的任何墓碑<p align="center"><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneCS211-3.png" width="400"></p></li></ul><h4 id="线性探测的优点"><a href="#线性探测的优点" class="headerlink" title="线性探测的优点"></a>线性探测的优点</h4><p>在实践中，线性探测是最快的通用哈希策略之一。</p><ul><li>低内存开销: 只需要一个数组和一个hash函数</li><li>极佳的局部性: 当冲突发生时，我们只搜索数组中相邻的位置</li><li>出色的缓存性能: 这是上述两个因素的结合<h4 id="线性探测的缺点"><a href="#线性探测的缺点" class="headerlink" title="线性探测的缺点"></a>线性探测的缺点</h4></li><li>线性探测在负载系数很高时表现出严重的性能下降</li><li>碰撞的数量趋向于随着现有碰撞的数量而增长<blockquote><p>这称为首次分簇(primary clustering)</p></blockquote></li></ul><hr><h3 id="平方探测"><a href="#平方探测" class="headerlink" title="平方探测"></a>平方探测</h3><ul><li>hash的<strong>结构是数组</strong></li><li>当遇到碰撞时，在原本计算得到的key的基础上+1<sup>2</sup>%数组大小<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(h(key) + 1^2) % table_size</span><br></pre></td></tr></table></figure></li><li>如果再遇到，那就在<strong>最开始得到的key上</strong>+2<sup>2</sup>%数组大小</li><li>相同思想递归</li><li><strong>为了保证您的平方探测最终将击中每一个可用点，表大小必须满足质数</strong></li></ul><hr><h3 id="双散列"><a href="#双散列" class="headerlink" title="双散列"></a>双散列</h3><ul><li>有<strong>两个hash函数</strong></li><li>hash的<strong>结构是数组</strong></li><li>当遇到碰撞时，在原本计算得到的key的基础上+1*h2(value)%数组大小，也就是用上了第二个函数来找另一个key</li><li>如果再遇到，那就在<strong>最开始得到的key上</strong>+2*h2(value)%数组大小</li><li>相同思想递归<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h1(key) + i * h2(key)</span><br></pre></td></tr></table></figure><p align="center"><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/damedaneCS211-4.png" width="600"></p></li></ul><h3 id="满表扩容"><a href="#满表扩容" class="headerlink" title="满表扩容"></a>满表扩容</h3><p>当负荷系数λ逐渐接近1(或者已经大于1/2)，我们就要考虑给哈希表扩容</p><ul><li>创建更大的表</li><li>扫描当前的表，移植到新的表里（使用新的hash函数）</li><li>扩容rehashing的时间复杂度为O(n)，因为一共有n个元素，每个元素hash的时间复杂度为O(1),每个元素插入的时间复杂度为O(1)，一共是O(1)*N+O(N)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ch13: 从随机数到概率</title>
      <link href="/2021/03/15/Ch13%EA%9E%89%20%E4%BB%8E%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%88%B0%E6%A6%82%E7%8E%87/"/>
      <url>/2021/03/15/Ch13%EA%9E%89%20%E4%BB%8E%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%88%B0%E6%A6%82%E7%8E%87/</url>
      
        <content type="html"><![CDATA[<h1 id="Ch13-从随机数到概率"><a href="#Ch13-从随机数到概率" class="headerlink" title="Ch13: 从随机数到概率"></a>Ch13: 从随机数到概率</h1><p>课本p365~373</p><h2 id="随机现象"><a href="#随机现象" class="headerlink" title="随机现象"></a>随机现象</h2><h3 id="定义及概念"><a href="#定义及概念" class="headerlink" title="定义及概念"></a>定义及概念</h3><blockquote><p>a random phenomenon is a situation in which we know what outcomes can possibly occur, but we don’t know which particular outcome will happen<br>比如说开车经过红绿灯，我们知道可能遇到红灯、黄灯或者绿灯，但不知道具体会遇到哪种情况，所以开车遇到红绿灯是随机现象</p></blockquote><ul><li>如果我们知道什么结果可能会发生，但我们不知道什么特定的结果会发生，我们就称这种现象是随机的<blockquote><p>In general, each occasion upon which we observe a random phenomenon is called a trial.<br>At each trial, we note the value of the random phenomenon, and call that the trial’s outcome</p></blockquote></li><li>一般来说，对随机现象的一次尝试或实现称为试验(trial)</li><li>测量、观察或报告的价值为一个单独的试验实例称为试验结果(outcome)<blockquote><p>When we combine outcomes like that, the resulting combination is an event.<br>We call the collection of all possible outcomes the sample space</p></blockquote></li><li>我们称事件是结果的集合。我们用粗体大写字母表示事件(Events)，如A、B或C</li><li>所有可能结果值的集合称为样本空间(Sample Space)。我们用黑体大写S表示样本空间(用于Venn图)</li></ul><br><h2 id="大数定律-LLN-Law-of-Large-Numbers"><a href="#大数定律-LLN-Law-of-Large-Numbers" class="headerlink" title="大数定律(LLN / Law of Large Numbers)"></a>大数定律(LLN / Law of Large Numbers)</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>当我们大量多次重复一个随机过程时，一个事件发生的次数所占的比例会逐渐降为一个数字。我们称这个数字为事件发生的概率<br>因为这个定义是基于对事件结果的反复观察，所以这个概率的定义通常被称为<strong>经验概率</strong></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>随机现象一定不能改变，每个试验的结果必须有相同的概率(比如抛硬币，正反两面的概率恒定是1/2)</li><li>事件必须独立互不影响。独立性意味着<strong>一个试验的结果不影响其他试验的结果</strong><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3>LLN保证相对频率在长期内稳定下来，我们可以为它们接近的值命名。我们称之为事件的概率。因为这个定义是建立在反复观察事件结果的基础上的，所以这个概率的定义通常被称为经验概率。对于任何事件A，经验概率的公式为：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">     一个事件在多次执行的过程中发生的次数</span><br><span class="line">——————————————————————————————————————————</span><br><span class="line">             事件执行的次数</span><br></pre></td></tr></table></figure></li></ul><br><h2 id="不存在的平均定律-The-Nonexistent-Law-of-Averages"><a href="#不存在的平均定律-The-Nonexistent-Law-of-Averages" class="headerlink" title="不存在的平均定律(The Nonexistent Law of Averages)"></a>不存在的平均定律(The Nonexistent Law of Averages)</h2><p>The so-called Law of Averages doesn’t exist at all.<br>大数定律经常被误解，因为”长期”的概念很难理解。举个简单的例子，许多人认为在许多次试验之后仍没有发生过的随机事件“应该很快就会”发生。</p><blockquote><p>许多赌徒把赌注押在一段时间没有出现的数字上，错误地认为这些数字可能会更早出现<br>另一个著名的例子是老虎机，赌徒错误的认为一台机子越久没有摇到777中奖的几率就越大</p></blockquote><p>针对这种现象与心理，一个更为常见的术语是“平均定律”。根据大数定律(LLN)，相对频率将最终确定为这种结果的概率，但是<strong>大数定律没有提到短期行为。相对频率只有在长期内才会均匀</strong>。根据LLN，长期是非常长的(实际上是无限长的)。所以<strong>所谓的平均法则根本就不存在</strong>。</p><blockquote><p>一个优秀的棒球击球手在过去六次三振出局后，下次会被击出安打吗?如果你在统计学课上的每周小测验中表现特别好，你会不会有一个糟糕的成绩?</p></blockquote><p>这不是随机现象的工作方式。短期内没有平均法则，评价定律并不存在</p><blockquote><p>答题模板</p><ul><li>平均定律并不存在</li><li>每个xx事件都是一个独立的事件</li><li>过去一小段时间的影响不会影响LLN进而影响到未来</li></ul></blockquote><br><h2 id="理论概率"><a href="#理论概率" class="headerlink" title="理论概率"></a>理论概率</h2><h3 id="公式-1"><a href="#公式-1" class="headerlink" title="公式"></a>公式</h3><p>当概率来自一个模型(如等可能的结果)而不是来自观察，它被称为理论概率。对于任何事件A，理论概率的公式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      事件A发生</span><br><span class="line">—————————————————————</span><br><span class="line">  可能发生的事件类型</span><br></pre></td></tr></table></figure><br><h2 id="其他概率"><a href="#其他概率" class="headerlink" title="其他概率"></a>其他概率</h2><h3 id="个人概率"><a href="#个人概率" class="headerlink" title="个人概率"></a>个人概率</h3><p>第三方的主观概率</p><h3 id="正式概率"><a href="#正式概率" class="headerlink" title="正式概率"></a>正式概率</h3><h4 id="Venn图"><a href="#Venn图" class="headerlink" title="Venn图"></a>Venn图</h4><ul><li>Venn图规定了一个框，整个框内代表概率为1(一次尝试的所有可能结果的集合的概率必须为1)，即P(S) = 1</li></ul><h4 id="正式概率规则"><a href="#正式概率规则" class="headerlink" title="正式概率规则"></a>正式概率规则</h4><ul><li>任意一个事件A，它发生的概率为0≤P(A)≤1</li><li>概率分配规则：一个实验(Trial)所有结果(Outcome)的概率和为P(S) = 1</li><li>补数规则：事件不发生的概率为1减去它发生的概率。不属于事件A的结果集合称为A的补数，表示为A<sup>C</sup></li><li>加法定律：两个**不相交(或互斥)**的事件A和B，他们中一个发生发生的概率为：<br>P(A or B) = P(A) + P(B)</li><li>乘法定律：两个<strong>独立</strong>事件，他们同时发生的概率为：<br>P(A and B) = P(A) * P(B)</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>小心那些加起来不等于1的概率</li><li>如果事件相交，不要用加法定律</li><li>如果事件不独立(不互斥)，就不要把它们的概率相乘</li><li>不要混淆不连贯和独立。不相交的事件不可能是独立的<blockquote><p>关于这点，举个例子：<br>如果A ={你在测验中得到A} B ={你在测验中得到B}， A和B是不相交(无法同时发生)的。他们是独立的吗?<br>如果你发现A发生了，会改变B发生的概率吗？当然了，因为B发生的概率变成0了，如果A已经发生则不可能发生B，所以它们不可能是独立的</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 统计学导论 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>进制转换与位运算</title>
      <link href="/2021/01/17/10%EF%BC%9A%E7%AC%AC%E5%8D%81%E7%AB%A0/"/>
      <url>/2021/01/17/10%EF%BC%9A%E7%AC%AC%E5%8D%81%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><p>关于进制转换，请参见<a href="@note/2%EF%BC%9A%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C.md">数字系统</a><br>请注意，这边负数都用二进码表示的</p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><blockquote><p>位运算魔法<br>.         ————神经元</p></blockquote><p>不好意思，不考</p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>递归与迭代</title>
      <link href="/2021/01/16/9%EF%BC%9A%E7%AC%AC%E4%B9%9D%E7%AB%A0/"/>
      <url>/2021/01/16/9%EF%BC%9A%E7%AC%AC%E4%B9%9D%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="Recursive和Iterative的区别"><a href="#Recursive和Iterative的区别" class="headerlink" title="Recursive和Iterative的区别"></a>Recursive和Iterative的区别</h2><h4 id="Recursive"><a href="#Recursive" class="headerlink" title="Recursive"></a>Recursive</h4><p>递归是方法调用方法本身实现的重复执行<br>Recursion is when a method calls itself</p><h4 id="Iterative"><a href="#Iterative" class="headerlink" title="Iterative"></a>Iterative</h4><p>迭代嘛…就是for或者while的循环体，虽然也是反复执行的但是是在一个方法里的<br>Iterative is a loop that be used in a method. It will run several times</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>如果没有base case，递归会无限持续下去，而循环体在达到循环的条件之后就会终止<br>The method keeps calling itself until it reached the base case  and it filters back up. Iterative will end when it out the condition of the loop</p><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>经典的递归例题，输入位置返回斐波那契数列对应位置的值<br>因为第一个和第二个的元素是固定的1，所以是有两个base case的</p><details>  <summary>代码</summary>  <markdown>public class Fbnq {    public static long fbnq(int n) {        if (n == 1) return 1;        if (n == 2) return 1;        return fbnq(n-1) + fbnq(n-2);        }    public static void main(String[] args) {        System.out.println(fbnq(5));    }}  </markdown></details><h2 id="归并排序Merge-Sort"><a href="#归并排序Merge-Sort" class="headerlink" title="归并排序Merge Sort"></a>归并排序Merge Sort</h2><p>一种递归的Sort方法，实际上Quick Sort也是一种递归的算法</p><h4 id="时间复杂度：O-nlogn"><a href="#时间复杂度：O-nlogn" class="headerlink" title="时间复杂度：O(nlogn)"></a>时间复杂度：O(nlogn)</h4><h4 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h4><ul><li>创建一个工作数组，与最终结果等长（其实就是装最终数组的</li><li>将给的数组拆成两部分，然后继续往下拆，直到拆到单独元素</li><li>开始归并，比较大小的归并啦</li><li>有比完空的（归并的两部分不等长）就直接把剩下的部分搬到尾巴<br><img src="/.com//Clipboard_2021-01-09-17-29-18.png"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2021/01/15/8%EF%BC%9A%E7%AC%AC%E5%85%AB%E7%AB%A0/"/>
      <url>/2021/01/15/8%EF%BC%9A%E7%AC%AC%E5%85%AB%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="数组和链表的优缺点"><a href="#数组和链表的优缺点" class="headerlink" title="数组和链表的优缺点"></a>数组和链表的优缺点</h2><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul><li><p>array优点：查找元素很快,数据是连续的形式储存在内存中的</p><blockquote><p>easy to search elements by using index; data elements are stored in contiguous locations in memory</p></blockquote></li><li><p>array缺点：当数组满了以后无法扩充，需要把所有元素转移到新的数组，很麻烦。没有填满的数组浪费空间</p><blockquote><p>When they get full it is not easy to extend them, we have to copy all items and move them to the new array. And also, the unfull array waste space</p></blockquote></li></ul><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><ul><li><p>linked list优点：不浪费任何空间，易于添加和删除新的元素</p><blockquote><p>Linked list doesn’t waste any space and extra links can easily be added or deleted</p></blockquote></li><li><p>linked list缺点：查找元素要从头开始…</p><blockquote><p>hard to search elements. If we want to search one element, we need to search from the head of the linked list</p></blockquote></li></ul><blockquote><p><strong>例题</strong><br>Why are linked lists better than arrays?<br>比较两个，说linked list的优势</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/2021/01/14/7%EF%BC%9A%E7%AC%AC%E4%B8%83.x%E7%AB%A0/"/>
      <url>/2021/01/14/7%EF%BC%9A%E7%AC%AC%E4%B8%83.x%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树Binary-Tree"><a href="#二叉树Binary-Tree" class="headerlink" title="二叉树Binary Tree"></a>二叉树Binary Tree</h2><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible</p><blockquote><p>完备二叉树是指除了最后一层之外的每一层都是满的，并且所有节点都在尽可能远的左边的二叉树</p></blockquote><h3 id="排序好的二叉树"><a href="#排序好的二叉树" class="headerlink" title="排序好的二叉树"></a>排序好的二叉树</h3><p>所有的父节点，都比他的子节点（不管是一个还是两个还是没有）大</p><h3 id="二叉树的节点关系"><a href="#二叉树的节点关系" class="headerlink" title="二叉树的节点关系"></a>二叉树的节点关系</h3><p>首先二叉树的第一个元素（最顶上那个）的序号是1</p><ul><li><p>一个节点的左子节点为2i</p></li><li><p>一个节点的右子节点为2i + 1</p></li><li><p>一个节点的父节点为i/2向下取整</p><h3 id="二叉树的五个特点"><a href="#二叉树的五个特点" class="headerlink" title="二叉树的五个特点"></a>二叉树的五个特点</h3><p>完全二叉树（最底下移除满了）</p></li><li><p><strong>FACT1:</strong> 一个有n个子节点的二叉树的高度至少为lgn向下取整</p><blockquote><p><strong>证明</strong><br>2^(h+1) − 1 ≥ 𝑛<br>2^(ℎ+1) ≥ 𝑛+1<br>ℎ+1 ≥ lg⁡(𝑛+1)<br>ℎ+1 ≥ ⌈lg⁡(𝑛+1)⌉    (Number of nodes is positive integer)<br>ℎ ≥ ⌈lg⁡(𝑛+1)⌉−1 = ⌊lg⁡𝑛⌋</p></blockquote></li><li><p><strong>FACT2:</strong> 一个有n个叶子节点的二叉树的高度至少为lgn向上取整</p><blockquote><p><strong>证明</strong><br>It has 𝑛 leaves<br>Suppose that the height of this tree is ℎ<br>There are at most 2^ℎ leaves<br>  2^ℎ ≥ 𝑛<br>  ℎ ≥ ⌈lg⁡𝑛⌉</p></blockquote></li><li><p><strong>FACT3:</strong> 一个高度为h的二叉树至多有2^0 + 2^1 + 2^2 + … + 2^h = 2^h+1 - 1个节点，最多有2^h个叶子节点</p><blockquote><p><strong>证明</strong><br>节点(实际上是数学归纳法)：<br>By induction on ℎ.<br>ℎ=0, so 2^0=1 leaf<br>ℎ=1, so at mose 2^1=2 leaves<br>Thus, we suppose that it holds on ℎ &lt; 𝑚<br>Then we will show that it holds on ℎ = 𝑚<br>叶子节点：<br>By induction hypothesis, we have that there are at most 2^(𝑚−1) leaves at the left subtree<br>and there are at most 2^(𝑚−1) leaves at the right subtree.<br>So, there are at most 2^(𝑚−1) + 2^(𝑚−1) = 2^𝑚  leaves at this binary tree</p></blockquote></li></ul><hr><p>接近完全的二叉树（就是最底下一层没满）</p><ul><li><strong>FACT4:</strong> 一个有n个叶子节点的二叉树的高度至少为⌈lg⁡(𝑛)⌉（或者⌈lg⁡(𝑛)⌉+1?）</li><li><strong>FACT4:</strong> 一个高度为h的二叉树有[2^h, 2^h + 1]个子节点，有[2^h-1, 2^h]个叶子节点</li><li><strong>FACT5:</strong> 第k个节点位于第⌊lg⁡k⌋层<blockquote><p><strong>证明</strong><br>也是数学归纳法，比较..直观明了</p></blockquote></li></ul><h2 id="堆排序Heap-Sort"><a href="#堆排序Heap-Sort" class="headerlink" title="堆排序Heap Sort"></a>堆排序Heap Sort</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(nlgn)</p><h3 id="heap-sort流程"><a href="#heap-sort流程" class="headerlink" title="heap sort流程"></a>heap sort流程</h3><ul><li>第一步，把数组元素装进一个二叉树中，并排序找到最大的元素(这个操作叫heapify)，也就是二叉树的头头</li><li>第二步，把二叉树的头头拿出来放到新建的数组的最后面，然后把最底下的叶子节点抓来放到头头的空位里</li><li>第三步，对新的二叉树重排序，迭代上述过程找到最大放到最后（要放最前也可以，看你想怎么排</li><li>第四步，二叉树只剩下最后一个元素了，这就是最小的元素，在数组的arr[0]</li></ul><h3 id="heapify具体操作"><a href="#heapify具体操作" class="headerlink" title="heapify具体操作"></a>heapify具体操作</h3><p>heapify即在一个父节点和它的子节点中进行排序得到排序好的二叉树的方法。<strong>是从上往下进行的</strong>。以HEAPIFY(A, 1)为例：<br>从顶点向下找第一个左父节点: </p><blockquote><p>比较左子节点与父节点，若父节点小则交换<br>比较右子节点与父节点，若父节点小则交换</p></blockquote><p>接下来，继续往上找左父节点，重复以上步骤</p><ul><li>HEAPIFY(A, n)的意思是A这个二叉树的序号为n的节点作为父节点向这个单元heapify</li><li>题目有的时候会给i = n，这个意思是以第n个节点为父节点向下所有父节点进行heapify</li><li>因为这种和2有关的操作，以及前面的定律，所以这个操作的时间复杂度为O(lgn)<blockquote><p><strong>证明</strong><br>𝑇(𝑛)≤𝑇(2/3 𝑛)+𝛩(1)<br>𝑇(𝑛)=𝑂(lg⁡𝑛)<br>Why?<br>Because there are at most 𝟐/𝟑 𝒏 nodes in the left subtree</p></blockquote></li></ul><h3 id="两种画堆的方式"><a href="#两种画堆的方式" class="headerlink" title="两种画堆的方式"></a>两种画堆的方式</h3><h4 id="时间复杂度区别："><a href="#时间复杂度区别：" class="headerlink" title="时间复杂度区别："></a>时间复杂度区别：</h4><ul><li>顶端到底端top-dowm：O(nlgn)</li><li>底端到顶端bottom-up：O(n)<h4 id="操作区别："><a href="#操作区别：" class="headerlink" title="操作区别："></a>操作区别：</h4></li><li>top-down<br>就是我们平常惯用的填法，一股脑的从上填到下、从左填到右</li></ul><p><em>请注意！！填入和heapify是同时进行的。不过这个行为好像被称作<strong>floating up</strong></em><br>填入的过程是O(n)，heapify的过程是O(lgn)，所以总的时间复杂度是O(nlgn)<br><img src="/2021/01/14/7%EF%BC%9A%E7%AC%AC%E4%B8%83/Clipboard_2021-01-09-22-50-59.png"></p><ul><li>buttom-up<br>首先按照元素个数画出二叉树的雏形，然后填入最后的几个元素到二叉树的底下</li></ul><h2 id="使用heap实现优先队列"><a href="#使用heap实现优先队列" class="headerlink" title="使用heap实现优先队列"></a>使用heap实现优先队列</h2><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(nlgn)</p><h3 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h3><ul><li><p>Maximum(A)<br>找到最大的数<br>O(1) –&gt;原因是 A[1]，就在顶端</p></li><li><p>Extract-max(A)<br>1、take the maximum (in A[1]) –&gt; O(1)找到最大<br>2、set A[1] = A[n]<br>3、Heapify （由上到下调整）A[1] ~ A[n-1] –&gt; O(lgn)</p><blockquote><p>Take the maximun and remove it.</p></blockquote></li><li><p>Insert(A,x)<br>把元素放入二叉树中，x是它的位置，S是这个元素本身，O(1)<br>Heapify（由下往上调整）把x往根节点调整 –&gt; O(lgn)</p><blockquote><p>Add a node x to the end of this tree.<br>Then “floating up”. </p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>堆栈与队列</title>
      <link href="/2021/01/13/6%EF%BC%9A%E7%AC%AC%E4%B8%83%E7%AB%A0/"/>
      <url>/2021/01/13/6%EF%BC%9A%E7%AC%AC%E4%B8%83%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>堆栈和队列都是抽象数据类型(abstract data type)</p><h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><h3 id="什么是堆栈"><a href="#什么是堆栈" class="headerlink" title="什么是堆栈?"></a>什么是堆栈?</h3><p>一个后进先出(Last-In-First-Out)的玩意，你可以理解成一叠碗。实际上一叠碗就是一个堆栈<br>In computer science, a stack is an abstract data type that serves as a collection of elements, with two main principal operations:<br>Push, which adds an element to the collection, and<br>Pop, which removes the most recently added element that was not yet removed.</p><blockquote><p>在计算机科学中，堆栈是一种抽象数据类型，它作为元素的集合，具有两个主要操作:<br>Push，将元素添加到集合中<br>Pop，它将删除最近添加的尚未删除的元素</p></blockquote><h3 id="堆栈操作"><a href="#堆栈操作" class="headerlink" title="堆栈操作"></a>堆栈操作</h3><ul><li>Pop()<br>往堆栈顶端放入一个元素</li><li>Push()<br>往堆栈顶端取出一个元素</li><li>Peek()<br>检查堆栈顶端的元素并复制它的值</li><li>MakeEmpty()<br>移除堆栈内所有元素</li><li>IsFull()<br>检查堆栈是不是满的，返回一个布尔值</li><li>IsEmpty()<br>检查堆栈是不是空的，返回一个布尔值</li></ul><h3 id="堆栈的top"><a href="#堆栈的top" class="headerlink" title="堆栈的top"></a>堆栈的top</h3><ul><li>当没有元素的时候，堆栈的top为-1</li><li>类似数组，堆栈最底下的那个槽位是0（top = 0），随着元素的加入top随之改变<p align="center"><img src="/.com//CS210-5.png" width="650"></p></li></ul><h3 id="堆栈的优缺点"><a href="#堆栈的优缺点" class="headerlink" title="堆栈的优缺点"></a>堆栈的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>空间复杂度为O(n)</li><li>每个堆栈操作的时间复杂度为O(1)<h4 id="缺点-基于array实现的stack"><a href="#缺点-基于array实现的stack" class="headerlink" title="缺点(基于array实现的stack)"></a>缺点(基于array实现的stack)</h4></li><li>堆栈的长度在开始时被定死</li><li>尝试将新元素插入已满的堆栈会导致特定于实现的异常</li></ul><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="什么是队列"><a href="#什么是队列" class="headerlink" title="什么是队列?"></a>什么是队列?</h3><p>一个先进先出(First-In-First-Out)的玩意，你可以理解成排队，这名字已经很直白了<br>In computer science, a queue is a collection of entities that are maintained in a sequence and can be modified by the addition of entities at one end of the sequence and the removal of entities from the other end of the sequence.</p><blockquote><p>在计算机科学中，队列是按序列维护的实体的集合，可以通过在序列的一端添加实体和从序列的另一端删除实体来修改。</p></blockquote><h3 id="队列操作"><a href="#队列操作" class="headerlink" title="队列操作"></a>队列操作</h3><ul><li>insert()<br>入队，在队列的rear（尾部）加上一个元素</li><li>remove()<br>出队，在队列的front（头部）取出一个元素</li><li>peek()<br>检查队列头部的元素，并复制它的值</li><li>size()<br>假设队列非空，返回队列内元素的总数</li><li>isFull()<br>检查队列是不是满的，返回一个布尔值</li><li>IsEmpty()<br>检查队列是不是空的，返回一个布尔值</li></ul><h3 id="队列的rear-尾-和front-头"><a href="#队列的rear-尾-和front-头" class="headerlink" title="队列的rear(尾)和front(头)"></a>队列的rear(尾)和front(头)</h3><ul><li><p>头和尾是相对的。一个队列有固定的长度（举个例子你是用数组实现的队列），由于队列的特性，会出现很神奇的头尾现象（缠绕现象）</p></li><li><p>当队列是空的时候，front为0，rear为-1</p></li><li><p>下面那个rear = 2是打错了，就是你想的那样</p><p align="left"><img src="/.com//CS210-6.png" width="450"><img src="/.com//CS210-7.png" width="450"></p></li><li><p>表格样队列操作视图</p><p align="center"><img src="/.com//CS210-8.png" width="450"></p></li></ul><h3 id="队列的优缺点"><a href="#队列的优缺点" class="headerlink" title="队列的优缺点"></a>队列的优缺点</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>空间复杂度为O(n)</li><li>每个队列操作的时间复杂度为O(1)<h4 id="缺点-基于array实现的queue"><a href="#缺点-基于array实现的queue" class="headerlink" title="缺点(基于array实现的queue)"></a>缺点(基于array实现的queue)</h4></li><li>队列的长度被定死</li><li>尝试将新元素插入已满的队列会导致特定于实现的异常</li></ul><h2 id="双队列"><a href="#双队列" class="headerlink" title="双队列"></a>双队列</h2><h3 id="什么是双队列-Deque"><a href="#什么是双队列-Deque" class="headerlink" title="什么是双队列(Deque)?"></a>什么是双队列(Deque)?</h3><ul><li>双队列没有front和rear的概念</li><li>A deque is a double-ended queue. This means you can insert items at either end and delete them at either end<blockquote><p>deque是一种双端队列<br>这意味着您可以在任意一端插入项，也可以在任意一端删除项</p></blockquote></li></ul><h3 id="双队列操作"><a href="#双队列操作" class="headerlink" title="双队列操作"></a>双队列操作</h3><ul><li>insertLeft()<br>从左边插入元素</li><li>insertRight()<br>从右边插入元素</li><li>removeLeft()<br>从左边移除元素</li><li>removeRight()<br>从右边移除元素<p align="left"><img src="/.com//CS210-9.png" width="450"><img src="/.com//CS210-10.png" width="450"></p></li></ul><h3 id="Deque与Stack和Queue的关系"><a href="#Deque与Stack和Queue的关系" class="headerlink" title="Deque与Stack和Queue的关系"></a>Deque与Stack和Queue的关系</h3><ul><li>Stack是只具有insertRight()和removeRight()的Deque</li><li>Queue是只具有insertRight()和removeLeft()的Deque</li></ul><h2 id="优先队列Priority-Queue"><a href="#优先队列Priority-Queue" class="headerlink" title="优先队列Priority Queue"></a>优先队列Priority Queue</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>A priority queue is a queue where items don’t just join at the rear, they are slotted into the queue according to their priority </p><blockquote><p>优先队列是指项目不是在后面连接，而是根据它们的优先级插入队列</p></blockquote><h3 id="优先队列方法"><a href="#优先队列方法" class="headerlink" title="优先队列方法"></a>优先队列方法</h3><ul><li>insert()<br>按照<strong>优先级</strong>插入元素。通常使用heap的方法插入<br>比如queue里已经有了1，3，现在要插入2，我们得到的新queue应该是1，2，3而不是1，3，2</li><li>remove()<br>删除掉当前队列优先级最高的元素</li></ul><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>插入的时间复杂度为O(n)，因为要进行优先级衡量的heap</li><li>删除的时间复杂度为O(1)</li></ul><h3 id="使用heap实现优先队列"><a href="#使用heap实现优先队列" class="headerlink" title="使用heap实现优先队列"></a>使用heap实现优先队列</h3><p><a href="@note/7%EF%BC%9A%E7%AC%AC%E4%B8%83.x%E7%AB%A0.md">第七.x章</a> </p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2021/01/12/5%EF%BC%9A%E7%AC%AC%E5%85%AD%E7%AB%A0/"/>
      <url>/2021/01/12/5%EF%BC%9A%E7%AC%AC%E5%85%AD%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>以下提及的除了heap以外都是comparison sort，基于比较的排序法</p><ul><li>Stable/Unsatble<br>A stable sorting algorithm is any sorting algorithm that preserves the relative ordering of items with equal values. <blockquote><p>一个稳定的排序算法是保持具有相等值的项的相对顺序的任何排序算法。</p></blockquote></li><li>In-palce/Out-place<br>An in-place algorithm is an algorithm which transforms input using no auxiliary data structure. <blockquote><p>就地算法是一种不使用辅助数据结构对输入进行转换的算法。</p></blockquote><h2 id="bubble-sort"><a href="#bubble-sort" class="headerlink" title="bubble sort"></a>bubble sort</h2></li><li>时间复杂度：O(n^2)<br>n*(n - 1)/2</li><li>Stable/In-place</li><li>图解冒泡排序：<p align="center"><img src="/.com//CS210-1.png" width="650"></p><details><summary>代码</summary><markdown>public class BubbleSort {  public static void bubble(int[] A){      int temp = 0;        for(int i = A.length-1;i>0;i--){//外层（冒泡循环），减去已经排序好的部分          for(int j = 0;j<i;j++){ 内层（交换循环），遍历未排序的部分 if(a[j]>A[j+1]){//执行交换，进行冒泡              temp = A[j];              A[j] = A[j+1];              A[j+1] = temp;            }          }           }        for(int k = 0;k<A.length;k++) { system.out.println(a[k]); } < markdown></A.length;k++)></i;j++){></markdown></details></li></ul><h2 id="selection-sort"><a href="#selection-sort" class="headerlink" title="selection sort"></a>selection sort</h2><p>在未排序部分找到最小的数，放到未排序的首位</p><ul><li>时间复杂度: O(n^2)<br>(n - 1) * n/2</li><li>Unsatble/In-place</li><li>图解选择排序<p align="center"><img src="/.com//CS210-2.png" width="550"></p><details><summary>代码</summary><markdown>public class SelectionSort {  public static void selectionSort(int[] array) {      int min;      int temp = 0;      for (int outer = 0; outer < array.length; outer++) {//未排序的部分          min = outer;//要检查的槽位           for (int i = outer + 1; i < array.length; i++) {//内循环，遍历未排序的部分              if (array[i] < array[min]) {                   min = i; //找到最小值              }          }           temp = array[outer];          array[outer] = array[min];          array[min] = temp;      }      for(int i = 0;i<array.length;i++) { system.out.println(array[i]); } public static void main(string[] args) int[] a="{2,1,0,3,4,5,};" selectionsort(a); < markdown></array.length;i++)></markdown></details></li></ul><h2 id="insertion-sort"><a href="#insertion-sort" class="headerlink" title="insertion sort"></a>insertion sort</h2><ul><li>时间复杂度：O(n^2)</li><li>Stable/In-place</li><li>图解插入排序：<p align="center"><img src="/.com//CS210-3.png" width="650"></p><details><summary>代码</summary><markdown>public class InsertionSort {  public static void insertionSort(int[] array) {       int temp = 0;        for (int outer = 1; outer < array.length; outer++) {        //O（n）        // outer是下一个要被sorting的元素，默认第一个已经sort好了          int inner = outer; // inner是用来判断交换的          while (inner > 0 && array[inner - 1] >= array[inner]) {     //O（n）            temp = array[inner-1];            array[inner - 1] = array[inner];            array[inner] = temp;            inner--;           }         }         for(int i = 0;i<array.length;i++) { system.out.println(array[i]); } public static void main(string[] args) int[] array="{2,1,0,5,3,7};" insertionsort(array); < markdown></array.length;i++)></markdown></details></li></ul><h2 id="quick-sort"><a href="#quick-sort" class="headerlink" title="quick sort"></a>quick sort</h2><ul><li>时间复杂度：O(n^2)</li><li>Unsatble/Out-place</li><li>图解快速排序<br>啊这，你还是看视频吧:<video width="620" height="440" controls><source src="@attachment/CS210-4.mp4" type="video/mp4"></video><details><summary>代码</summary><markdown>public static int[] qsort(int arr[],int start,int end) {        //start和end指的是要排序的部分  int pivot = arr[start];            //取第一个作为pivot  int i = start;                    //数组头  int j = end;                    //数组尾  while (i<j) { while ((i<j)&&(arr[j]>pivot)) {                          j--;                              }                  while ((i<j)&&(arr[i]<pivot)) { i++; } if ((arr[ i ]="=arr[" j ]) && (i < j)) else swap（arr[i], arr[j]）; (i-1>start) arr = qsort(arr,start,i-1);        //递归的部分if (j+1<end) arr="qsort(arr,j+1,end);" return (arr); } < markdown></end)></j)&&(arr[i]<pivot))></j)></markdown></details></li></ul><h2 id="heap-sort"><a href="#heap-sort" class="headerlink" title="heap sort"></a>heap sort</h2><ul><li>详情见<a href="@note/7%EF%BC%9A%E7%AC%AC%E4%B8%83.x%E7%AB%A0.md">第七.x章</a> </li><li>Unstable/In-place</li><li>O(lgn)</li></ul><h2 id="merge-sort"><a href="#merge-sort" class="headerlink" title="merge sort"></a>merge sort</h2><ul><li>O(nlgn)</li><li>Stable/Out-place<br>会画图已经ok了，老师说不考代码<br>关于递归实现merge的思路见<a href="@note/9%EF%BC%9A%E7%AC%AC%E4%B9%9D%E7%AB%A0.md">第九章</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线性查找与二分查找</title>
      <link href="/2021/01/10/3%EF%BC%9A%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
      <url>/2021/01/10/3%EF%BC%9A%E7%AC%AC%E5%9B%9B%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="linear-search"><a href="#linear-search" class="headerlink" title="linear search"></a>linear search</h2><h4 id="时间复杂度：O-n"><a href="#时间复杂度：O-n" class="headerlink" title="时间复杂度：O(n)"></a>时间复杂度：O(n)</h4><details>  <summary>代码</summary>  <markdown>public calss LinearSearch{  public static int linear(int[] array,int value){    for(int i = 0;i<array.length,i++){ if(array[i]="value){" return i; } < markdown></array.length,i++){></markdown></details><hr><h2 id="binary-search"><a href="#binary-search" class="headerlink" title="binary search"></a>binary search</h2><h4 id="时间复杂度：O-logn-，这里的对数是以2为底的"><a href="#时间复杂度：O-logn-，这里的对数是以2为底的" class="headerlink" title="时间复杂度：O(logn)，这里的对数是以2为底的"></a>时间复杂度：O(logn)，这里的对数是以2为底的</h4><details>  <summary>代码</summary>  <markdown>public class BinaryTest{    public static int binary(int[] array, int value)    {        int low = 0;//数组的头啦        int high = array.length - 1;//数组的尾巴        while(low <= high) 底下没有用递归是因为用了while啊233.如果这里用的是if判别的话就要递归了。这么写的好处是可以在方法内定义low和high { int middle="(low" + 2; 头和尾巴中间的部分，就是最中间的那个元素 if(value="=" array[middle]) return middle; 你小子运气真好 }> array[middle])            {                low = middle + 1;//值在右边，将底边界移动到middle左边            }            if(value < array[middle])            {                high = middle - 1;//值在左边，将顶边界移动到middle右边            }        }        return -1;//找不到    }  </=></markdown></details>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自增与自减</title>
      <link href="/2021/01/09/2%EF%BC%9A%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
      <url>/2021/01/09/2%EF%BC%9A%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="自增"><a href="#自增" class="headerlink" title="自增"></a>自增</h2><ul><li>i++<br>执行完这次算法后，i自增</li><li>++i<br>执行这次算法的时候i就自增了<details><summary>代码</summary><markdown>> public static void main (String[] args){      int x = 5;      int y = 5;      x = x++;      y = ++y;      System.out.println("x = "+ x);      System.out.println("y = "+ y);  }**Answer:** *x = 5,y = 6*</markdown></details></li></ul><h2 id="自减"><a href="#自减" class="headerlink" title="自减"></a>自减</h2><ul><li>i–<br>执行完这次算法后，i自减</li><li>–i<br>执行这次算法的时候i就自减了<details><summary>代码</summary><markdown>> public static void main (String[] args){      int x = 5;      int y = 5;      x = x--;      y = --y;      System.out.println("x = "+ x);      System.out.println("y = "+ y);  }</markdown></details></li></ul><p><strong>Answer:</strong> <em>x = 5,y = 4</em><br>  <br>  </p><h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><p>  public static void main(String[] args){<br>    int a = 100;<br>    int b = 0;<br>    int c = 0;<br>    int d = 100;<br>    for(int i = 0;i&lt;100;i++){<br>      a = a++;<br>      d = ++d;<br>      c = c++;<br>      d = c++;<br>    }<br>  }<br>这样a是不变的，因为a = a，然后结束整个步骤之后a才会自增1<br>而d会自增，因为在执行的时候自增1<br>c和d会自增，但是d比c少一。因为d的缘故，c才得以增加（否则会和a一样</p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法与数据结构</title>
      <link href="/2021/01/08/1%EF%BC%9A%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>/2021/01/08/1%EF%BC%9A%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是算法"><a href="#什么是算法" class="headerlink" title="什么是算法"></a>什么是算法</h2><p>A data structure is a conceptual structure for organizing information </p><blockquote><p>数据结构是用于组织信息的概念结构</p></blockquote><h2 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h2><p>An algorithm is a precise step-by-step plan for solving a problem using a finite sequence of instructions</p><blockquote><p>算法是用有限的指令序列来解决问题的精确的分步计划</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
