---
title: 排序算法之选泡插
tags: ['算法与数据结构','算法','计算机科学技术','面试相关']
categories: 算法与数据结构
date: '2024-03-02 12:40:59'
copyright_author: 时光
cover: https://img13.360buyimg.com/ddimg/jfs/t1/238481/34/4684/97117/65e98056F9aa63fbd/675a286453df0bac.jpg
---

{% note info simple %}

通俗易懂了解算法方面我强烈推荐油管主 Michael Sambol 的“x分钟了解xx算法”系列视频！非常直观

{% endnote %}

在不同领域，排序算法的实现各有千秋。总体来看，排序算法大致可分为十类：

- {% label 选泡插 red %}：选择排序/Selection Sort、冒泡排序/Bubble Sort、插入排序/Insertion Sort
- {% label 快归希堆 green %}：快速排序/Quick Sort、归并排序/Merge Sort、希尔排序/Shell Sort、堆排序/Heap Sort
- {% label 桶计基 blue %}：桶排序/Bucket sort、计数排序/Counting Sort、基数排序/Radix Sort

<!--more-->

在排序算法中，按照其特性，还有以下两种分类方式：

- **稳定stable/不稳定unstable**
A stable sorting algorithm is any sorting algorithm that preserves the relative ordering of items with equal values. 
> 一个稳定的排序算法是**保持具有相等值的项**的**相对顺序**的任何排序算法。通俗的说就是：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i] = r[j]，且 r[i] 在 r[j] 之前，而在排序后的序列中，r[i] 仍在 r[j] 之前，则称这种排序算法是稳定的；否则称为不稳定的。

- **就地in-place/不就地out-place**
An in-place algorithm is an algorithm which transforms input using no auxiliary data structure. 
> 就地算法是一种**不使用辅助数据结构**对输入进行转换的算法。

按照被排序的数据元素的存储位置，还分为以下两种：
- **内排序**
内排序是被排序的数据元素全部**存放在计算机内存中**的排序算法，也称为内部排序。
- **外排序**
若待排序记录的数量庞大，在排序的过程中需要使用到**外部存储介质**如磁盘等，这种涉及内外存储器数据交换的排序过程称为外排序，又称为外部排序。如：归并排序、拓扑排序。

# 时间复杂度为O(n^2)的排序算法
## 冒泡排序/bubble sort
- Stable/In-place
- 最优时间复杂度：O(n)，即已经排序好的情况下
- 最差时间复杂度：O(n^2)，即完全没排序的情况，或原始算法
- 空间复杂度：O(1)
<img src="https://img11.360buyimg.com/ddimg/jfs/t1/158015/1/42815/50715/65e2d284Fdf45dfbe/89a05babfa393505.jpg" width=500 title="图解冒泡排序" />

{% video CS210-1.mp4 %}
<br/>

{% tabs 冒泡排序的写法 %}
<!-- tab 一般来说的写法 -->
根据上面的视频，我们不难写出：
```Java
public static int[] bubbleSort(int[] arr){
    for(int i = arr.length - 1; i > 0; i--){      // 每次比较的上限
        for(int j = 0; j < arr.length - i; j++){  // 范围内进行两两比较
            if(arr[j] > arr[j + 1]){
                // 如果比后面的元素大，则交换.这里的交换是伪代码
                swap(arr[j], arr[j + 1])；
            } 
        }
    }
    return A;
}
```
改写一下for循环，使其统一为++的形式，则有：
```Java
public static void bubbleSort(int[] arr) {
    for (int i = 0; i < arr.length - 1; i++) {
        for (int j = 0; j < arr.length - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                // 如果左边的数大于右边的数，则交换，保证右边的数字最大
                swap(arr, j, j + 1);
            }
        }
    }
}
```
<!-- endtab -->

<!-- tab 经过优化的写法(交换确认) -->
使用一个变量**swaped**记录当前轮次的比较是否发生过交换，如果没有发生交换表示已经有序，不再继续排序。
```Java
public static void bubbleSort(int[] arr) {
    boolean swaped;
    for (int i = 0; i < arr.length - 1; i++) {
        swaped = false;
        for (int j = 0; j < arr.length - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                // 如果左边的数大于右边的数，则交换，保证右边的数字最大
                swaped = true;
                swap(arr, j, j + 1);
            }
        }
        // 如果这一轮遍历都没有发生过交换，直接退出循环
        if (!swapped) break;
    }
}
```
<!-- endtab -->

<!-- tab 更进一步优化的写法 -->
在前一种排序方法的基础上，我们还可以更进一步优化算法，即在下一轮比较时，只需比较到上一轮比较中，**最后一次发生交换的位置**即可。因为后面的所有元素都没有发生过交换，必然已经有序了。
当一轮比较中从头到尾都没有发生过交换，则表示整个列表已经有序，排序完成。
因此我们需要引入两个变量：**swaped** 和 **lastSwapIndex**。

```Java
public static void bubbleSort(int[] arr) {
    boolean swaped = true;
    // 最后一个没有经过排序的元素的下标
    int indexOfLastUnsortedElement = arr.length - 1;
    // 上次发生交换的位置
    int swappedIndex = -1;
    while (swapped) {
        swapped = false;
        for (int i = 0; i < indexOfLastUnsortedElement; i++) {
            if (arr[i] > arr[i + 1]) {
                // 如果左边的数大于右边的数，则交换，保证右边的数字最大
                swap(arr, i, i + 1);
                // 表示发生了交换
                swapped = true;
                // 更新交换的位置
                swappedIndex = i;
            }
        }
        // 最后一个没有经过排序的元素的下标就是最后一次发生交换的位置
        indexOfLastUnsortedElement = swappedIndex;
    }
}
```
<!-- endtab -->
{% endtabs %}


### 更高效的交换算法
{% tabs 冒泡排序的写法 %}
<!-- tab 初学者写法 -->
在前面的代码中，我并没有写出交换方法 **swap** 的具体实现。作为初学者，很容易写出以下方法：
```Java
public static void swap(int[] arr, int a, int b){
    int temp = arr[a];
    arr[a] = arr[b];
    arr[b] = temp;
}
```
<!-- endtab -->

<!-- tab 位运算魔法 -->
创建新变量temp无疑增大了空间复杂度，有没有不引入新变量又安全的方法呢？隆重推出：**位运算魔法**！
```Java
public static void swap(int[] arr, int a, int b){
    arr[a] = arr[a] ^ arr[b];
    arr[b] = arr[b] ^ arr[a];
    arr[a] = arr[a] ^ arr[b];
}
```
两个相同的值相与的时候，返回1；此时与任何元素相与都会得到元素本身。这种写法不会出现越界问题，较于数学方法更安全。
<!-- endtab -->

<!-- tab 数学方法 -->
```Java
public static void swap(int[] arr, int a, int b){
    arr[a] = arr[a] + arr[b];
    arr[b] = arr[a] - arr[b];
    arr[a] = arr[a] - arr[b];
}
```
<!-- endtab -->
{% endtabs %}

## 选择排序/selection sort
在未排序部分找到最小的数，放到未排序的首位
- Unsatble/In-place
- 时间复杂度：O(n^2)
- 空间复杂度：O(1)

<img src="https://img14.360buyimg.com/ddimg/jfs/t1/230674/34/14634/49156/65e2d43aF55757290/ecad4d4afdca897f.jpg" width=500 title="图解选择排序" />

{% video CS210-2.mp4 %}

<br>

选择排序中，最小值和首位交换的过程可能会破坏稳定性。比如数列：[2, 2, 1]，在选择排序中第一次进行交换时，原数列中的两个 2 的相对顺序就被改变了，因此，我们说选择排序是不稳定的。
算法稳定性的意义在于：当要排序的内容是一个对象的多个属性，且其原本的**顺序存在意义**时，如果我们需要在二次排序后**保持原有排序的意义**，就需要使用到稳定性的算法。

> **选择排序算法如何实现稳定排序呢？**
实现的方式有很多种，这里给出一种最简单的思路：新开一个数组，将每轮找出的最小值依次添加到新数组中，选择排序算法就变成稳定的了。
但如果将寻找最小值的比较条件由arr[minIndex] > arr[j]修改为arr[minIndex] >= arr[j]，即使新开一个数组，选择排序算法依旧是不稳定的。所以分析算法的稳定性时，需要结合具体的实现逻辑才能得出结论，我们通常所说的算法稳定性是基于一般实现而言的。

{% tabs 选择排序的写法 %}
<!-- tab 一般来说的写法 -->

这种写法也被称作“简单选择排序”。关键字比较的次数与记录的初始排列无关。

```Java
public static void selectionSort(int[] array) {
    int min;
    for (int outer = 0; outer < array.length; outer++) {//未排序的部分
        min = outer;//要检查的槽位 
        for (int i = outer + 1; i < array.length; i++) {//内循环，遍历未排序的部分
            if (array[i] < array[min]) { 
                min = i; //找到最小值
            }
        } 
        // 将最小元素交换至首位
        swap(outer, min);
    }
}
```
<!-- endtab -->

<!-- tab 经过优化的写法(二元选择) -->
选择排序算法也是可以优化的，既然每轮遍历时找出了**最小值**，何不把**最大值**也顺便找出来呢？这就是二元选择排序的思想。
使用二元选择排序，每轮选择时记录最小值和最大值，可以把数组需要遍历的范围**缩小一倍**。其思想是减少一半的外圈遍历，在内圈遍历时同时交换首位/最小值与末位/最大值，然后缩短遍历范围。当minIndex与maxIndex相碰的时候，说明遍历完成，可以跳出循环。
虽然如此，由于存在两个for循环，这种思想下的选择排序的时间复杂度依然是**O(n^2)**。
```Java
public static void selectionSort2(int[] arr) {
    int minIndex, maxIndex;
    // i 只需要遍历一半
    for (int i = 0; i < arr.length / 2; i++) {
        minIndex = i;
        maxIndex = i;
        for (int j = i + 1; j < arr.length - i; j++) {
            if (arr[minIndex] > arr[j]) {
                // 记录最小值的下标
                minIndex = j;
            }
            if (arr[maxIndex] < arr[j]) {
                // 记录最大值的下标
                maxIndex = j;
            }
        }
        // 如果 minIndex 和 maxIndex 都相等，那么他们必定都等于 i，且后面的所有数字都与 arr[i] 相等，此时已经排序完成
        if (minIndex == maxIndex) break;

        // 将最小元素交换至首位
        swap(i, minIndex);

        // 如果最大值的下标刚好是 i，由于 arr[i] 和 arr[minIndex] 已经交换了，所以这里要更新 maxIndex 的值。
        if (maxIndex == i) maxIndex = minIndex;

        // 将最大元素交换至末尾
        int lastIndex = arr.length - 1 - i;
        swap(lastIndex, maxIndex);                                                 
    }
}
```
<!-- endtab -->
{% endtabs %}


## 插入排序/insertion sort
遍历数组，插入合适的位置
- Statble/In-place
- 时间复杂度：O(n^2)
- 空间复杂度：O(1)

<img src="https://img14.360buyimg.com/ddimg/jfs/t1/182518/29/36021/31240/65e2d459F2dc463b5/57b367697ae574f0.jpg" width=500 title="图解插入排序" />

插入排序有两种写法（**交换法**/**移动法**），以下是移动法的示意视频：
{% video CS210-3.mp4 %}

<br/>

{% tabs 插入排序的写法 %}
<!-- tab 交换法 -->
在新数字插入过程中，不断与前面的数字交换，直到找到自己合适的位置。
```Java
public static void insertionSort(int[] arr) { 
    for (int i = 1; i < arr.length; i++) {
        for (int j = i; j >= 0; j--) {
            if (arr[i] < arr[j]) {
                swap(arr, i, j);
            }
        }
    }
} 
```
上面for嵌套for的写法，也可以改成for嵌套while（好处是可以提前跳出while，不用走完一遍循环）：
```Java
public static void insertSort(int[] arr) {
    for (int i = 1; i < arr.length; i++) {
        int j = i;
        while (j >= 1 && arr[j] < arr[j - 1]) {
            swap(arr, j, j - 1);
            j--;
        }
    }
}

```
<!-- endtab -->

<!-- tab 移动法 -->
在新数字插入过程中，与前面的数字不断比较，前面的数字不断向后挪出位置，当新数字找到自己的位置后，插入一次即可。
这好比打牌的时候，我们摸到了一张新的牌，要把它插入现有手牌的合适位置中。
```Java
public static void insertSortMove(int[] arr) {
    for (int i = 1; i < array.length; i++){
        int temp = array[i];
        int j = i - 1;
        while(j >= 0 && temp < array[j]){   // 越界检测在前，因为这里j是-1的话实际上array[j]会返回报错
            array[j + 1] = array[j];
            j--;
        }
        array[j + 1] = temp;
    }
    return array;
}
```
<!-- endtab -->
{% endtabs %}

| 复习周期 |   1d   |   2d   |   7d   |   21d  |
|  :----: | :----: | :----: | :----: | :----: |
|  /      |        |        |        |        |