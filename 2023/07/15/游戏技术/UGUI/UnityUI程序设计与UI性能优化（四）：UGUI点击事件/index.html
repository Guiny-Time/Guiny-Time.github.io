<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>UnityUI程序设计与UI性能优化（四）：UGUI的点击事件 | 几/何/冰/川</title><meta name="author" content="时光"><meta name="copyright" content="时光"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在 Unity 的 UI 系统中，Button 是最常见的可交互组件之一（除此之外还有 Slider、Toggle、Input Field、Scroll Bar、Drop Down），其点击事件不仅是开发者构建用户交互的基础，更是一个复杂而精巧的功能模块。本文将从 UGUI 的源码层面出发，全面剖析 Button 点击事件的实现原理，理解其设计思路与内部逻辑。  按钮点击的触发流程相信每个介绍">
<meta property="og:type" content="article">
<meta property="og:title" content="UnityUI程序设计与UI性能优化（四）：UGUI的点击事件">
<meta property="og:url" content="https://cattyhouse-guiny.xyz/2023/07/15/%E6%B8%B8%E6%88%8F%E6%8A%80%E6%9C%AF/UGUI/UnityUI%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8EUI%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AUGUI%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6/index.html">
<meta property="og:site_name" content="几&#x2F;何&#x2F;冰&#x2F;川">
<meta property="og:description" content="在 Unity 的 UI 系统中，Button 是最常见的可交互组件之一（除此之外还有 Slider、Toggle、Input Field、Scroll Bar、Drop Down），其点击事件不仅是开发者构建用户交互的基础，更是一个复杂而精巧的功能模块。本文将从 UGUI 的源码层面出发，全面剖析 Button 点击事件的实现原理，理解其设计思路与内部逻辑。  按钮点击的触发流程相信每个介绍">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VAa198651e59fd8df47130a8f8b489dbc5.png">
<meta property="article:published_time" content="2023-07-15T08:41:18.000Z">
<meta property="article:modified_time" content="2025-01-06T15:43:39.512Z">
<meta property="article:author" content="时光">
<meta property="article:tag" content="Unity">
<meta property="article:tag" content="UI">
<meta property="article:tag" content="UGUI">
<meta property="article:tag" content="源码">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VAa198651e59fd8df47130a8f8b489dbc5.png"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://cattyhouse-guiny.xyz/2023/07/15/%E6%B8%B8%E6%88%8F%E6%8A%80%E6%9C%AF/UGUI/UnityUI%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8EUI%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AUGUI%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 时光","link":"链接: ","source":"来源: 几/何/冰/川","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'UnityUI程序设计与UI性能优化（四）：UGUI的点击事件',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-01-06 23:43:39'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mycss.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><canvas id="universe" ></canvas><link rel="stylesheet" href="/css/fish.css"><link rel="stylesheet" href="/css/wave.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/CodeByZach/pace/themes/green/pace-theme-flash.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.css"/><!-- hexo injector head_end start --><script> let HEXO_MMEDIA_DATA = { js: [], css: [], aplayerData: [], metingData: [], artPlayerData: [], dplayerData: []}; </script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/CodeByZach/pace/themes/blue/pace-theme-fill-left.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">68</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">122</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-hubspot"></i><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/cats/time/"><i class="fa-fw far fa-hourglass"></i><span> Time</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fab fa-connectdevelop"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 内容</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/next/"><i class="fa-fw fas fa-feather"></i><span> 笔记</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-hamburger"></i><span> 图片</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VAa198651e59fd8df47130a8f8b489dbc5.png')"><nav id="nav"><span id="blog-info"><a href="/" title="几/何/冰/川"><span class="site-name">几/何/冰/川</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-hubspot"></i><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/cats/time/"><i class="fa-fw far fa-hourglass"></i><span> Time</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fab fa-connectdevelop"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 内容</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/next/"><i class="fa-fw fas fa-feather"></i><span> 笔记</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-hamburger"></i><span> 图片</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">UnityUI程序设计与UI性能优化（四）：UGUI的点击事件<a class="post-edit-link" href="https://github.com/Guiny-Time/Guiny-Time.github.io/edit/source/source/_posts/游戏技术/UGUI/UnityUI程序设计与UI性能优化（四）：UGUI点击事件.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-15T08:41:18.000Z" title="发表于 2023-07-15 16:41:18">2023-07-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-06T15:43:39.512Z" title="更新于 2025-01-06 23:43:39">2025-01-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%95%E6%93%8E%E5%8A%9F%E8%83%BD/">引擎功能</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>26分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="UnityUI程序设计与UI性能优化（四）：UGUI的点击事件"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA6b6935c66455dcdd22208dca3f17bef8.png"></p>
<p>在 Unity 的 UI 系统中，Button 是最常见的<strong>可交互组件</strong>之一（除此之外还有 Slider、Toggle、Input Field、Scroll Bar、Drop Down），其点击事件不仅是开发者构建用户交互的基础，更是一个复杂而精巧的功能模块。本文将从 UGUI 的源码层面出发，全面剖析 Button 点击事件的实现原理，理解其设计思路与内部逻辑。</p>
<p><img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA3184b2a76d5f8e46a76d47ea3f1462be.png" alt="初始创建的Button(TMP)" width="300/"></p>
<h1 id="按钮点击的触发流程"><a href="#按钮点击的触发流程" class="headerlink" title="按钮点击的触发流程"></a>按钮点击的触发流程</h1><p>相信每个介绍 UGUI 的新手视频都会讲到 Button 的点击事件。在 Unity 中，如果我们想为一个按钮添加事件有<strong>两种实现方式</strong>，一种是直接在检查器上为该按钮绑定事件:</p>
<p><img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA1759456b91beba83619ddd34f6534b3d.png" alt="Button组件上的OnClick" width="352"></p>
<p>另一种是通过代码为按钮的 <code>onClick</code> 加上方法监听:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GetComponent&lt;Button&gt;().onClick.AddListener(() =&gt; &#123; </span><br><span class="line">    ...<span class="comment">//按钮点击的处理逻辑</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这两者是等价的。让我们沿着 <strong>onClick</strong> 的调用链一步一步看看是怎么回事吧。</p>
<h2 id="Button：Press-gt-OnPointerClick"><a href="#Button：Press-gt-OnPointerClick" class="headerlink" title="Button：Press -&gt; OnPointerClick"></a>Button：Press -&gt; OnPointerClick</h2><p>我们来看看 Button 的源码吧！在 UGUI 的源码中，Button 是一个继承自 <strong>Selectable</strong> 的类。Selectable 提供了 UI 组件的基础<strong>选择功能</strong>，如焦点状态、交互状态等。Button 在 Selectable 的基础上扩展了点击事件处理能力（<code>onClick</code> 方法）。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.EventSystems;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Serialization;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">UnityEngine.UI</span> &#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 当点击时发送事件的标准按钮</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    [<span class="meta">AddComponentMenu(<span class="string">&quot;UI/Button&quot;</span>, 30)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Button</span> : <span class="title">Selectable</span>, <span class="title">IPointerClickHandler</span>, <span class="title">ISubmitHandler</span> &#123;</span><br><span class="line">        [<span class="meta">Serializable</span>]</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 按钮点击事件</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ButtonClickedEvent</span> : <span class="title">UnityEvent</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 点击时触发的事件委托</span></span><br><span class="line">        [<span class="meta">FormerlySerializedAs(<span class="string">&quot;onClick&quot;</span>)</span>]</span><br><span class="line">        [<span class="meta">SerializeField</span>]</span><br><span class="line">        <span class="keyword">private</span> ButtonClickedEvent m_OnClick = <span class="keyword">new</span> ButtonClickedEvent();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">Button</span>()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 也就是我们前文中提到的 onClick</span></span><br><span class="line">        <span class="keyword">public</span> ButtonClickedEvent onClick &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_OnClick; &#125;</span><br><span class="line">            <span class="keyword">set</span> &#123; m_OnClick = <span class="keyword">value</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果按钮处于活跃状态并且可交互(Interactable设置为true)，则触发事件</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Press</span>()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!IsActive() || !IsInteractable())</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            UISystemProfilerApi.AddMarker(<span class="string">&quot;Button.onClick&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 执行onClick委托上的方法</span></span><br><span class="line">            m_OnClick.Invoke();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 鼠标点击按钮时调用该函数，继承自 IPointerClickHandler 接口</span></span><br><span class="line">        <span class="comment">// 此操作需要确保您的场景有一个**事件系统**（EventSystem）</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnPointerClick</span>(<span class="params">PointerEventData eventData</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (eventData.button != PointerEventData.InputButton.Left)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// 触发点击</span></span><br><span class="line">            Press();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 按钮提交时调用该函数，继承自 ISubmitHandler 接口</span></span><br><span class="line">        <span class="comment">// &quot;提交&quot;键可以在 Edit-&gt;Project Settings-&gt;Input-&gt;Submit 中自定义</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnSubmit</span>(<span class="params">BaseEventData eventData</span>)</span> &#123;</span><br><span class="line">            Press();</span><br><span class="line">            <span class="comment">// 如果点击过程中被设置为禁用，就不要运行该协程</span></span><br><span class="line">            <span class="keyword">if</span> (!IsActive() || !IsInteractable())</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            DoStateTransition(SelectionState.Pressed, <span class="literal">false</span>);</span><br><span class="line">            StartCoroutine(OnFinishSubmit());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">OnFinishSubmit</span>()</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> fadeTime = colors.fadeDuration;</span><br><span class="line">            <span class="keyword">var</span> elapsedTime = <span class="number">0f</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (elapsedTime &lt; fadeTime) &#123;</span><br><span class="line">                elapsedTime += Time.unscaledDeltaTime;</span><br><span class="line">                <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 状态转换，包括动画/颜色切换等</span></span><br><span class="line">            DoStateTransition(currentSelectionState, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现，鼠标点击时最终调用的是 <code>Press</code> 方法，里面执行了 <strong>onClick 委托链</strong>上挂载的方法。<code>Press</code> 被包裹进 <code>OnPointerClick</code> 方法里，而这个 <code>OnPointerClick</code> 是 <code>IPointerClickHandler</code> 接口下的方法实现（这个接口也仅包括该方法）：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IPointerClickHandler</span> : <span class="title">IEventSystemHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 使用此回调检测点击事件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnPointerClick</span>(<span class="params">PointerEventData eventData</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ExecuteEvents：Execute-gt-s-PointerClickHandler-gt-pointerClickHandler"><a href="#ExecuteEvents：Execute-gt-s-PointerClickHandler-gt-pointerClickHandler" class="headerlink" title="ExecuteEvents：Execute -&gt; s_PointerClickHandler -&gt; pointerClickHandler"></a>ExecuteEvents：Execute -&gt; s_PointerClickHandler -&gt; pointerClickHandler</h2><p>查找 <code>OnPointerClick</code> 的调用链，我们会发现该方法是由 <strong>ExecuteEvents</strong> 类下的 <code>Execute</code> 方法调用的。<strong>ExecuteEvents 类</strong>相当于<strong>事件执行器</strong>，提供了许多通用的事件处理方法，针对按钮点击类型的 <code>Execute</code> 只是其中的一种<strong>重载</strong>。<code>Execute</code> 方法被赋值给 <strong>s_PointerClickHandler</strong> 字段，该字段由 <code>pointerClickHandler</code> 方法封装提供。</p>
<p><img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA80ee9af3d47796a41509459b385813cd.png" alt="OnPointerClick的调用"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Execute方法赋值给s_PointerClickHandler字段</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> EventFunction&lt;IPointerClickHandler&gt; s_PointerClickHandler = Execute;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">IPointerClickHandler handler, BaseEventData eventData</span>)</span> &#123;</span><br><span class="line">    handler.OnPointerClick(ValidateEventData&lt;PointerEventData&gt;(eventData));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> EventFunction&lt;IPointerClickHandler&gt; pointerClickHandler &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; <span class="keyword">return</span> s_PointerClickHandler; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BaseInput：ReleaseMouse-Execute-gt-ProcessMousePress-gt-ProcessMouseEvent-gt-Process"><a href="#BaseInput：ReleaseMouse-Execute-gt-ProcessMousePress-gt-ProcessMouseEvent-gt-Process" class="headerlink" title="BaseInput：ReleaseMouse(Execute) -&gt; ProcessMousePress -&gt; ProcessMouseEvent -&gt; Process"></a>BaseInput：ReleaseMouse(Execute) -&gt; ProcessMousePress -&gt; ProcessMouseEvent -&gt; Process</h2><p>沿着调用链继续往上，我们会找到两个脚本： <strong>TouchInputModule</strong> 和 <strong>StandaloneInputModule</strong>。这两个类都继承自 <strong>BaseInput</strong>，主要作用是<strong>输入处理</strong>：</p>
<ul>
<li><strong>TouchInputModule</strong>：专为触摸屏设备（如：手机）设计，主要用于处理移动设备上的触摸输入，它支持单点触摸、多点触摸等功能。不支持鼠标和键盘</li>
<li><strong>StandaloneInputModule</strong> 是一个通用的输入模块，能够支持多种输入方式，包括鼠标、键盘和触摸屏输入。</li>
</ul>
<p>假设我们的项目是一个电脑游戏，那么我们就会用鼠标去点击这个 Button，也就对应了 <strong>StandaloneInputModule</strong> 中的下面两个方法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算和处理任何鼠标按钮状态的变化</span></span><br><span class="line"><span class="comment">// Process函数间接对其进行调用（调用链过长，不一一展示)</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">ProcessMousePress</span>(<span class="params">MouseButtonEventData data</span>)</span> &#123;</span><br><span class="line">    ...<span class="comment">// 省略部分代码</span></span><br><span class="line">    <span class="keyword">var</span> pointerEvent = data.buttonData;</span><br><span class="line">    <span class="keyword">var</span> currentOverGo = pointerEvent.pointerCurrentRaycast.gameObject;</span><br><span class="line">    <span class="comment">// 鼠标按键抬起时调用（按键包括鼠标左键、中间滑轮和右键）</span></span><br><span class="line">    <span class="keyword">if</span> (data.ReleasedThisFrame()) &#123;</span><br><span class="line">        ReleaseMouse(pointerEvent, currentOverGo);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 满足松开鼠标的条件时调用</span></span><br><span class="line"><span class="comment">// currentOverGo ：当前选中的游戏物体</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ReleaseMouse</span>(<span class="params">PointerEventData pointerEvent, GameObject currentOverGo</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// pointUp事件</span></span><br><span class="line">    ExecuteEvents.Execute(pointerEvent.pointerPress, pointerEvent, ExecuteEvents.pointerUpHandler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> pointerClickHandler = ExecuteEvents.GetEventHandler&lt;IPointerClickHandler&gt;(currentOverGo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pointerEvent.pointerPress == pointerUpHandler &amp;&amp; pointerEvent.eligibleForClick) &#123;</span><br><span class="line">        <span class="comment">// pointClick事件，传入ExecuteEvents.pointerClickHandler委托</span></span><br><span class="line">        ExecuteEvents.Execute(pointerEvent.pointerPress, pointerEvent, ExecuteEvents.pointerClickHandler);</span><br><span class="line">    &#125;  </span><br><span class="line">    ...<span class="comment">// 省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>追寻 <code>ProcessMousePress</code> 方法的调用链，最后来到了输入模块的 <code>Process</code> 方法这里。该方法在 <strong>EventSystem</strong> 的 <code>Update</code> 里逐帧检查事件是否被触发。<code>Process</code> 方法会处理鼠标的按下、抬起等事件，当鼠标抬起时调用 <code>ReleaseMouse</code> 方法，并最终调用 <code>Execute</code> 方法并触发 <strong>IPointerClick</strong> 事件。</p>
<p>所以兜兜转转一圈，居然又回到了 <strong>ExecuteEvents</strong> 的 <code>Execute</code> 方法上。不过这里调用的 <code>Execute</code> 和前面出现的并不相同，而是：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// **target**：需要执行事件的游戏对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">Execute</span>&lt;<span class="title">T</span>&gt;(<span class="params">GameObject target, BaseEventData eventData, EventFunction&lt;T&gt; functor</span>) <span class="keyword">where</span> T : IEventSystemHandler</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> internalHandlers = ListPool&lt;IEventSystemHandler&gt;.Get();</span><br><span class="line">    <span class="comment">// 获取target对象的事件</span></span><br><span class="line">    GetEventList&lt;T&gt;(target, internalHandlers);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> internalHandlersCount = internalHandlers.Count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; internalHandlersCount; i++) &#123;</span><br><span class="line">        T arg;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            arg = (T)internalHandlers[i];</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">var</span> temp = internalHandlers[i];</span><br><span class="line">            Debug.LogException(<span class="keyword">new</span> Exception(<span class="built_in">string</span>.Format(<span class="string">&quot;Type &#123;0&#125; expected &#123;1&#125; received.&quot;</span>, <span class="keyword">typeof</span>(T).Name, temp.GetType().Name), e));</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行EventFunction&lt;T&gt;委托,例如pointerClickHandler(arg,eventData)</span></span><br><span class="line">            functor(arg, eventData);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Debug.LogException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> handlerCount = internalHandlers.Count;</span><br><span class="line">    ListPool&lt;IEventSystemHandler&gt;.Release(internalHandlers);</span><br><span class="line">    <span class="keyword">return</span> handlerCount &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="UGUI的事件系统"><a href="#UGUI的事件系统" class="headerlink" title="UGUI的事件系统"></a>UGUI的事件系统</h1><p>在刚才梳理 Button 点击响应的过程中，我们看到了不少新概念，相信大家也产生了一些疑问，比如：最终调用的 <code>Execute</code> 方法的 <strong>target</strong> 参数是如何通过 <strong>EventData</strong> 拿到对应 UI 元素的值的？在更深入理解 Button 的点击事件之前，我们需要先简单了解一下 UGUI 的<strong>事件系统</strong>。以下是事件系统的文件目录：</p>
<p><img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA0411c3886a4b627ce147669890c074c4.png"></p>
<p>UGUI 的事件系统是一个模块化的、基于事件驱动的交互框架，从目录结构中可以看到，<strong>EventSystem</strong> 的核心由以下几部分组成：</p>
<ol>
<li><strong>EventSystem</strong>：事件分发中心，负责<strong>管理</strong>用户输入与事件分发，一个场景只能包含一个 EventSystem。它主要包含以下功能：<ul>
<li>管理哪个游戏对象被认为是选中的</li>
<li>管理正在使用的输入模块</li>
<li>管理射线检测（如果需要）</li>
<li>根据需要更新所有输入模块</li>
</ul>
</li>
<li><strong>InputModules</strong>：输入模块，包含 <strong>StandaloneInputModule</strong> 和 <strong>TouchInputModule</strong> 两种具体实现，负责<strong>处理</strong>不同平台的输入行为。输入模块的主要任务有三个，分别是：<ul>
<li>处理输入</li>
<li>管理事件状态</li>
<li>发送事件到场景对象</li>
</ul>
</li>
<li><strong>Raycasters</strong>：射线检测模块，将输入位置映射到 UI 元素上，检测当前输入事件需要发送到哪里。系统提供了以下几种类型的 Raycaster:<ul>
<li><strong>Graphic Raycaster</strong>：检测 UI 元素</li>
<li><strong>PanelRaycaster</strong>：检测 UI Toolkit的面板实例</li>
<li><strong>Physics 2D Raycaster</strong>：用于 2D 物理元素</li>
<li><strong>Physics Raycaster</strong>：用于 3D 物理元素</li>
</ul>
</li>
</ol>
<p>这些模块共同协作，为 UGUI 提供了灵活的交互能力。</p>
<h2 id="EventSystem"><a href="#EventSystem" class="headerlink" title="EventSystem"></a>EventSystem</h2><p>EventSystem 与多个模块协同工作，主要负责<strong>保持（保存）状态</strong>并将功能委托给特定的组件。</p>
<p>当事件系统启动时，它会搜索连接到同一游戏对象的任何 <strong>BaseInputModules</strong>，并将它们添加到内部列表中。更新时，每个附加模块都会收到 <strong>UpdateModules</strong> 调用，模块可以在此修改内部状态。每个模块更新后，活动模块将执行 <strong>Process</strong> 调用。</p>
<h3 id="管理输入模块"><a href="#管理输入模块" class="headerlink" title="管理输入模块"></a>管理输入模块</h3><p>EventSystem 的源码采用了 <strong>BaseInputModule</strong> 类型的 List 和变量保存输入模块：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 系统输入模块</span></span><br><span class="line"><span class="keyword">private</span> List&lt;BaseInputModule&gt; m_SystemInputModules = <span class="keyword">new</span> List&lt;BaseInputModule&gt;();</span><br><span class="line"><span class="comment">// 当前输入模块</span></span><br><span class="line"><span class="keyword">private</span> BaseInputModule m_CurrentInputModule;</span><br></pre></td></tr></table></figure>
<p>在 <strong>BaseInputModule</strong> 的 <code>OnEnable</code> 和 <code>OnDisable</code> 中，脚本会查找场景中所有的输入模块并赋值给 <strong>m_SystemInputModules</strong> 字段。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UpdateModules</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取所有输入模块</span></span><br><span class="line">    GetComponents(m_SystemInputModules);</span><br><span class="line">    <span class="keyword">var</span> systemInputModulesCount = m_SystemInputModules.Count;</span><br><span class="line">    <span class="comment">// 移除非活跃状态的输入模块</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = systemInputModulesCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_SystemInputModules[i] &amp;&amp; m_SystemInputModules[i].IsActive())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        m_SystemInputModules.RemoveAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，EventSystem 会在 <code>TickModules</code> 方法中逐个更新每一个输入模块。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TickModules</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> systemInputModulesCount = m_SystemInputModules.Count;</span><br><span class="line">    <span class="comment">// 更新输入模块</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; systemInputModulesCount; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_SystemInputModules[i] != <span class="literal">null</span>)</span><br><span class="line">            m_SystemInputModules[i].UpdateModule();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>UpdateModule</code> 方法用于<strong>更新输入模块的状态</strong>，主要目的是处理触摸事件（对 StandaloneInputModule 的覆写则涵盖了鼠标事件等）的状态变化，确保窗口失去焦点时不会留下未处理的拖拽或输入状态。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">UpdateModule</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!eventSystem.isFocused &amp;&amp; ShouldIgnoreEventsOnNoFocus()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_InputPointerEvent != <span class="literal">null</span> &amp;&amp; m_InputPointerEvent.pointerDrag != <span class="literal">null</span> &amp;&amp; m_InputPointerEvent.dragging) &#123;</span><br><span class="line">            ReleaseMouse(m_InputPointerEvent, m_InputPointerEvent.pointerCurrentRaycast.gameObject);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_InputPointerEvent = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录鼠标的当前位置与上一次位置</span></span><br><span class="line">    m_LastMousePosition = m_MousePosition;</span><br><span class="line">    m_MousePosition = input.mousePosition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>EventSystem 对输入模块主要的管理在 <code>Update</code> 生命周期函数里，通过前文介绍过的 <code>TickModules</code> 方法更新输入模块，并 在满足条件的情况下调用当前模块的 <code>Process</code> 方法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Update</span>()</span> &#123; </span><br><span class="line">    TickModules();</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// 遍历 m_SystemInputModules</span></span><br><span class="line">    <span class="built_in">bool</span> changedModule = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> systemInputModulesCount = m_SystemInputModules.Count;</span><br><span class="line">    <span class="comment">// 遍历 m_SystemInputModules</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; systemInputModulesCount; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> module = m_SystemInputModules[i];</span><br><span class="line">        <span class="comment">// 判断输入模块是否支持当前平台</span></span><br><span class="line">        <span class="keyword">if</span> (module.IsModuleSupported() &amp;&amp; module.ShouldActivateModule()) &#123;</span><br><span class="line">            <span class="comment">// 如果支持并且可以激活，则将其赋值给当前输入模块并break</span></span><br><span class="line">            <span class="keyword">if</span> (m_CurrentInputModule != module) &#123;</span><br><span class="line">                ChangeEventModule(module);</span><br><span class="line">                changedModule = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// 如果上面没找到符合条件的模块，则使用第一个支持当前平台的模块</span></span><br><span class="line">    <span class="keyword">if</span> (m_CurrentInputModule == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; systemInputModulesCount; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> module = m_SystemInputModules[i];</span><br><span class="line">            <span class="keyword">if</span> (module.IsModuleSupported()) &#123;</span><br><span class="line">                ChangeEventModule(module);</span><br><span class="line">                changedModule = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// 如果当前模块没有发生变化并且当前模块不为空</span></span><br><span class="line">    <span class="keyword">if</span> (!changedModule &amp;&amp; m_CurrentInputModule != <span class="literal">null</span>)</span><br><span class="line">        m_CurrentInputModule.Process();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以 StandaloneInputModule 为例，其中的 <code>Process</code> 覆写长这样：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Process</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// 如果当前窗口未聚焦且配置为忽略无焦点事件，不处理事件</span></span><br><span class="line">    <span class="keyword">if</span> (!eventSystem.isFocused &amp;&amp; ShouldIgnoreEventsOnNoFocus())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 更新选中对象</span></span><br><span class="line">    <span class="built_in">bool</span> usedEvent = SendUpdateEventToSelectedObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于鼠标模拟层的存在，需要优先处理触摸事</span></span><br><span class="line">    <span class="keyword">if</span> (!ProcessTouchEvents() &amp;&amp; input.mousePresent)</span><br><span class="line">        ProcessMouseEvent();</span><br><span class="line">    <span class="comment">// 如果启用了导航事件，会处理移动事件和提交事件</span></span><br><span class="line">    <span class="keyword">if</span> (eventSystem.sendNavigationEvents) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!usedEvent)</span><br><span class="line">            usedEvent |= SendMoveEventToSelectedObject();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!usedEvent)</span><br><span class="line">            SendSubmitEventToSelectedObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="built_in">bool</span> <span class="title">SendUpdateEventToSelectedObject</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// 未选中任何对象</span></span><br><span class="line">    <span class="keyword">if</span> (eventSystem.currentSelectedGameObject == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> data = GetBaseEventData();</span><br><span class="line">    <span class="comment">// updateSelected 事件</span></span><br><span class="line">    ExecuteEvents.Execute(eventSystem.currentSelectedGameObject, data, ExecuteEvents.updateSelectedHandler);</span><br><span class="line">    <span class="keyword">return</span> data.used;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>Process</code> 方法就是我们在先前在 Button 点击事件调用链上找到的 <code>Process</code>，主要作用是<strong>捕获各种输入事件</strong>（如点击、拖拽等），通过 <code>ExecuteEvents.Execute</code> 方法执行 <strong>updateSelected 事件</strong>，更新 <strong>EventSystem</strong> 中当前选中的 <strong>GameObject</strong>(即 <strong>m_CurrentSelected</strong>)。有个这个“选中对象”，我们就知道触发事件的对象具体是哪个 UI 元素了，那么 EventSystem 是如何管理选中的游戏对象的呢？</p>
<h3 id="管理选中的游戏对象"><a href="#管理选中的游戏对象" class="headerlink" title="管理选中的游戏对象"></a>管理选中的游戏对象</h3><p>EventSystem 是通过一个用于储存当前选中对象的字段 <strong>m_CurrentSelected</strong> 来管理选中物体的。当场景中的可交互 UI 元素（例如 Button、Dropdown、InputField 等）被选中时，会通知之前选中的对象执行<strong>被取消</strong>(<strong>OnDeselect</strong>)事件，通知当前选中的对象执行<strong>选中</strong>(<strong>OnSelect</strong>)事件，部分代码如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> GameObject m_CurrentSelected;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetSelectedGameObject</span>(<span class="params">GameObject selected, BaseEventData pointer</span>)</span> &#123;</span><br><span class="line">    ......<span class="comment">//省略部分代码</span></span><br><span class="line">    <span class="comment">// 通知之前被选中取消选中</span></span><br><span class="line">    ExecuteEvents.Execute(m_CurrentSelected, pointer, ExecuteEvents.deselectHandler);</span><br><span class="line">    m_CurrentSelected = selected;</span><br><span class="line">    <span class="comment">// 通知当前物体被选中</span></span><br><span class="line">    ExecuteEvents.Execute(m_CurrentSelected, pointer, ExecuteEvents.selectHandler);</span><br><span class="line">    m_SelectionGuard = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="管理射线检测"><a href="#管理射线检测" class="headerlink" title="管理射线检测"></a>管理射线检测</h3><p>那么问题来了，我们怎么知道一个 UI 元素被选中了呢？这就是<strong>射线</strong>（Raycast）的作用了。<strong>EventSystem</strong> 中有一个非常重要的函数 <code>RaycastAll</code>，主要作用就是获取目标。它被 <strong>PointerInputModule</strong> 类调用，即当鼠标设备可用或触摸板被使用时被调用。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RaycastAll</span>(<span class="params">PointerEventData eventData, List&lt;RaycastResult&gt; raycastResults</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 清空结果</span></span><br><span class="line">    raycastResults.Clear();</span><br><span class="line">    <span class="comment">// 获取BaseRaycast对象</span></span><br><span class="line">    <span class="keyword">var</span> modules = RaycasterManager.GetRaycasters();</span><br><span class="line">    <span class="keyword">var</span> modulesCount = modules.Count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; modulesCount; ++i) &#123;</span><br><span class="line">        <span class="keyword">var</span> module = modules[i];</span><br><span class="line">        <span class="keyword">if</span> (module == <span class="literal">null</span> || !module.IsActive())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 调用Raycast方法，</span></span><br><span class="line">        module.Raycast(eventData, raycastResults);</span><br><span class="line">    &#125;</span><br><span class="line">​    <span class="comment">// 结果排序</span></span><br><span class="line">    raycastResults.Sort(s_RaycastComparer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它首先获取所有的 <strong>BaseRaycast</strong> 对象，然后调用它们的 <code>Raycast</code> 方法，用以获取屏幕某个点下的所有目标，最后对得到的结果进行排序。大部分情况下排序都是根据<strong>深度</strong>(Depth)进行排序的，在一些情况下也会使用<strong>距离</strong>(Distance)、<strong>排序顺序</strong>（SortingOrder，如果是UI元素则是根据Canvas面板的 Sort order 值，3D 物体默认是 0）或者<strong>排序层级</strong>(Sorting Layer)等作为排序依据。排序过后，<strong>raycastResults</strong> 中最前的目标就被认为成射线击中的对象。</p>
<p>总结一下，<strong>EventSystem</strong> 会在 <code>Update</code> 中调用输入模块的 <code>Process</code> 方法来处理输入消息，<strong>PointerInputModule</strong> 会调用 <strong>EventSystem</strong> 中的 <code>RaycastAll</code> 方法进行射线检测，<code>RaycastAll</code> 又会调用 <strong>BastRaycaster</strong> 的 <code>Raycast</code> 方法执行具体的射线检测操作，主要是获取被选中的目标信息。</p>
<h2 id="InputModules"><a href="#InputModules" class="headerlink" title="InputModules"></a>InputModules</h2><p>在讲 Button 的时候我们提到鼠标的点击事件是在 <strong>BaseInputModule</strong> 中触发的，除此之外，<strong>EventInterface</strong> 接口中的其他事件（也就是我们通过 <strong>Event Trigger</strong> 能为对象添加的所有事件类型）也都是由输入模块产生的。</p>
<p><img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VAce4fb7f15f44ee908354db64f18f3d6d.png" alt="EventTrigger里的事件类型" width="400"></p>
<p>各个不同的事件的具体触发条件如下：</p>
<ul>
<li><strong>pointerEnterHandler</strong>、<strong>pointerExitHandler</strong>：当鼠标或触摸进入、退出当前对象时执行。</li>
<li><strong>pointerDownHandler、pointerUpHandler</strong>：在鼠标或者触摸按下、松开时执行。</li>
<li><strong>pointerClickHandler</strong>：在鼠标或触摸松开并且与按下时是同一个响应物体时执行。</li>
<li><strong>beginDragHandler</strong>：在鼠标或触摸位置发生偏移（偏移值大于一个很小的常量）时执行。</li>
<li><strong>initializePotentialDrag</strong>：在鼠标或者触摸按下且当前对象可以响应拖拽事件时执行。</li>
<li><strong>dragHandler</strong>：对象正在被拖拽且鼠标或触摸移动时执行。</li>
<li><strong>endDragHandler</strong>：对象正在被拖拽且鼠标或触摸松开时执行。</li>
<li><strong>dropHandler</strong>：鼠标或触摸松开且对象未响应 <strong>pointerClickHandler</strong> 情况下，如果对象正在被拖拽则执行。</li>
<li><strong>scrollHandler</strong>：当鼠标滚动差值大于 <strong>0</strong> 执行。</li>
<li><strong>updateSelectedHandler</strong>：当输入模块切换到 <strong>StandaloneInputModule</strong> 时执行。（不需要Input类）</li>
<li><strong>selectHandler</strong>、<strong>deselectHandler</strong>：当鼠标移动导致被选中的对象改变时，执行。</li>
<li><strong>导航事件</strong>：导航可用的情况下，<ul>
<li>按上下左右键执行 <strong>moveHandler</strong></li>
<li>按确认键执行 <strong>submitHandler</strong></li>
<li>按取消键执行 <strong>cancelHandler</strong>。</li>
</ul>
</li>
</ul>
<p>更加底层的调用还是UnityEngine.Input类，但可惜的是这部分Unity并没有开源。</p>
<div class="note warning flat"><p>每次事件系统中只能有<strong>一个</strong>输入模块处于活跃状态，并且必须与 <strong>EventSystem</strong> 组件处于相同的游戏对象上。<br><img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA9f97b74ec565416932aa2eb4d6e056a1.png" width="300"></p>
</div>
<h3 id="执行事件"><a href="#执行事件" class="headerlink" title="执行事件"></a>执行事件</h3><p><strong>InputModule</strong> 可以处理设备输入，然后发送事件到场景对象，那这些事件是怎么执行的呢？在讲 Button 的时候，我们提到过 <strong>ExecuteEvent</strong> 类，其实事件的执行都是通过这个类进行的，不过也需要 <strong>EventInterface</strong> 接口配合。</p>
<p><strong>InputModule</strong> 类中定义了许多接口，比如鼠标按下、点击、拖拽等。<strong>ExecuteEvent</strong> 类中提供了一个方法让外部统一调用以执行事件，也就是前面提到的泛型 <code>Execute</code> 方法，主要就是查找 <strong>target</strong> 对象上的 <strong>T</strong> 类型的组件列表，并遍历执行。</p>
<p>除此之外，还有一个 <strong>GetEventHandler</strong> 方法，它主要是通过<strong>冒泡</strong>的方式查找到能够处理指定事件的对象。冒泡是什么意思？比如我们在场景中创建了一个 Button，这个 Button 还包含了一个 Text 组件，当鼠标点击到按钮上的文本时就会调用 <code>GetEventHandler</code> 函数。该函数的 root 参数其实是 Text，但是会通过冒泡的方式查找到它的父物体 Button，然后调用 Button 的点击事件。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在游戏对象上冒泡指定的事件，找出哪个对象将实际接收事件。 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GameObject <span class="title">GetEventHandler</span>&lt;<span class="title">T</span>&gt;(<span class="params">GameObject root</span>) <span class="keyword">where</span> T : IEventSystemHandler</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">​</span><br><span class="line">    Transform t = root.transform;</span><br><span class="line">    <span class="comment">// 冒泡查找，如果物体本身不能处理输入的事件，交予parent处理</span></span><br><span class="line">    <span class="keyword">while</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (CanHandleEvent&lt;T&gt;(t.gameObject))</span><br><span class="line">            <span class="keyword">return</span> t.gameObject;</span><br><span class="line">        t = t.parent;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 指定的游戏对象是否能够处理指定的事件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">CanHandleEvent</span>&lt;<span class="title">T</span>&gt;(<span class="params">GameObject go</span>) <span class="keyword">where</span> T : IEventSystemHandler</span> &#123;</span><br><span class="line">     <span class="keyword">var</span> internalHandlers = s_HandlerListPool.Get();</span><br><span class="line">     GetEventList&lt;T&gt;(go, internalHandlers);</span><br><span class="line">     <span class="keyword">var</span> handlerCount = internalHandlers.Count;</span><br><span class="line">     s_HandlerListPool.Release(internalHandlers);</span><br><span class="line">     <span class="keyword">return</span> handlerCount != <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Raycasters"><a href="#Raycasters" class="headerlink" title="Raycasters"></a>Raycasters</h2><p><strong>BaseRaycaster</strong> 是其他 <strong>Raycaster</strong> 的基类。在它的 <code>OnEnable</code> 里将自己注册到 <strong>RaycasterManager</strong>，并在 <code>OnDisable</code> 的时候从 <strong>RaycasterManager</strong> 中移除。这个 <strong>RaycasterManager</strong> 是一个静态类，维护了一个 <strong>BaseRaycaster</strong> 类型的 List，功能比较简单，包含<strong>获取</strong>(Get)、<strong>添加</strong>(Add)、<strong>移除</strong>(Remove)方法。</p>
<p><strong>BaseRaycaster</strong> 中最重要的就是 <code>Raycast</code> 方法了。对于 UI 元素来说，<strong>BaseRaycaster</strong> 有两个子类：<strong>PanelRaycaster</strong> 和 <strong>GraphicRaycaster</strong>，它们都对该方法进行了重写，以实现对应的射线方法。我们来分析一下 <strong>GraphicRaycaster</strong> 吧。</p>
<h3 id="GraphicRaycast"><a href="#GraphicRaycast" class="headerlink" title="GraphicRaycast"></a>GraphicRaycast</h3><p><strong>GraphicRaycast</strong> 用于检测 UI 元素，它依赖于 Canvas，我们在场景中添加 Canvas 默认都会包含一个 <strong>GraphicRaycast</strong> 组件：</p>
<p><img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA301b768b9ece4cb0c2775c2753aeb2d5.png" alt="i创建Canvas时自动创建的GraphicRaycast"></p>
<p><strong>GraphicRaycast</strong> 的 <code>Raycast</code> 方法先获取<strong>鼠标坐标</strong>，将其转换为 <strong>Camera</strong> 的<strong>视角坐标</strong>，然后分情况计算<strong>射线的距离</strong>（hitDistance），调用 <strong>Graphic</strong> 的 <code>Raycast</code> 方法来获取鼠标点下方的元素，最后将满足条件的结果添加到 <strong>resultAppendList</strong> 中。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 针对与 canvas 相关联的图形列表执行射线投射。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Raycast</span>(<span class="params">PointerEventData eventData, List&lt;RaycastResult&gt; resultAppendList</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (canvas == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// 返回Canvas上的所有包含Graphic脚本并且允许被射线检测的对象</span></span><br><span class="line">    <span class="keyword">var</span> canvasGraphics = GraphicRegistry.GetRaycastableGraphicsForCanvas(canvas);</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> (canvasGraphics == <span class="literal">null</span> || canvasGraphics.Count == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">int</span> displayIndex;</span><br><span class="line">    <span class="comment">// 画布在 ScreenSpaceOverlay 模式下默认为 null</span></span><br><span class="line">    <span class="keyword">var</span> currentEventCamera = eventCamera;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> (canvas.renderMode == RenderMode.ScreenSpaceOverlay || currentEventCamera == <span class="literal">null</span>)</span><br><span class="line">        displayIndex = canvas.targetDisplay;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        displayIndex = currentEventCamera.targetDisplay;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// 获取鼠标位置</span></span><br><span class="line">    <span class="keyword">var</span> eventPosition = Display.RelativeMouseAt(eventData.position);</span><br><span class="line">    <span class="comment">// 多 display 相关</span></span><br><span class="line">    <span class="keyword">if</span> (eventPosition != Vector3.zero) &#123;</span><br><span class="line">        <span class="comment">// 支持多 display 和基于事件位置的显示识别</span></span><br><span class="line">        <span class="built_in">int</span> eventDisplayIndex = (<span class="built_in">int</span>)eventPosition.z;</span><br><span class="line">        <span class="comment">// 丢弃不属于该 display 的事件，这样用户就不会同时与多个 display 交互。</span></span><br><span class="line">        <span class="keyword">if</span> (eventDisplayIndex != displayIndex)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 并非所有平台都支持多display，当不支持时返回的位置将全为 0</span></span><br><span class="line">        <span class="comment">// 为了安全起见，当返回的索引为 0 时，我们将默认为事件数据。</span></span><br><span class="line">        eventPosition = eventData.position;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// 将鼠标在屏幕上的坐标转换成摄像机的视角坐标</span></span><br><span class="line">    Vector2 pos;</span><br><span class="line">    <span class="keyword">if</span> (currentEventCamera == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">float</span> w = Screen.width;</span><br><span class="line">        <span class="built_in">float</span> h = Screen.height;</span><br><span class="line">        <span class="keyword">if</span> (displayIndex &gt; <span class="number">0</span> &amp;&amp; displayIndex &lt; Display.displays.Length) &#123;</span><br><span class="line">            w = Display.displays[displayIndex].systemWidth;</span><br><span class="line">            h = Display.displays[displayIndex].systemHeight;</span><br><span class="line">        &#125;</span><br><span class="line">        pos = <span class="keyword">new</span> Vector2(eventPosition.x / w, eventPosition.y / h);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        pos = currentEventCamera.ScreenToViewportPoint(eventPosition);</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// 如果超出相机范围则return</span></span><br><span class="line">    <span class="keyword">if</span> (pos.x &lt; <span class="number">0f</span> || pos.x &gt; <span class="number">1f</span> || pos.y &lt; <span class="number">0f</span> || pos.y &gt; <span class="number">1f</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">float</span> hitDistance = <span class="built_in">float</span>.MaxValue;</span><br><span class="line">​</span><br><span class="line">    Ray ray = <span class="keyword">new</span> Ray();</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// 如果 currentEventCamera 不为空，摄像机发射射线</span></span><br><span class="line">    <span class="keyword">if</span> (currentEventCamera != <span class="literal">null</span>)</span><br><span class="line">        ray = currentEventCamera.ScreenPointToRay(eventPosition);</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> (canvas.renderMode != RenderMode.ScreenSpaceOverlay &amp;&amp; blockingObjects != BlockingObjects.None) &#123;</span><br><span class="line">        <span class="built_in">float</span> distanceToClipPlane = <span class="number">100.0f</span>;</span><br><span class="line">        <span class="keyword">if</span> (currentEventCamera != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">float</span> projectionDirection = ray.direction.z;</span><br><span class="line">            distanceToClipPlane = Mathf.Approximately(<span class="number">0.0f</span>, projectionDirection)</span><br><span class="line">                ? Mathf.Infinity</span><br><span class="line">                : Mathf.Abs((currentEventCamera.farClipPlane - currentEventCamera.nearClipPlane) / projectionDirection);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算 hitDistance 的值</span></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> PACKAGE_PHYSICS</span></span><br><span class="line">            <span class="keyword">if</span> (blockingObjects == BlockingObjects.ThreeD || blockingObjects == BlockingObjects.All) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ReflectionMethodsCache.Singleton.raycast3D != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">var</span> hits = ReflectionMethodsCache.Singleton.raycast3DAll(ray, distanceToClipPlane, (<span class="built_in">int</span>)m_BlockingMask);</span><br><span class="line">                    <span class="keyword">if</span> (hits.Length &gt; <span class="number">0</span>)</span><br><span class="line">                        hitDistance = hits[<span class="number">0</span>].distance;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">if</span> PACKAGE_PHYSICS2D</span></span><br><span class="line">            <span class="keyword">if</span> (blockingObjects == BlockingObjects.TwoD || blockingObjects == BlockingObjects.All) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ReflectionMethodsCache.Singleton.raycast2D != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">var</span> hits = ReflectionMethodsCache.Singleton.getRayIntersectionAll(ray, distanceToClipPlane, (<span class="built_in">int</span>)m_BlockingMask);</span><br><span class="line">                    <span class="keyword">if</span> (hits.Length &gt; <span class="number">0</span>)</span><br><span class="line">                        hitDistance = hits[<span class="number">0</span>].distance;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    m_RaycastResults.Clear();</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// 调用 Raycast 函数重载，该方法位于 GraphicRaycaster 第326行</span></span><br><span class="line">    <span class="comment">// 不同于该 Raycast（提供给EventSystem使用），这个 Raycast 是内部调用的</span></span><br><span class="line">    Raycast(canvas, currentEventCamera, eventPosition, canvasGraphics, m_RaycastResults);</span><br><span class="line">​</span><br><span class="line">    <span class="comment">//遍历 m_RaycastResults</span></span><br><span class="line">    <span class="built_in">int</span> totalCount = m_RaycastResults.Count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; totalCount; index++) &#123;</span><br><span class="line">        <span class="keyword">var</span> go = m_RaycastResults[index].gameObject;</span><br><span class="line">        <span class="built_in">bool</span> appendGraphic = <span class="literal">true</span>;</span><br><span class="line">​        <span class="comment">// 判断 Graphic 的方向向量和 Camera 的方向向量是否相交</span></span><br><span class="line">        <span class="keyword">if</span> (ignoreReversedGraphics) &#123;</span><br><span class="line">            <span class="keyword">if</span> (currentEventCamera == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果没有摄像机，则始终面向前方</span></span><br><span class="line">                <span class="keyword">var</span> dir = go.transform.rotation * Vector3.forward;</span><br><span class="line">                appendGraphic = Vector3.Dot(Vector3.forward, dir) &gt; <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果有摄像机，则面向摄像机的前方</span></span><br><span class="line">                <span class="keyword">var</span> cameraForward = currentEventCamera.transform.rotation * Vector3.forward * currentEventCamera.nearClipPlane;</span><br><span class="line">                appendGraphic = Vector3.Dot(go.transform.position - currentEventCamera.transform.position - cameraForward, go.transform.forward) &gt;= <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">​        <span class="comment">// 判断 Graphic 是否在 Camera 的前面，并且距离小于等于 hitDistance</span></span><br><span class="line">        <span class="keyword">if</span> (appendGraphic) &#123;</span><br><span class="line">            <span class="built_in">float</span> distance = <span class="number">0</span>;</span><br><span class="line">            Transform trans = go.transform;</span><br><span class="line">            Vector3 transForward = trans.forward;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">if</span> (currentEventCamera == <span class="literal">null</span> || canvas.renderMode == RenderMode.ScreenSpaceOverlay)</span><br><span class="line">                distance = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                distance = (Vector3.Dot(transForward, trans.position - ray.origin) / Vector3.Dot(transForward, ray.direction));</span><br><span class="line">​</span><br><span class="line">                <span class="comment">// 检查对象是否在摄像机后面</span></span><br><span class="line">                <span class="keyword">if</span> (distance &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">​            <span class="comment">// 超出射线检测距离，忽视</span></span><br><span class="line">            <span class="keyword">if</span> (distance &gt;= hitDistance)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">​            <span class="comment">// 打包成 RaycastResult 添加到 resultAppendList 里</span></span><br><span class="line">            <span class="keyword">var</span> castResult = <span class="keyword">new</span> RaycastResult &#123;</span><br><span class="line">                ......</span><br><span class="line">            &#125;;</span><br><span class="line">            resultAppendList.Add(castResult);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个提供给 <strong>EventSystem</strong> 使用的 <code>Raycast</code> 方法里调用了 <code>Raycast</code> 的重载，该方法位于 <strong>GraphicRaycaster</strong> 的第326行，其作用是向屏幕投射射线并收集屏幕下方所有挂载了 Graphic 脚本的游戏对象，将结果储存到 <strong>m_RaycastResults</strong> 字段中。该重载方法的内容为：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向屏幕进行射线投射，收集屏幕下方的所有图形</span></span><br><span class="line">[<span class="meta">NonSerialized</span>] <span class="keyword">static</span> <span class="keyword">readonly</span> List&lt;Graphic&gt; s_SortedGraphics = <span class="keyword">new</span> List&lt;Graphic&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Raycast</span>(<span class="params">Canvas canvas, Camera eventCamera, Vector2 pointerPosition, IList&lt;Graphic&gt; foundGraphics, List&lt;Graphic&gt; results</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历场景内 Graphic 对象(挂载了 Graphic 脚本的对象)</span></span><br><span class="line">    <span class="built_in">int</span> totalCount = foundGraphics.Count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; totalCount; ++i) &#123;</span><br><span class="line">        Graphic graphic = foundGraphics[i];</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// -1 表示 canvas 尚未对其进行处理，也就是没有实际绘制</span></span><br><span class="line">        <span class="keyword">if</span> (!graphic.raycastTarget || graphic.canvasRenderer.cull || graphic.depth == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 目标点是否在矩阵中</span></span><br><span class="line">        <span class="keyword">if</span> (!RectTransformUtility.RectangleContainsScreenPoint(graphic.rectTransform, pointerPosition, eventCamera, graphic.raycastPadding))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 是否超出摄像机范围</span></span><br><span class="line">        <span class="keyword">if</span> (eventCamera != <span class="literal">null</span> &amp;&amp; eventCamera.WorldToScreenPoint(graphic.rectTransform.position).z &gt; eventCamera.farClipPlane)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 这里又有一个 Raycast 方法，是位于 Graphic 下的</span></span><br><span class="line">        <span class="keyword">if</span> (graphic.Raycast(pointerPosition, eventCamera)) &#123;</span><br><span class="line">            s_SortedGraphics.Add(graphic);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​    <span class="comment">// 排序</span></span><br><span class="line">    s_SortedGraphics.Sort((g1, g2) =&gt; g2.depth.CompareTo(g1.depth));</span><br><span class="line">    totalCount = s_SortedGraphics.Count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; totalCount; ++i)</span><br><span class="line">        results.Add(s_SortedGraphics[i]);</span><br><span class="line">​</span><br><span class="line">    s_SortedGraphics.Clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的源码中可以发现，这个 <code>Raycast</code> 方法中又套了一层 <code>Raycast</code> 方法（已经套了三层了），该方法位于 <strong>Graphic</strong> 类（RawImage、Image 和 Text 都间接继承自 Graphic）下。这个 <code>Raycast</code> 向场景中进行光线投射时，它主要会做两件事：</p>
<ul>
<li>使用 <strong>RectTransform</strong> 的值过滤元素</li>
<li>使用 <strong>Raycast</strong> 函数确定射线击中的元素</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sp：screen point</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">bool</span> <span class="title">Raycast</span>(<span class="params">Vector2 sp, Camera eventCamera</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isActiveAndEnabled)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// UI 元素,比如 Image，Button 等</span></span><br><span class="line">    <span class="keyword">var</span> t = transform;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">var</span> components = ListPool&lt;Component&gt;.Get();</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">bool</span> ignoreParentGroups = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">bool</span> continueTraversal = <span class="literal">true</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">while</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">        t.GetComponents(components);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; components.Count; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> canvas = components[i] <span class="keyword">as</span> Canvas;</span><br><span class="line">            <span class="keyword">if</span> (canvas != <span class="literal">null</span> &amp;&amp; canvas.overrideSorting)</span><br><span class="line">                continueTraversal = <span class="literal">false</span>;</span><br><span class="line">​</span><br><span class="line">            <span class="comment">// 获取 ICanvasRaycastFilter 组件(Image，Mask，RectMask2D)</span></span><br><span class="line">            <span class="keyword">var</span> filter = components[i] <span class="keyword">as</span> ICanvasRaycastFilter;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">if</span> (filter == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">var</span> raycastValid = <span class="literal">true</span>;</span><br><span class="line">​</span><br><span class="line">            <span class="comment">// 判断点是否在有效的范围内</span></span><br><span class="line">            <span class="keyword">var</span> <span class="keyword">group</span> = components[i] <span class="keyword">as</span> CanvasGroup;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">group</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ignoreParentGroups == <span class="literal">false</span> &amp;&amp; <span class="keyword">group</span>.ignoreParentGroups) &#123;</span><br><span class="line">                    ignoreParentGroups = <span class="literal">true</span>;</span><br><span class="line">                    raycastValid = filter.IsRaycastLocationValid(sp, eventCamera);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!ignoreParentGroups)</span><br><span class="line">                    raycastValid = filter.IsRaycastLocationValid(sp, eventCamera);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                raycastValid = filter.IsRaycastLocationValid(sp, eventCamera);</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">if</span> (!raycastValid) &#123;</span><br><span class="line">                ListPool&lt;Component&gt;.Release(components);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历它的父物体</span></span><br><span class="line">        t = continueTraversal ? t.parent : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListPool&lt;Component&gt;.Release(components);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码中有一个频繁出现的方法 <code>IsRaycastLocationValid</code>。该方法位于 <strong>ICanvasRaycastFilter</strong> 接口，用来判断测试点（sp）是否有效。如果无效则会返回 <strong>false</strong>，图形不会被加入前面的 <strong>s_SortedGraphics</strong> 列表中。</p>
<p><code>IsRaycastLocationValid</code> 方法的实现很简单：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">bool</span> <span class="title">IsRaycastLocationValid</span>(<span class="params">Vector2 screenPoint, Camera eventCamera</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 小于阈值(alphaHitTestMinimumThreshold)的 Alpha 值将导致射线事件穿透图像。 </span></span><br><span class="line">    <span class="comment">// alphaHitTestMinimumThreshold 为 1 将导致只有完全不透明的像素在图像上注册相应射线事件。</span></span><br><span class="line">    <span class="keyword">if</span> (alphaHitTestMinimumThreshold &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> (alphaHitTestMinimumThreshold &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> (activeSprite == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">​</span><br><span class="line">    Vector2 local;</span><br><span class="line">    <span class="keyword">if</span> (!RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, screenPoint, eventCamera, <span class="keyword">out</span> local))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">​</span><br><span class="line">    Rect rect = GetPixelAdjustedRect();</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// 转换为以左下角为参考点</span></span><br><span class="line">    local.x += rectTransform.pivot.x * rect.width;</span><br><span class="line">    local.y += rectTransform.pivot.y * rect.height;</span><br><span class="line">​</span><br><span class="line">    local = MapCoordinate(local, rect);</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// 将本地坐标转换为纹理空间</span></span><br><span class="line">    Rect spriteRect = activeSprite.textureRect;</span><br><span class="line">    <span class="built_in">float</span> x = (spriteRect.x + local.x) / activeSprite.texture.width;</span><br><span class="line">    <span class="built_in">float</span> y = (spriteRect.y + local.y) / activeSprite.texture.height;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> activeSprite.texture.GetPixelBilinear(x, y).a &gt;= alphaHitTestMinimumThreshold;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnityException e) &#123;</span><br><span class="line">        Debug.LogError(<span class="string">&quot;Using alphaHitTestMinimumThreshold greater than 0 on Image whose sprite texture cannot be read. &quot;</span> + e.Message + <span class="string">&quot; Also make sure to disable sprite packing for this sprite.&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="再看点击事件"><a href="#再看点击事件" class="headerlink" title="再看点击事件"></a>再看点击事件</h1><p>最后，我们再来回顾一下 <strong>Button</strong> 的点击事件是怎么触发的。首先是 <strong>EventSystem</strong> 在 <code>Update</code> 中调用当前输入模块的 <code>Process</code> 方法处理所有的鼠标事件，并且输入模块会调用 <code>RaycastAll</code> 来得到目标信息，通过冒泡的方式找到事件实际接收者并执行点击事件。</p>
<ol>
<li><p>用户输入捕获：<br>EventSystem 检测到鼠标点击或触摸操作，将输入数据封装为 PointerEventData 对象。</p>
</li>
<li><p>射线检测：<br>GraphicRaycaster 遍历场景中的 UI 元素，根据输入位置确定被点击的对象。</p>
</li>
<li><p>事件分发：<br>EventSystem 调用目标对象上实现的接口方法，如 IPointerClickHandler.OnPointerClick。</p>
</li>
<li><p>事件回调：<br>Button 的 OnPointerClick 方法被调用，进而触发 onClick 事件。</p>
</li>
</ol>
<h2 id="自定义-Button-行为"><a href="#自定义-Button-行为" class="headerlink" title="自定义 Button 行为"></a>自定义 Button 行为</h2><p>在实际开发中，Button 的默认功能可能无法满足需求。通过继承 Button 类，我们可以扩展其行为，例如：</p>
<ol>
<li><p><strong>添加双击功能</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DoubleClickButton</span> : <span class="title">Button</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> lastClickTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">float</span> doubleClickThreshold = <span class="number">0.3f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> UnityEvent onDoubleClick;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnPointerClick</span>(<span class="params">PointerEventData eventData</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnPointerClick(eventData);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Time.time - lastClickTime &lt; doubleClickThreshold) &#123;</span><br><span class="line">            onDoubleClick.Invoke();</span><br><span class="line">        &#125;</span><br><span class="line">        lastClickTime = Time.time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>改变点击区域</strong></p>
</li>
</ol>
<p>通过重写射线检测逻辑，可以自定义 Button 的点击区域：<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomHitButton</span> : <span class="title">Button</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">IsRaycastLocationValid</span>(<span class="params">Vector2 sp, Camera eventCamera</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 自定义点击区域逻辑</span></span><br><span class="line">        <span class="keyword">return</span> RectTransformUtility.RectangleContainsScreenPoint(rectTransform, sp, eventCamera);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>在复杂 UI 场景中，大量 Button 可能导致性能问题。以下是一些优化建议：</p>
<ol>
<li><p>减少不必要的事件监听：如果 Button 的状态变化不需要动画，可以禁用 Animator。</p>
</li>
<li><p>合并 UI 元素：使用 Canvas 的批处理功能减少绘制调用。</p>
</li>
<li><p>合理规划事件回调：避免在 onClick 中执行复杂逻辑，尽量将耗时操作放在后台线程。</p>
</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/437704772">https://zhuanlan.zhihu.com/p/437704772</a><br><a target="_blank" rel="noopener" href="https://kendevlog.wordpress.com/2019/05/16/unity-%E6%8A%80%E5%B7%A7-%E7%95%8C%E9%9D%A2%E5%A4%A7%E8%AE%8A%E8%BA%AB-%E5%9F%BA%E7%A4%8E%E7%AF%87/">https://kendevlog.wordpress.com/2019/05/16/unity-%E6%8A%80%E5%B7%A7-%E7%95%8C%E9%9D%A2%E5%A4%A7%E8%AE%8A%E8%BA%AB-%E5%9F%BA%E7%A4%8E%E7%AF%87/</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://cattyhouse-guiny.xyz">时光</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://cattyhouse-guiny.xyz/2023/07/15/%E6%B8%B8%E6%88%8F%E6%8A%80%E6%9C%AF/UGUI/UnityUI%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8EUI%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AUGUI%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6/">https://cattyhouse-guiny.xyz/2023/07/15/%E6%B8%B8%E6%88%8F%E6%8A%80%E6%9C%AF/UGUI/UnityUI%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8EUI%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AUGUI%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://cattyhouse-guiny.xyz" target="_blank">几/何/冰/川</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Unity/">Unity</a><a class="post-meta__tags" href="/tags/UI/">UI</a><a class="post-meta__tags" href="/tags/UGUI/">UGUI</a><a class="post-meta__tags" href="/tags/%E6%BA%90%E7%A0%81/">源码</a></div><div class="post_share"><div class="social-share" data-image="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VAa198651e59fd8df47130a8f8b489dbc5.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/20/%E6%B8%B8%E6%88%8F%E6%8A%80%E6%9C%AF/UGUI/UnityUI%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8EUI%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AUGUI%E4%BC%98%E5%8C%96/" title="UnityUI程序设计与UI性能优化（五）：UGUI性能优化指南"><img class="cover" src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA1fc5ff9e9083059d3dab93de58d27b40.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">UnityUI程序设计与UI性能优化（五）：UGUI性能优化指南</div></div></a></div><div class="next-post pull-right"><a href="/2023/07/11/%E6%B8%B8%E6%88%8F%E6%8A%80%E6%9C%AF/UGUI/UnityUI%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8EUI%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="UnityUI程序设计与UI性能优化（三）：UGUI的渲染流程"><img class="cover" src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA96d03380d5b9586247c6962d0c4f1351.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">UnityUI程序设计与UI性能优化（三）：UGUI的渲染流程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/07/11/%E6%B8%B8%E6%88%8F%E6%8A%80%E6%9C%AF/UGUI/UnityUI%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8EUI%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="UnityUI程序设计与UI性能优化（三）：UGUI的渲染流程"><img class="cover" src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA96d03380d5b9586247c6962d0c4f1351.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-11</div><div class="title">UnityUI程序设计与UI性能优化（三）：UGUI的渲染流程</div></div></a></div><div><a href="/2023/07/20/%E6%B8%B8%E6%88%8F%E6%8A%80%E6%9C%AF/UGUI/UnityUI%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8EUI%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AUGUI%E4%BC%98%E5%8C%96/" title="UnityUI程序设计与UI性能优化（五）：UGUI性能优化指南"><img class="cover" src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA1fc5ff9e9083059d3dab93de58d27b40.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-20</div><div class="title">UnityUI程序设计与UI性能优化（五）：UGUI性能优化指南</div></div></a></div><div><a href="/2023/06/30/%E6%B8%B8%E6%88%8F%E6%8A%80%E6%9C%AF/UGUI/UnityUI%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8EUI%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" title="UnityUI程序设计与UI性能优化（一）：基本概念"><img class="cover" src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VAa2bc4a06555293dfd21c7343d47b81cd.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-30</div><div class="title">UnityUI程序设计与UI性能优化（一）：基本概念</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">时光</div><div class="author-info__description">时间的旅者，无痕的过客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">68</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">122</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Guiny-Time"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Guiny-Time" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:guinytime@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎光临时光的博客！有关于本博客的详细信息请见<b>“关于”</b>。<br>本博客的访问方式：<a href="https://cattyhouse-guiny.xyz/">https://cattyhouse-guiny.xyz/</a> <br><a target="_blank" rel="noopener" href="https://guiny-time.github.io/">https://guiny-time.github.io/</a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%89%E9%92%AE%E7%82%B9%E5%87%BB%E7%9A%84%E8%A7%A6%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">按钮点击的触发流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Button%EF%BC%9APress-gt-OnPointerClick"><span class="toc-number">1.1.</span> <span class="toc-text">Button：Press -&gt; OnPointerClick</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ExecuteEvents%EF%BC%9AExecute-gt-s-PointerClickHandler-gt-pointerClickHandler"><span class="toc-number">1.2.</span> <span class="toc-text">ExecuteEvents：Execute -&gt; s_PointerClickHandler -&gt; pointerClickHandler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BaseInput%EF%BC%9AReleaseMouse-Execute-gt-ProcessMousePress-gt-ProcessMouseEvent-gt-Process"><span class="toc-number">1.3.</span> <span class="toc-text">BaseInput：ReleaseMouse(Execute) -&gt; ProcessMousePress -&gt; ProcessMouseEvent -&gt; Process</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UGUI%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.</span> <span class="toc-text">UGUI的事件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#EventSystem"><span class="toc-number">2.1.</span> <span class="toc-text">EventSystem</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E8%BE%93%E5%85%A5%E6%A8%A1%E5%9D%97"><span class="toc-number">2.1.1.</span> <span class="toc-text">管理输入模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E9%80%89%E4%B8%AD%E7%9A%84%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.2.</span> <span class="toc-text">管理选中的游戏对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B"><span class="toc-number">2.1.3.</span> <span class="toc-text">管理射线检测</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InputModules"><span class="toc-number">2.2.</span> <span class="toc-text">InputModules</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.2.1.</span> <span class="toc-text">执行事件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Raycasters"><span class="toc-number">2.3.</span> <span class="toc-text">Raycasters</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GraphicRaycast"><span class="toc-number">2.3.1.</span> <span class="toc-text">GraphicRaycast</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%8D%E7%9C%8B%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6"><span class="toc-number">3.</span> <span class="toc-text">再看点击事件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-Button-%E8%A1%8C%E4%B8%BA"><span class="toc-number">3.1.</span> <span class="toc-text">自定义 Button 行为</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">3.2.</span> <span class="toc-text">性能优化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">4.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/04/06/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E7%BC%96%E5%86%99Claude%E6%8F%90%E7%A4%BA%E8%AF%8D/" title="如何优雅地编写Claude提示词——提示词工程介绍"><img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VAa331303a4fbb9cd9a7d8cc627210df93.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何优雅地编写Claude提示词——提示词工程介绍"/></a><div class="content"><a class="title" href="/2025/04/06/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E7%BC%96%E5%86%99Claude%E6%8F%90%E7%A4%BA%E8%AF%8D/" title="如何优雅地编写Claude提示词——提示词工程介绍">如何优雅地编写Claude提示词——提示词工程介绍</a><time datetime="2025-04-06T12:00:49.000Z" title="发表于 2025-04-06 20:00:49">2025-04-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/06/%E7%BC%96%E8%BE%91%E5%87%BA%E7%89%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="编辑出版の基础知识"><img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA5bda4c6a55958d8fdd15b403e71bbf14.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="编辑出版の基础知识"/></a><div class="content"><a class="title" href="/2025/03/06/%E7%BC%96%E8%BE%91%E5%87%BA%E7%89%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="编辑出版の基础知识">编辑出版の基础知识</a><time datetime="2025-03-06T07:55:44.000Z" title="发表于 2025-03-06 15:55:44">2025-03-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/04/%E6%B8%B8%E6%88%8F%E6%8A%80%E6%9C%AF/toLua%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" title="toLua学习记录"><img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VAf4da76dd755ee1073f55b9f2d33af128.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="toLua学习记录"/></a><div class="content"><a class="title" href="/2025/03/04/%E6%B8%B8%E6%88%8F%E6%8A%80%E6%9C%AF/toLua%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" title="toLua学习记录">toLua学习记录</a><time datetime="2025-03-04T13:34:24.000Z" title="发表于 2025-03-04 21:34:24">2025-03-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/27/%E6%B8%B8%E6%88%8F%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84%E5%9B%9B%E5%8F%89%E6%A0%91/" title="游戏中的四叉树"><img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA7562191307de671338bddf3ce1a67e86.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="游戏中的四叉树"/></a><div class="content"><a class="title" href="/2025/01/27/%E6%B8%B8%E6%88%8F%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84%E5%9B%9B%E5%8F%89%E6%A0%91/" title="游戏中的四叉树">游戏中的四叉树</a><time datetime="2025-01-27T14:30:54.000Z" title="发表于 2025-01-27 22:30:54">2025-01-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/29/2024%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/" title="2024年终总结"><img src="https://b.bdstatic.com/comment/HPpFm-ziUYsgpwpjCcQ1VA9ec6e766c3f0df3108fd9d215123d6de.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2024年终总结"/></a><div class="content"><a class="title" href="/2024/12/29/2024%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/" title="2024年终总结">2024年终总结</a><time datetime="2024-12-29T03:31:02.000Z" title="发表于 2024-12-29 11:31:02">2024-12-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/17/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/%E5%9C%A8%E7%BB%88%E9%9D%A2%E4%B9%8B%E5%90%8E%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E%E8%B0%B7%E6%AD%8C%E6%96%87%E6%A1%A3%E7%9A%84%E9%85%8D%E7%BD%AE%E8%A1%A8/" title="在终面之后——基于谷歌文档的多语言配置"><img src="/2024/12/17/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/%E5%9C%A8%E7%BB%88%E9%9D%A2%E4%B9%8B%E5%90%8E%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E%E8%B0%B7%E6%AD%8C%E6%96%87%E6%A1%A3%E7%9A%84%E9%85%8D%E7%BD%AE%E8%A1%A8/mul.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="在终面之后——基于谷歌文档的多语言配置"/></a><div class="content"><a class="title" href="/2024/12/17/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/%E5%9C%A8%E7%BB%88%E9%9D%A2%E4%B9%8B%E5%90%8E%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E%E8%B0%B7%E6%AD%8C%E6%96%87%E6%A1%A3%E7%9A%84%E9%85%8D%E7%BD%AE%E8%A1%A8/" title="在终面之后——基于谷歌文档的多语言配置">在终面之后——基于谷歌文档的多语言配置</a><time datetime="2024-12-16T16:00:00.000Z" title="发表于 2024-12-17 00:00:00">2024-12-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By 时光</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'forest'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    btf.addModeChange('mermaid', () => {
      window.runMermaid()
    })

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'c814313c5d1b183c9c3e',
      clientSecret: 'a4a4fb04b96e4ea4e93304cf819b7b85d8a94f56',
      repo: 'Guiny-Time.github.io',
      owner: 'Guiny-Time',
      admin: ['Guiny-Time'],
      id: '8ffaea54d2178b7cabf5af0cd920a977',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.textContent= n
  }
}

if ('Gitalk' === 'Gitalk' || !true) {
  if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script><script defer data-pjax src="https://gcore.jsdelivr.net/gh/xiabo2/CDN@latest/fishes.js"></script><script src="/js/universe.js"></script><div class="aplayer no-destroy" data-id="7263032154" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false" data-lrcType="-1"> </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script src="/assets/mmedia/mmedia-loader.js"></script> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://cattyhouse-guiny.xyz/categories/引擎功能/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🧊 Unity引擎功能 (16)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://cattyhouse-guiny.xyz/categories/效果实现/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🦚 渲染效果实现 (6)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://cattyhouse-guiny.xyz/categories/探索发现/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🪐 探索与发现 (6)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://cattyhouse-guiny.xyz/categories/项目复盘/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">👩‍💻 项目复盘 (10)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://cattyhouse-guiny.xyz/categories/设计模式/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 游戏编程模式 (7)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://cattyhouse-guiny.xyz/categories/计算机图形学/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 计算机图形学 (6)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://cattyhouse-guiny.xyz/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #ffffff;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #1E90FF}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>