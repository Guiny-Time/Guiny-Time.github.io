---
tags: ['Unity Shader', 'Unity', '纹理', '计算机图形学', '凹凸映射']
title: §2-2纹理映射与贴图
date: 2021-08-17
categories: UnityShader
mathjax: true
cover: https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/20211101231325.png
---

# 凹凸映射贴图(Bump)
凹凸映射通过修改物体表面的法线来为物体提供更多细节，使模型看起来更逼真(但不会真的改变模型顶点的位置)。

## 法线映射(Normal)
- 法线纹理通过颜色来表示法线。但由于像素RGB的分量在[0, 1]范围，而法线的分量在[-1, 1]范围，因此需要使用以下公式进行映射：
$$pixel = \frac{normal + 1}{2}$$
- 法线纹理储存在模型空间或模型切线空间中。
- 法线纹理(Normal Map)储存的是法线本身，因此使用法线纹理的处理速度比高度纹理更快。
<center><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/20211101202012.png" width=380/></center>

法线映射与视差映射的效果对比如下：
请注意，视差贴图与法线贴图和凹凸贴图一样，物体的轮廓都不受影响。
<center><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/20211101202704.png" width=450 alt="视差映射与法线映射的效果对比"/></center>

### 模型空间的法线纹理(Object-space Normal Map)
记录**模型空间内各点的法线方向**，通过映射公式后得到的法线纹理。模型空间的法线纹理较为直观，可以看出凹凸情况、五颜六色
模型空间的法线纹理有以下几个优缺点：
- 实现简单、表现直观
不需要原始模型的法线/切线信息，只需要记录各个顶点的法线方向
- 缝隙较少、平滑边界
模型空间的法线纹理能够对边界处进行线性插值以获得更平滑的效果
- 低自由度
模型空间的法线纹理是固定的(绝对法线信息)，因此，模型空间的法线贴图是不能够重用的，当模型产生改变之后贴图便不再合适，也无法应用于UV动画。
<center><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/20211101002807.png" width=300/></center>

### 切线空间的法线纹理(Tangent-space Normal Map)
与模型空间的法线纹理不同的是，切线空间的法线纹理记录的是法线的扰动值，或者说偏移量，是一个相对的法线信息。
对于模型的任意一个顶点，我们可以找到一个**切平面**（由切线和副切线组成的空间，世界空间转切线空间的矩阵被称作TBN矩阵），其中上面的任意一条直线都是该顶点的切线。对于切平面垂直的直线即该顶点的法线。我们记录的是新的法线较原本法线的偏移量，如下图所示：
![](@attachment/Clipboard_2021-09-01-11-16-28.png)
由于映射公式的特性，切线空间的法线纹理基本是蓝色色调的(当法线并没有任何偏移时也是蓝色)
切线空间的法线纹理有以下几个优缺点：
- 高自由度、可用于UV动画
因为是相对的法线纹理，所以当模型发生变化的时候，也能得到一个合理的效果。并且可以用在水、熔岩这样流动的物体效果上
- 可重用
一张切线空间的法线贴图可用在多个物体上，比如一块砖的六面
- 可压缩
我们可以只储存切线空间的XY分量来推导法线的Z分量，所以可以舍弃掉第三个分量来压缩贴图（这也是为什么最好在Unity中把法线贴图的类型设置成Normal，这是方便Unity进行压缩）。而对于模型空间的法线纹理则必须记录三个分量
<center><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/20211101002906.png" width=300/></center>

### 法线映射的光照计算
#### 切线空间下计算光照
- 效率更高
- 通用性更差
在切线空间下计算光照，需要将光照和视角方向转换到切线空间再进行计算。这些操作可以在顶点着色器中完成。
但由于一些时候我们需要在世界空间才能完成一些计算，所以不通用。

#### 世界空间下计算光照
- 效率更低
- 通用性更高
在世界空间下计算光照，需要对纹理进行采样，将法线转换到世界空间再计算。这些操作需要在片元着色器中完成。
因为是在世界空间完成的计算，所以通用性更高。

# 位移/置换贴图(Displacement)
与凹凸映射不同的是，位移贴图真的改变了顶点的位置。（根据储存在纹理中的几何信息对顶点进行位移或偏移）
## 视差映射(Parallax)
视差贴图是模仿位移贴图（这是完全不同于凹凸映射的一种映射方式）的一种方法，根据纹理中保存的数值表面点的实际几何位置沿着表面法线发生偏移。视差映射主要为了赋予模型表面遮挡关系的细节
- 使用储存了强度值(Intensity)的**高度图**/高度纹理(Height Map)来模拟表面位移，即表面局部的海拔高度。
- 高度纹理通过颜色非常直观的表示了高度，颜色越浅表示表面越向外凸起、颜色越深表示表面越向内凹（如下图所示）。（也有可能是反过来的，那个是深度图，或者是反向高度图）。应用视差贴图时，低位置的信息被高位置的信息遮挡掉了，所以会采样更高的信息
- 高度纹理通过灰度计算得出法线，不能直接得到法线值，需要消耗更多性能。

<center><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/20211101204710.png" width=280/></center>

### 原理
<img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/20211101211143.png" width=250 style="float:right"/>

我们可以参考右图的示例。
在没有高度图的情况下，从视线方向出发，我们会看到平面上的A点和B点。而在加上高度图之后，从A点看东西直接投到B点底下去了。
这可是ntr行为啊kora！但我们怎么知道这个B点到底是哪个呢？毕竟一条线上的点多了去了。然而，我们并没有精确的求B点的方法，只能用近似的方法求解：
- 计算Ha的值（A点距离水平面的高度信息）
- 利用A点的深度、实现方向实现近似三角形，计算近似B点

算出来的近似点B'其实和真实的B点有所偏差，这就是视差映射偏移的由来
<img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/20211101213454.png" width=300/>

> **遮挡是如何产生的？**
思考一下我们求近似点B'的操作，我们利用A点的高度去构造了一个近似三角形。但如果A点的深度Ha很大呢？那么B'与真实的B点之间的偏移就会更大，这样A点最终被渲染出来的机会就比较小（因为偏移后就被采样到其他点上了）。
然而当视线看到B点这样深度比较小的点，计算出来的偏移就比较小甚至没有，所以被采样的机会就比较大。
深度大的点很容易被深度小的点覆盖掉，这样就会表现出遮挡的效果了。

### 陡峭视差映射(Steep Parallax)
在一般正常的视差映射中，经常会出现一种“位移”的感觉，这是不可避免的。相较于传统的视差映射，陡视差映射能够尽可能的精确近似点与真实点之间的误差。
<img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/20211101214916.png" width=300 style="float:right"/>

#### 原理
如右图所示，陡视差映射分出了许多间隔相同的层。分层的多少由你来定，但是分太多了会增大性能开销，分太少了会导致偏移的不准确性上升、锯齿明显等问题。
来还原一下陡视差映射的算法，还是根据右图所示：
- 首先对A点采样，得到深度大约为0.8的位置，而其对应层深度为0.0，不符合，继续采样
- 采样B点，深度为1，层深度为0.25，不符合，继续采样
- 采样C点，深度大约为0.8，层深度为0.5，不符合，继续采样
- 采样D点，采样深度为0.5，层深度为0.75，符合层的深度大于实际采样到的深度的条件，认为是比较合理的一个偏移点，返回结果。

## 浮雕映射(Relief)
因为视差映射的偏移可能导致模型的视觉效果失真，所以需要使用浮雕映射贴图去真实的更改模型的顶点。并且，在更改凹凸程度之后，可以真实的造成阴影。
### 原理
视差步进 + 二分查找（注意顺序，先二分查找可能造成错误的结果）。视差步进指的是类似陡视差映射那样的逐层寻找的过程，而二分查找指的是在找到近似的层之后，在这层继续使用视差步进缩小误差范围
<center><img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/20211101224406.png" width=400/></center>

### 视差闭塞贴图（Parallax Occlusion Mapping）
浮雕映射的视差步进与二分查找实际上是一个不断迭代直到找到精确点的过程，这么做的开销很大。为了解决迭代的资源占用大的问题，就可以采用视差闭塞贴图（POM）。
#### 原理
POM的原理是在视差步进的最后一步对两个点求高度H，并对这两个高度Ha、Hb进行插值。
#### 优点
- 因为只需要一步插值，POM的资源开销是最小的。
- 适合平滑的面，有突起的话可能没法得到正确的结果
