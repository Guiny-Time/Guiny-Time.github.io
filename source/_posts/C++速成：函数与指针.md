---
tags: ['C++']
title: C++速成：函数与指针
created: '2022-02-10'
categories: 语言学习
cover: https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/20220129030603.png
---

# 函数
&emsp;&emsp;函数是对特定一部分代码的封装，遵循面向对象的基本原则，一个函数应该专注于干一件事。C++函数的语法格式和Java差不多，由返回值类型、输入参数和返回值构成：
```C++
// 声明函数MyFunc（可以声明多次）
int MyFunc(int a);

// 定义函数MyFunc
int MyFunc(int a){
  a+=1;
  return a;
}
```
&emsp;&emsp;当我们的函数是写在其他文件中的时候，我们就需要跨文件的调用函数。跨文件调用函数的步骤如下：
- 创建头文件(.h)和源文件(.cpp)
- 在头文件中声明函数，在源文件中定义函数
- 在需要使用函数的地方引用头文件即可调用

## 注意事项
1. 顺序问题
当处于同一个文件时，我们可以简单的把函数写在main函数外头，然后在main函数里通过MyFunc(a);的方式去调用。另外我发现一件很狗的事情就是：**当不进行声明时，用户*定义*函数必须写在main函数前面**，否则就会出现标识符未找到的问题。但是如果在main函数前先进行了声明，在main函数之后再定义函数内容是可以的。

2. 参数问题
当我们利用函数直接对值进行修改时，实际上我们是在一个新的内存地址创建了一个或多个变量来存储函数处理的结果，并不会影响到输入的参数本身。也就是说：
```C++
int MyFunc(int a){
  a+=1;
  return a;
}

int main(){
  int a = 1;
  MyFunc(a);
  return 0;
}
```
当我们调用完这个函数之后再打印输入参数a的值时，a的值并没有变成2，仍然是1。如果我们需要切实的修改输入参数的内存的值，需要使用指针。

# 指针
> 学习 C++ 的指针既简单又有趣。通过指针，可以简化一些 C++ 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。

&emsp;&emsp;指针也是一种**变量**，**在32位系统下占4个字节，在64位系统下占8个字节**。指针可以用来存放一段内存地址，而内存地址指向一个变量，也可能指向什么都没有的空内存。声明指针的方式很简单，我们可以用类型 + *变量名的方式进行声明：

```C++
int    *ip;    /* 一个整型的指针 */
double *dp;    /* 一个 double 型的指针 */
float  *fp;    /* 一个浮点型的指针 */
char   *ch;    /* 一个字符型的指针 */
```
&emsp;&emsp;请注意，虽然在声明指针时使用了诸如int、double的类型关键字，但实际上指针的值只有一种数据类型，即**代表内存地址的长的十六进制数**。利用不同的类型进行声明的目的是更好的区分内存地址指向的变量的类型。

## 指针与变量
&emsp;&emsp;我们可以将一个指针与一个变量相绑定，使得指针储存的内存地址指向改变量。*符号用来声明指针/获取指针的值，&符号用来获取变量的内存地址（取址）：
```C++
#include <iostream>
using namespace std;
 
int main ()
{
   int var = 20;
   int *ip;         // 指针变量的声明
   ip = &var;       // 在指针变量中存储 var 的地址
 
   // 输出在指针变量中存储的地址
   cout << "Address stored in ip variable: " << ip << endl;
 
   // 访问指针中地址的值
   cout << "Value of *ip variable: " << *ip << endl;
 
   return 0;
}
```
**输出结果**：
Address stored in ip variable: 00EFFD88
Value of *ip variable: 20

## 指针与数组
&emsp;&emsp;需要知道的一点是：当我们定义了一个数组之后，描述数组的变量名（例如arr）其实代表的是数组的第一个元素的地址。如果我们将数组与指针关联的话：
```C++
int arr[] = {1,2,3,4,5};
int *p = &arr;
cout << *p << endl;
p++;
cout << *p << endl;
```
**输出结果**：
1
2

&emsp;&emsp;可见，如果我们要获取数组第二位或者其他元素，可以对p执行++操作。这里因为p是int类型的指针，++的操作会让指针往4个字节后走。

## 指针与函数
&emsp;&emsp;如果我们不针对内存地址去更改的话，在函数内修改输入参数并不会影响到其本身，因为函数在拿到输入参数之后对其深拷贝了。如果要想切实的修改输入参数本身，就需要使用指针：
```C++
void swap(int *p1, int *p2){
  int temp = *p1;
  *p1 = *p2;
  *p2 = temp;
}
...
int main(){
  int a = 10;
  int b = 20;
  swap(&a, &b);
  return 0;
}
```
&emsp;&emsp;当我们直接把指针作为输入参数处理的时候，实际上就会直接修改到值本身了。当我们调用函数的时候，输入变量的内存地址。

## 几种指针类型
### 空指针
&emsp;&emsp;空指针的含义是指针存储的地址为NULL。在变量声明的时候，如果没有确切的地址可以赋值，为指针变量先赋一个NULL值是一个良好的编程习惯：
```C++
int  *pointer = NULL;
```
&emsp;&emsp;我们可以在后续的编程中给空指针具体赋值。空指针返回的值为0。

### 野指针
&emsp;&emsp;野指针指的是指针指向了一块非法的内存空间，例如：没有访问权限的地址。使用野指针可能会报错。

### 常量指针
&emsp;&emsp;常量指针指在声明一个指针时加上了const关键字：
```C++
int a = 10;
int b = 10;
int c = 20;
const int *pointer = &a;
```
这代表指针指向的内存所指向的值不能改变。意思是：
- pointer指针**可以指向a也可以指向b**，因为变量a和b的内存地址虽然不一样但值一样。
- pointer指针**不可以指向c**，因为变量c的值和变量a不同。

### 指针常量
&emsp;&emsp;与常量指针这个名词相近的还有“指针常量”。指针常量在声明的时候把const关键字放到了指针变量名的前面：
```C++
int a = 10;
int b = 10;
int * const pointer = &a;
a = 20;
```
这代表该指针不能指向其他变量。意思是：
- pointer指针**可以指向a，不可指向b**。因为变量a和b的内存地址不一样。
- a的值可以改变，因为pointer仅指向a。

### 常量指针常量
&emsp;&emsp;当我们说到这个的时候，我们可以把常量指针当成X-Vmon，把指针常量当成刺钉兽，两个数码兽来个混合进化。是的，常量指针常量就是把const同时加在了两个地方：
```C++
int a = 10;
int b = 10;
const int * const pointer = &a;
```
&emsp;&emsp;这代表指针仅可以指向变量a，并且变量a的值不可以更改。