---
tags: ['TA','Unity Shader','shader','渲染管线']
title: 渲染管线(下)：GPU渲染流水线
date: '2022-11-01T08:30:17.165Z'
cover: https://yanxuan.nosdn.127.net/51fb7d95b02a30282ae84efc909ec467.jpg
---

处理场所：GPU
主要流程：
1. 顶点处理
2. 图元装配
3. 光栅化
4. 片元着色器
5. 输出合并

<img src="https://tva1.sinaimg.cn/large/006UcwnJly1h7ppdcwzlxj30k00ec0wj.jpg" alt="image" width="720" data-width="720" data-height="516">

# 顶点处理
在顶点处理阶段，每个顶点都会经过一次顶点着色器。虽然一个模型可能有很多很多顶点，但得益于GPU的高并发的特点，可以同时处理大量的数据，所以实际上是很快的（虽然快但不代表可以无限精细模型）。在顶点阶段完成的最基本的操作是顶点坐标的变换，从模型空间经过MVP处理变换到齐次裁剪空间。在这个阶段也可以计算顶点的光照（高洛德着色），但效果不佳。
除了顶点着色器之外，顶点处理阶段还包括**曲面细分着色器**和**几何着色器**。这两种着色器是**非必须**的，可选可不选。
## 曲面细分着色器(Tessellation Shader)
主要作用是用于细分图元。曲面细分着色器是一个**可选的着色器**，主要是对三角面进行细分，以此来增加物体表面的三角面的数量。借助它可以实现**细节层次(LOD,Level-of-Detail**)的机制，使得离摄像机越近的物体具有更加丰富的细节，而远离摄像机的物体具有较少的细节。
### 几何着色器
几何着色器也是一个**可选的着色器**，它以完整的图元（比如，点）作为输入数据，输出可以是一个或多个其他的图元(比如，三角面)，或者不输出任何的图元。几何着色器的拿手好戏就是将输入的点或线扩展成多边形。我们可以用几何着色器完成很多工作，例如绘制mesh的法线、

# 图元装配
## 裁剪(Clipping) 
CPU阶段的剔除已经帮助我们去掉了所有整个在视锥体外、不需要渲染的物体。但有一些物体**部分在视锥体内部分在视锥体外**，针对这些物体，在视锥体外的部分就需要进行裁剪，使用一些新的顶点来代替被裁剪的部分，不再渲染视锥体外被裁减的部分，减少开销。

<img src="https://tva3.sinaimg.cn/large/006UcwnJly1h7pnne0n39j305g06n74l.jpg" alt="image" width="196" data-width="196" data-height="239">

## 标准化设备坐标(Normalized Device Coordinates，NDC)
在处理完模型顶点的裁剪空间的基础上，进行透视除法(perspective division，即除w)后会得到一个长宽高均为2的正方体，这就是标准化设备坐标(NDC)。之所以边长是2是因为从原点出发三个轴的范围都在[0,1]之间。

<img src="https://tva2.sinaimg.cn/large/006UcwnJly1h7pnsyik2sj308404sjrp.jpg" alt="image" width="292" data-width="292" data-height="172">

获得NDC坐标是为了实现屏幕坐标的转换，与硬件无关。

## 背面剔除(Back-Face Culling)
这一步在NDC之后，剔除所有背对摄像机的三角面。上篇文章（GPU渲染管线）中我们讲到过模型数据中含有顶点和mesh的索引列表，列表中的三个点组成一个三角片，默认情况下：
- 三个点是顺时针排列的，认为背对摄像机
- 三个点是逆时针排列的，认为正对摄像机

关于是顺时针还是逆时针，可以通过三角形任意两边叉乘的方向判断。判断为背面则剔除，除非开启了双面渲染等设置。

## 屏幕映射(Screen Mapping)
屏幕映射将NDC中每个图元的x、y坐标转换到屏幕坐标系(Screen Coordinates, **z坐标不做任何处理**（但并不是无用的），因为屏幕是二维的。
屏幕坐标系和z坐标一起被称作窗口坐标系(Window Coordinates)。

# 光栅化
光栅化的主要流程是计算每个图元覆盖了哪些像素，并计算它们的颜色。即将屏幕空间的**图元离散化为片元**的过程，包括：
- 三角形设置
- 三角形遍历

## 三角形设置(Triangle Setup)
我们从上一个阶段获得图元的顶点信息，也就是三角面每条边的两个端点，但如果要得到整个三角网格对像素的覆盖情况，我们就必须计算每条边上的像素坐标。为了能够计算边界像素的坐标信息，我们就需要得到三角形边界的表示方式。这样一个计算三角网格表示数据的过程就叫做三角形设置。

## 三角形遍历(Triangle Traversal)
检查每个像素是否被一个三角形网格覆盖，如果覆盖的话则生成一个**片元(Fragment)**, 并使用三角网格3个顶点的顶点信息对整个覆盖区域的像素进行插值。这个阶段也被成为**扫描变换(Scan Conversion)**
经过三角形遍历我们会得到一个片元序列，但片元不等同于像素，而是包含了屏幕坐标、深度信息(通过插值得到)、顶点信息等的状态合集。

# 片元着色器(Fragment Shader)
片元着色器最主要的任务就是**着色**,光栅化阶段实际上并不会影响屏幕上每个像素的颜色值，而是会产生一系列的数据信息，用来表述一个三角网格是怎样覆盖每个像素的。而每个片元就负责存储这样一系列数据。着色有两种最常见的技术，分别是**纹理贴图**和**光照技术**。

# 输出合并(Output Operations)
这个阶段也被成为**逐片元操作**（Per-Fragment Operations），主要决定了每个片元的**可见性**(在这个阶段需要对片元进行多种测试，包括透明度测试、模板测试和深度测试等等)和片元的混合。

## **透明度测试(Alpha Test)**
这是输出合并阶段片元经历的**第一个测试**，也是一个非常简单粗暴的测试。通过片元数据，可以获取该片元的alpha值，如果alpha值小于某个数的话，则直接将该片元丢弃，不进行渲染（即只渲染透明度在某一范围内的片元），可以用来做一些树叶镂空的效果。

## **模板测试(Stencil Test)**
模板测试是输出合并阶段经历的**第二个测试**。模板测试将**模板缓冲区中的模板值**与**参考值**进行比较，可以自己配置比较的方式，比较的结果决定一个片元是否通过测试。通过模板测试的片元可以参与下一阶段的深度测试(如果开启了的话)，否则被舍弃。
<img src="https://tva3.sinaimg.cn/large/006UcwnJly1h7ppk8xshnj30rf06x75m.jpg" alt="image" width="987" data-width="987" data-height="249">

## **深度测试(Depth Test)**
深度测试是**最后一个测试**。深度测试比较了片元的深度值和已存在于深度缓冲区中的深度值，可以自己配置比较的方式，比较的结果决定一个片元是否通过深度测试。如果没有通过，需要舍弃该片元。
深度测试在正常的思维中是近处覆盖远处(深度值小覆盖深度值大，同时缓冲区内的深度值被替换成当前深度值)，但通过修改深度测试的规则，可以允许物体永远出现在前方，或仅在遮挡时显示。

## 混合(Blend)
混合操作对于半透明物体而言十分重要。如果没有开启混合功能，GPU会直接使用片元的颜色覆盖掉颜色缓冲区中的颜色。而如果开启了混合功能，GPU会取出颜色缓冲区中的颜色(目标颜色)与片元的颜色(源颜色)根据设置的混合模式进行**混合**。
对混合更好的理解是绘图软件（例如PS）中的混合模式(比如叠加、正片叠底、滤色等等)，实际上就是混合图层与下面的图层进行混合。在片元着色器的混合中，因为存在深度(z轴参数不同)，所以实际上片元也存在图层的前后关系。

> 提前深度测试(Early-z)
深度测试和模板测试是在片段着色器之后进行的，这里就存在一个问题：我们费尽千辛万苦计算了一个片元的颜色，然后它没有通过测试，被抛弃了！那我们花在这个片元上的计算岂不是就**浪费**了吗？Yes，真是这样。
提前深度测试正是在这种情况下出现的，它在顶点着色器和片元着色器之间进行，可以在片元着色器计算之前把那些无法通过深度测试的片元剔除。不过，Early-Z Culling**不是管线标准**，只是硬件厂商用来加速渲染的一种优化手段，所以在不同的硬件上会有不同的实现，而且Early-Z Culling并不保证一定有效，它需要硬件的支持。

