---
tags: ['OpenGL ES']
title: OpenGL ES-基础概念介绍
created: '2022-02-09'
categories: 视效渲染
cover: https://s2.loli.net/2022/02/23/PDswRntXlWfb42F.png
---

&emsp;&emsp;本文主要讲一些OpenGL ES和Unity Shader不同的地方。OpenGL ES比ShaderLab要底层，并且比较适合移动端和嵌入式的渲染。目前，**Android4.3以上的版本以及使用ios7的iPhone 5s都支持OpenGl ES 3.0**，并且3.0可以向后兼容2.0版本。不过在学习和实际应用中我们一般选择选2.0的版本，因为即使用户的手机是Android 4.3以上的版本，设备制造商也不一定实现了3.0API的接口。
&emsp;&emsp;我们用Java或者Kotlin来写安卓相关的代码，并用c来写着色器程序。

# 渲染管线
&emsp;&emsp;OpenGL ES的渲染管线如下所示，实际上这里漏了一个由帧缓冲区指向API的箭头（参见《OpenGL ES 3.0编程指南》p3）：
<img src="https://s2.loli.net/2022/02/21/Ajqf2KYdxDo3Hgu.png" width=800/>

用文字描述一下每块的流程，即：
1. API获得顶点数据，将顶点数据从内存中拷贝至顶点缓冲区（显存）
23. 拿到数据之后，通过**attribute通道**传递至顶点着色器，同时，纹理坐标通过**Texture通道**传递到顶点着色器和片元着色器
3. 然后，图元装配，即图元的连接方式，此步骤将顶点变换为图元
4. 光栅化：确定图元与屏幕对应的位置
5. 片元（片段）着色器：处理对应像素点的颜色值
6. 在将处理好的每个像素点的颜色值存储到帧缓存区，然后在显示器中显示
7. API：可以通过API操作顶点缓冲区、顶点着色器、纹理坐标、片段着色器

&emsp;&emsp;我们会发现相较于ShaderLab的渲染管线，OpenGL ES额外加入了纹理坐标作为API的输入之一。3.0引入了不少有关纹理的新功能，例如3D纹理、深度纹理和阴影比较、无缝立方贴图等等，将在之后提到。
&emsp;&emsp;OpenGL ES中是有几何着色器和曲面细分着色器的（至少我能找到相关的文章），在必要的3D处理场合可以使用:

<img src="https://s2.loli.net/2022/02/21/zn1Fk4NJX6CDhAI.png"/>

## 顶点、图元、片元和像素
&emsp;&emsp;这四个概念大概的关系如下所示：
<img src="https://s2.loli.net/2022/02/22/ksMJcrBoILPCpiA.png"/>
<img src="https://s2.loli.net/2022/02/23/Koa6vH3BgluT1Zq.png"/>

### 顶点
&emsp;&emsp;**顶点（Vertex**）指的就是一个图形所有的顶点，在**图元装配**环节顶点可以组合成**图元（Primitives**），图元有：
- 点精灵图元
- 线段图元
- 三角形图元

&emsp;&emsp;图元装配的过程中，对于三种图元是否只有部分在视锥体中需要采用不同的方式进行裁剪：
- 当点位于视锥体之外时：直接舍弃
- 当线段有部分位于视锥体之外时：在裁点生成新的顶点，舍弃视锥体外的顶点
- 当三角形有部分位于视锥体之外时：在裁点生成新的顶点，并连接产生新的边，舍弃视锥体外的顶点
新的顶点会被赋予相关的信息，例如法线等

### 片元
&emsp;&emsp;然而顶点和图元都是三维世界中的概念，对于最终要呈现在二维的手机屏幕上的图形来说，还需要经过**光栅化**的步骤映射到二维平面上的映射区域。投影完得到的就是**片元（Fragment**）。片元上的每个点都包含了颜色、深度和纹理数据等信息，然而片元还不是最终呈现在屏幕上的像素。

### 像素
&emsp;&emsp;在光栅化中的纹理映射之后，图元的信息转化为了**像素（Pixel**）。
&emsp;&emsp;通常一个片元对应于屏幕上的一个像素，但高分辨率的屏幕可能会用多个像素点映射到一个片元，以减少 GPU 的工作。片元和像素之间的关键区别是：虽然两者的直观印象都是的“像素”，但是**片元比像素多了许多信息，在光栅化中纹理映射之后图元信息转化为了像素**。

## 顶点着色器
&emsp;&emsp;顶点着色器的主要工作：
1. 矩阵变换位置
2. 计算光照公式生成逐顶点颜色（也可以片元着色器）
3. 生成/变换纹理坐标：片元着色器是没有办法传入属性即attribute的，可以通过顶点着色器桥接，间接将纹理坐标属性传递到片元着色器

&emsp;&emsp;顶点着色器的基本写法如下，这里实现了基本功能（将顶点从模型空间经过mvp矩阵变换到裁剪空间）。我们发现，OpenGL ES的写法是：
- 在第一行声明版本号
- 利用uniform关键字定义同一变量（常量，即不变的数据）
- 用in和out关键字来声明**顶点着色器输入变量（属性**）和**顶点着色器输出变量**。输出变量会在后续传入片元着色器中使用。
- shader语义块被放在**main函数**里
```glsl
#version 300 es
uniform mat4 u_mvpMatrix;

// attribute通道输入
in vec4 a_position;
in vec4 a_color;

// 顶点着色器的输出，之后会输入进片元着色器
out vec4 v_color

void main(){
  v_color = a_color;
  // 内建变量，处理过后的顶点数据必须写进里面
  gl_Position = u_mvpMatrix * a_position;
}
```

## 片元着色器
&emsp;&emsp;片元着色器的主要工作：
1. 计算颜色
2. 获取纹理值
3. 往像素点中填充颜色值【纹理值/颜色值】
4. 实现雾等效果

&emsp;&emsp;片元着色器的写法如下，这里简单的进行了上色：
- 第一行声明了版本号
- 第二行声明了数据精度值
- 用**in声明片元着色器输入变量**（其中v前缀表示该变量从顶点着色器获取），用**out关键字来声明输出变量**（片元颜色）
- shader语义块放在**main函数**内
```glsl
#version 300 es
precision mediump float;

in vec4 v_color;

out vec4 fragColor;
void main(){
  fragColor = v_color;
}
```
## 逐片元操作
&emsp;&emsp;逐片元操作对每个片元进行测试，按照顺序依次如下图所示：
<img src="https://s2.loli.net/2022/02/23/mDTla3joHybx1Ik.png"/>
&emsp;&emsp;部分概念已经是老生常谈，这里就简单略过了，主要说几个之前没遇到过的：
- 像素归属测试
确定帧缓冲区特定位置的像素目前是否归属OpenGL ES所有。
- 裁剪测试
确定特定的一个点是否位于OpenGL ES状态的一部分的裁剪矩阵范围内。如果位于范围外则被抛弃。
- 抖动
指的是将较大的色彩空间的图像展示到较小的色彩空间的设备上。如果没有抖动的存在会导致图像呈现不真实的效果，而抖动使用一个矩阵避免了这种效果的产生。

# OpenGL ES的坐标系
&emsp;&emsp;他的坐标系和DirectX、OpenGL、Canvas都不同，而是以屏幕中心为愿您，窗口的四角为±1的坐标所在位置：
<img src="https://s2.loli.net/2022/02/23/6oRNfSxahPc5CEL.png"/>
&emsp;&emsp;并且，即使屏幕或者窗口并不是完美的正方形（例如一般手机屏幕都是一个矩形），窗口口的四角为±1的坐标的事实并不会改变，只是被拉伸了：
<img src="https://s2.loli.net/2022/02/23/tObEmljvhqWkyeS.png"/>