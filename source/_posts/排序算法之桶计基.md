---
title: 排序算法之桶计基
tags: ['算法与数据结构','算法','计算机科学技术','面试相关']
categories: 算法与数据结构
date: '2024-03-14 21:47:16'
copyright_author: 时光
cover: geometry_glacier_httpss.mj.runklX034FNpZk_httpss.mj.runNOHRT7vJ_436f1ab3-00ce-43fc-bd27-5df52a390a4b.png
katex: true
---

在不同领域，排序算法的实现各有千秋。总体来看，排序算法大致可分为十类：

- {% label 选泡插 red %}：选择排序/Selection Sort、冒泡排序/Bubble Sort、插入排序/Insertion Sort
- {% label 快归希堆 green %}：快速排序/Quick Sort、归并排序/Merge Sort、希尔排序/Shell Sort、堆排序/Heap Sort
- {% label 桶计基 blue %}：桶排序/Bucket sort、计数排序/Counting Sort、基数排序/Radix Sort

本文将介绍第三类排序算法，它们的时间复杂度均为O(n)级别，属于“空间换时间”。

# 时间复杂度为O(n)的排序算法
## 计数排序/Counting Sort
- Stable/Out-place
- 时间复杂度：O(n+k)，k为数据的范围大小
- 空间复杂度：O(n+k)，k为数据的范围大小

计数排序是一种时间复杂度为 O(n) 的排序算法，该算法于 1954 年由 Harold H. Seward 提出。在对一定范围内的整数排序时，它的复杂度为 O(n+k)（其中 k 是整数的范围大小）。
O(n) 级的排序算法存在已久，但他们只能用于**特定的场景**。以计数排序为例，我们需要先根据待排序数据的范围构建一个**计数数组**，而如果这个范围很大（例如Ingeter.MIN_VALUA ~ Integer.MAX_VALUE）时，光是建立一个计数数组就要16G左右的内存，其开销是非常可怕的。

### 两种伪计数排序
#### 伪计数排序1.0
伪计数排序1.0的基本思路如下：
1. 确定待排序数组的范围
2. 构建计数数组
3. 遍历计数
4. 遍历输出

比如说，当我们需要对一列数组排序，而且这个数组中每个元素正好都是 [1, 9] 区间内的整数时，我们可以构建一个长度为 9 (下标为 0 ~ 8 )的数组用于**计数**。这个数组称为“**计数数组**”。计数数组的**下标**（其实是下标 - 1，因为元素范围是从 1 开始的）分别对应区间内的整数。
接下来遍历待排序的数组，将区间内每个整数**出现的次数**统计到计数数组中**对应下标的位置**（即在遍历过程中，每遇到一次该元素，计数数组在该位置上的元素 + 1）。
最后遍历计数数组，将每个元素输出，输出的次数就是对应位置记录的次数。

<img src="https://pic.leetcode-cn.com/1620707085-FdqElS-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.gif" width=500 title="图解伪计数排序1.0" />

```Java
public static void countingSort9(int[] arr) {
    // 建立长度为 9 的数组，下标 0~8 对应数字 1~9
    int[] counting = new int[9];
    // 遍历 arr 中的每个元素
    for (int element : arr) {
        // 将每个整数出现的次数统计到计数数组中对应下标的位置
        counting[element - 1]++;
    }
    int index = 0;
    // 遍历计数数组，将每个元素输出
    for (int i = 0; i < 9; i++) {
        // 输出的次数就是对应位置记录的次数
        while (counting[i] != 0) {
            arr[index++] = i + 1;
            counting[i]--;
        }
    }
}
```
伪计数排序1.0的问题在于，排序结束后的 arr 中记录的元素已经不再是最开始的那个元素了，他们只是**值相等，但却不是同一个对象**。因为我们只是记录了某个值出现的次数，但没有记录值本身。由此，我们可以衍生出改良后的**伪计数排序2.0**：

#### 伪计数排序2.0
在统计元素出现的次数时，同时把真实的元素保存到一个哈希表中，输出时，从哈希表中取真实的元素。
1. 确定待排序数组的范围
2. 构建计数数组和记录元素本身的哈希表
3. 遍历计数，填入哈希表
4. 遍历输出

算法实现如下：

```Java
public static void countingSort9(int[] arr) {
    // 建立长度为 9 的数组，下标 0~8 对应数字 1~9
    int[] counting = new int[9];
    // 记录每个下标中包含的真实元素，使用队列可以保证排序的稳定性
    HashMap<Integer, Queue<Integer>> records = new HashMap<>();
    // 遍历 arr 中的每个元素
    for (int element : arr) {
        // 将每个整数出现的次数统计到计数数组中对应下标的位置
        counting[element - 1]++;
        if (!records.containsKey(element - 1)) {
            records.put(element - 1, new LinkedList<>());
        }
        records.get(element - 1).add(element);
    }
    int index = 0;
    // 遍历计数数组，将每个元素输出
    for (int i = 0; i < 9; i++) {
        // 输出的次数就是对应位置记录的次数
        while (counting[i] != 0) {
            // 输出记录的真实元素
            arr[index++] = records.get(i).remove();
            counting[i]--;
        }
    }
}
```

但这也不是真正的计数排序。

{% tabs 计数排序的写法 %}
<!-- tab 一般来说的写法 -->
真正的计数排序的思路如下所示：
1. 确定待排序数组的范围
2. 构建计数数组
3. 遍历计数
4. 遍历待排序数组，计算出每个元素在排序完成后的位置，然后将元素赋值到对应位置

区别主要就在于最后一步，我们不需要新建哈希表，但是需要记录“排序后所在的位置”。

{% folding cyan closed, 一个例子 %}

举个例子，班上有 10 名同学：他们的考试成绩分别是：[7,8,9,7,6,7,6,8,6,6]，他们需要按照成绩从低到高坐到 0～9 共 10 个位置上。用计数排序完成这一过程需要以下几步：

- 第一步仍然是计数，统计出：4 名同学考了 6 分，3 名同学考了 7 分，2 名同学考了 8 分，1 名同学考了 9 分；
- 然后从头遍历数组：第一名同学考了 7 分，共有 4 个人比他分数低，所以第一名同学坐在 4 号位置（也就是第 5 个位置）；
- 第二名同学考了 8 分，共有 7 个人（4 + 3）比他分数低，所以第二名同学坐在 7 号位置；
- 第三名同学考了 9 分，共有 9 个人（4 + 3 + 2）比他分数低，所以第三名同学坐在 9 号位置；
- 第四名同学考了 7 分，共有 4 个人比他分数低，并且之前已经有一名考了 7 分的同学坐在了 4 号位置，所以第四名同学坐在 5 号位置。
- ...依次完成整个排序

{% endfolding %}

```Java
public static void countingSort(int[] arr) {
    // 判空及防止数组越界
    if (arr == null || arr.length <= 1) return;
    // 找到最大值，最小值
    int max = arr[0];
    int min = arr[0];
    for (int i = 1; i < arr.length; i++) {
        if (arr[i] > max) max = arr[i];
        else if (arr[i] < min) min = arr[i];
    }
    // 确定计数范围
    int range = max - min + 1;
    // 建立长度为 range 的数组，下标 0~range-1 对应数字 min~max
    int[] counting = new int[range];
    // 遍历 arr 中的每个元素
    for (int element : arr) {
        // 将每个整数出现的次数统计到计数数组中对应下标的位置，这里需要将每个元素减去 min，才能映射到 0～range-1 范围内
        counting[element - min]++;
    }
    // 记录前面比自己小的数字的总数
    int preCounts = 0;
    for (int i = 0; i < range; i++) {
        // 当前的数字比下一个数字小，累计到 preCounts 中
        preCounts += counting[i];
        // 将 counting 计算成当前数字在结果中的起始下标位置。位置 = 前面比自己小的数字的总数。
        counting[i] = preCounts - counting[i];
    }
    int[] result = new int[arr.length];
    for (int element : arr) {
        // counting[element - min] 表示此元素在结果数组中的下标
        result[counting[element - min]] = element;
        // 更新 counting[element - min]，指向此元素的下一个下标
        counting[element - min]++;
    }
    // 将结果赋值回 arr
    for (int i = 0; i < arr.length; i++) {
        arr[i] = result[i];
    }
}
```
<!-- endtab -->

<!-- tab 倒序遍历的计数排序 -->
计数排序还有一种写法，在计算元素在最终结果数组中的下标位置这一步，不是计算初始下标位置，而是计算最后一个下标位置。最后倒序遍历 arr 数组，逐个将 arr 中的元素放到最终位置上。这种写法在性能上更好一些。

```Java
public static void countingSort(int[] arr) {
    // 防止数组越界
    if (arr == null || arr.length <= 1) return;
    // 找到最大值，最小值
    int max = arr[0];
    int min = arr[0];
    for (int i = 1; i < arr.length; i++) {
        if (arr[i] > max) max = arr[i];
        else if (arr[i] < min) min = arr[i];
    }
    // 确定计数范围
    int range = max - min + 1;
    // 建立长度为 range 的数组，下标 0~range-1 对应数字 min~max
    int[] counting = new int[range];
    // 遍历 arr 中的每个元素
    for (int element : arr) {
        // 将每个整数出现的次数统计到计数数组中对应下标的位置，这里需要将每个元素减去 min，才能映射到 0～range-1 范围内
        counting[element - min]++;
    }
    // 每个元素在结果数组中的最后一个下标位置 = 前面比自己小的数字的总数 + 自己的数量 - 1。我们将 counting[0] 先减去 1，后续 counting 直接累加即可
    counting[0]--;
    for (int i = 1; i < range; i++) {
        // 将 counting 计算成当前数字在结果中的最后一个下标位置。位置 = 前面比自己小的数字的总数 + 自己的数量 - 1
        // 由于 counting[0] 已经减了 1，所以后续的减 1 可以省略。
        counting[i] += counting[i - 1];
    }
    int[] result = new int[arr.length];
    // 从后往前遍历数组，通过 counting 中记录的下标位置，将 arr 中的元素放到 result 数组中
    for (int i = arr.length - 1; i >= 0; i--) {
        // counting[arr[i] - min] 表示此元素在结果数组中的下标
        result[counting[arr[i] - min]] = arr[i];
        // 更新 counting[arr[i] - min]，指向此元素的前一个下标
        counting[arr[i] - min]--;
    }
    // 将结果赋值回 arr
    for (int i = 0; i < arr.length; i++) {
        arr[i] = result[i];
    }
}
```
<!-- endtab -->
{% endtabs %}

### 为什么计数排序与O(nlogn)级的算法不同？
计数排序之所有能够突破 O（nlogn）的限制是因为借助了辅助数组，没有进行**对比**，直接绕过了逆序对这个思路。
一个数组所有可能的排序情况可以用一颗决策树来表示，其中从根结点到叶结点之间的最长简单路径的长度，就表示比较排序算法中最坏情况下的比较次数。而树的高度

$$h ≥ \log{(n!)}$$

因此，基于对比的算法无论怎么优化都无法突破 O(nlogn) 的下界。

## 基数排序/Radix Sort
- Stable/Out-place
- 时间复杂度：O(d(n+k))，d为最大位数，k为数据的范围大小
- 空间复杂度：O(n+k)，k为数据的范围大小

<img src="https://pic.leetcode-cn.com/1618984043-EyABAp-%E5%9F%BA%E6%95%B0%E7%AE%97%E6%B3%95%20(1).gif" title="图解基数排序" />

基数排序是一种有趣的排序方式，它的核心思想是比较数字在每一“**位**”上的大小。这里的位可以称为**基数(Radix)**，也就是基数排序名称的由来。基数排序分 {%label 最高位优先法(MSD) orange%} 和  {%label 最低位优先法(LSD) orange%} 两种类型，顾名思义，一种是从最高位判断到最低位；另一种是从最低位判断到最高位。

{% folding cyan closed, 一个例子 %}
举个例子，我们对 999, 997, 866, 666 这四个数字进行MSD型基数排序，过程如下：

1. 先看第一位基数：6 比 8 小，8 比 9 小，所以 666 是最小的数字，866 是第二小的数字，暂时无法确定两个以 9 开头的数字的大小关系。
2. 再比较 9 开头的两个数字，看他们第二位基数：9 和 9 相等，暂时无法确定他们的大小关系。
3. 再比较 99 开头的两个数字，看他们的第三位基数：7 比 9 小，所以 997 小于 999
{% endfolding %}

LSD 和 MSD 哪种效率更高呢？通常来讲，LSD 比 MSD 更常用。以上面的例子为例，因为使用的是 MSD 方法，所以在第二步比较两个以 9 开头的数字时，其他基数开头的数字不得不暂时放到一边。体现在计算机中，这里会产生很多临时变量。
但在采用 LSD 进行基数排序时，每一轮遍历都可以将所有数字一视同仁，统一处理。所以 LSD 的基数排序更符合计算机的操作习惯。

{% folding cyan closed, 题外话 %}
基数排序最早是用在卡片排序机（Card Sorter）上的，一张卡片有 80 列，类似一个 80 位的整数。机器通过在卡片不同位置上穿孔表示当前基数的大小。卡片排序机的排序过程就是采用的 LSD 的基数排序。
千禧年出生的我们这一代基本没见过打孔机，因此对这个说法很陌生。现在的小朋友哪想得到以前的程序是打在卡片上拿去执行的呢？科技的发展实在是太快了。
<img src="https://64.media.tumblr.com/176622a73a1ddd3d86cd1dd010faaded/7505751830d9b53c-10/s400x600/3cafab18f61b5c558186aec6aebad324bb5695d9.png" width=500 title="homestuck中的打孔卡，这里演示了与（左）和或（右）的操作" />
<img src="https://static.righto.com/images/sorter/card.jpg" title="现实中的打孔卡" />

{% endfolding %}

暂时不考虑负数存在的情况，基数排序的一般思路如下所示：
1. 找出数组中最大的数字的位数 maxDigitLength，以此确定需要判断几位
2. 获取数组中每个数字的基数
3. 遍历 maxDigitLength 轮数组，每轮按照基数对其进行**计数排序**

结合计数排序的思想，我们可以写出：
```Java
public static void radixSort(int[] arr) {
    if (arr == null) return;
    int max = 0;
    // 一轮循环，找到待排序数组中最大的数
    for (int value : arr) {
        if (value > max) {
            max = value;
        }
    }
    // 计算最大数的位数
    int maxDigitLength = 0;
    while (max != 0) {
        maxDigitLength++;
        max /= 10;  // 削掉一位
    }
    // 使用计数排序算法对基数进行排序
    int[] counting = new int[10];
    int[] result = new int[arr.length];
    // 获取基数
    int dev = 1;
    for (int i = 0; i < maxDigitLength; i++) {
        for (int value : arr) {
            int radix = value / dev % 10;
            counting[radix]++;
        }
        for (int j = 1; j < counting.length; j++) {
            counting[j] += counting[j - 1];
        }
        // 使用倒序遍历的方式完成计数排序
        for (int j = arr.length - 1; j >= 0; j--) {
            int radix = arr[j] / dev % 10;
            result[--counting[radix]] = arr[j];
        }
        // 计数排序完成后，将结果拷贝回 arr 数组
        System.arraycopy(result, 0, arr, 0, arr.length);
        // 将计数数组重置为 0
        Arrays.fill(counting, 0);

        // 完成一轮后，排序下一位（低位）
        dev *= 10;
    }
}
```

由于计数排序是稳定的，因此基数排序也是一种**稳定**的排序算法。
但是我们还没有考虑过**负数**出现的情况，那么完整的基数排序应该是什么样的呢？在对基数进行计数排序时，申请长度为 **19** 的计数数组，用来存储 [−9,9] 这个区间内的所有整数。在把每一位基数计算出来后，加上 9，就能对应上 counting 数组的下标了。也就是说，counting 数组的下标 [0,18] 对应基数 [−9,9]。
- 当数组中存在负数时，我们就不能简单的计算数组的最大值了，而是要计算数组中**绝对值**最大的数，也就是数组中最长的数。
- 在获取基数的步骤，将计算出的基数**加上9**，使其与 counting 数组下标一一对应。

{% tabs 基数排序的写法 %}
<!-- tab MSD法 -->
```Java
public class RadixSort {
    public static void radixSort(int[] arr) {
        if (arr == null) return;
        // 找到最大值
        int max = 0;
        for (int value : arr) {
            if (Math.abs(value) > max) {
                max = Math.abs(value);
            }
        }
        // 计算最大长度
        int maxDigitLength = 0;
        while (max != 0) {
            maxDigitLength++;
            max /= 10;
        }
        radixSort(arr, 0, arr.length - 1, maxDigitLength);
    }

    // 对 arr 数组中的 [start, end] 区间进行基数排序
    private static void radixSort(int[] arr, int start, int end, int position) {
        if (start == end || position == 0) return;
        // 使用计数排序对基数进行排序
        int[] counting = new int[19];
        int[] result = new int[end - start + 1];
        int dev = (int) Math.pow(10, position - 1);
        for (int i = start; i <= end; i++) {
            // MSD, 从最高位开始
            int radix = arr[i] / dev % 10 + 9;
            counting[radix]++;
        }
        for (int j = 1; j < counting.length; j++) {
            counting[j] += counting[j - 1];
        }
        // 拷贝 counting，用于待会的递归
        int[] countingCopy = new int[counting.length];
        System.arraycopy(counting, 0, countingCopy, 0, counting.length);
        for (int i = end; i >= start; i--) {
            int radix = arr[i] / dev % 10 + 9;
            result[--counting[radix]] = arr[i];
        }
        // 计数排序完成后，将结果拷贝回 arr 数组
        System.arraycopy(result, 0, arr, start, result.length);
        // 对 [start, end] 区间内的每一位基数进行递归排序
        for (int i = 0; i < counting.length; i++) {
            radixSort(arr, i == 0 ? start : start + countingCopy[i - 1], start + countingCopy[i] - 1, position - 1);
        }
    }

}
```
<!-- endtab -->

<!-- tab LSD法 -->
```Java
public class RadixSort {
    public static void radixSort(int[] arr) {
        if (arr == null) return;
        // 找出最长的数
        int max = 0;
        for (int value : arr) {
            if (Math.abs(value) > max) {
                max = Math.abs(value);
            }
        }
        // 计算最长数字的长度
        int maxDigitLength = 0;
        while (max != 0) {
            maxDigitLength++;
            max /= 10;
        }
        // 使用计数排序算法对基数进行排序，下标 [0, 18] 对应基数 [-9, 9]
        int[] counting = new int[19];
        int[] result = new int[arr.length];
        int dev = 1;
        for (int i = 0; i < maxDigitLength; i++) {
            for (int value : arr) {
                // 下标调整
                int radix = value / dev % 10 + 9;
                counting[radix]++;
            }
            for (int j = 1; j < counting.length; j++) {
                counting[j] += counting[j - 1];
            }
            // 使用倒序遍历的方式完成计数排序
            for (int j = arr.length - 1; j >= 0; j--) {
                // 下标调整
                int radix = arr[j] / dev % 10 + 9;
                result[--counting[radix]] = arr[j];
            }
            // 计数排序完成后，将结果拷贝回 arr 数组
            System.arraycopy(result, 0, arr, 0, arr.length);
            // 将计数数组重置为 0
            Arrays.fill(counting, 0);
            dev *= 10;
        }
    }
}
```
<!-- endtab -->
{% endtabs %}

## 桶排序/Bucket Sort
- Stable/Out-place
- 时间复杂度：O(n)，需要注意的是此处n的常数项较大
- 空间复杂度：O(n)，k为数据的范围大小

<img src="https://miro.medium.com/v2/resize:fit:800/1*_2l-UN7jcQp54hgazT6iVA.gif" title="图解桶排序" />

桶排序的思想是：

1. 将区间划分为 n 个相同大小的子区间，每个子区间称为一个**桶**（bucket）
2. 遍历数组，将每个数字装入桶中
3. 对每个桶内的数字单独排序，这里需要**采用其他排序算法**，如插入、归并、快排等
4. 最后按照顺序将所有桶内的数字合并起来

桶排序在实际工作中的应用较少，不仅因为它需要借助于其他排序算法，还因为桶排序算法基于一个假设：所有输入数据都**服从均匀分布**，也就是说输入数据应该尽可能地均匀分布在每个桶中。只有这个假设成立时，桶排序运行效率才比较高（否则可能出现空的桶）。在最差的情况下，所有数据都会被装入**同一个桶**中，此时桶排序算法只会徒增一轮遍历。

使用桶排序算法时，我们需要考虑两个因素，这两个因素会直接影响到桶排序的内存和效率：
- **设置多少个桶比较合适？**
桶的数量过少，会导致单个桶内的数字过多，桶排序的时间复杂度就会在很大程度上受桶内排序算法的影响。桶的数量过多，占用的内存就会较大，并且会出现较多的空桶，影响遍历桶的效率。具体设置多少个桶需要根据实际情况决定。

- **桶采用哪种数据结构？**
如果将桶的数据结构设置为**数组**，那么每个桶的长度必须设置为待排序数组的长度，因为我们需要做好最坏的打算，即所有的数字都被装入了同一个桶中，所以这种方案的**空间复杂度会很高**。
那么是不是将桶的数据结构设置为**链表**就更好呢？使用链表有一个好处，即所有桶的总长度刚好等于待排序数组的长度，不会造成内存浪费。但使用链表也会有一些问题，我们待会一一分析。

不管是哪种方法实现的桶排序，首先都要找到待排序元素的范围（和计数排序一样）：

```Java
public static void bucketSort(int[] arr) {
    // 判空及防止数组越界
    if (arr == null || arr.length <= 1) return;
    // 找到最大值，最小值
    int max = arr[0];
    int min = arr[0];
    for (int i = 1; i < arr.length; i++) {
        if (arr[i] > max) max = arr[i];
        else if (arr[i] < min) min = arr[i];
    }
    // 确定取值范围
    int range = max - min;
}
```

然后，我们再根据范围划分桶，并实现装桶和排序的操作。

{% tabs 桶排序的写法 %}
<!-- tab 数组桶 -->
在下面代码的例子中，我们将桶的数量设置为 100 个，这个值可以根据输入数据的实际情况修改。所有的桶是一个**二维数组**，第一个维度代表桶的**编号**，第二个维度代表桶内的**数字**，每个桶中都有一组数字。
装桶时需要做一些简单的运算：先通过第一步找到的取值范围计算出每个桶之间的间距，再通过当前数字与最小值的距离除以间距计算出桶的编号，最后根据编号把当前数字放入对应的桶中。
装桶完成后，借助其他排序算法（如下面代码中使用的插入排序）对每个桶内的数字进行单独排序，这就是以数组作为桶实现的桶排序。
下面代码做了一些优化，我们在开始时声明时所有的数组都为**空**，当需要添加数字时，不断对桶数组进行**扩容**（add方法），避免在开始时创建大量长度为待排序元素的数组，节省内存空间。
不过需要注意的是，数组扩容是时间换空间的行为，过程比较耗时。

```Java
public static void bucketSort(int[] arr) {
    // 判空及防止数组越界
    if (arr == null || arr.length <= 1) return;
    // 找到最大值，最小值
    int max = arr[0];
    int min = arr[0];
    for (int i = 1; i < arr.length; i++) {
        if (arr[i] > max) max = arr[i];
        else if (arr[i] < min) min = arr[i];
    }
    // 确定取值范围
    int range = max - min;
    // 设置桶的数量，这里我们设置为 100 个，可以根据实际情况修改。
    int bucketAmount = 100;
    // 桶和桶之间的间距
    double gap = range * 1.0 / (bucketAmount - 1);
    // 用二维数组来装桶，第一个维度是桶的编号，第二个维度是桶中的数字。初始化长度为 0
    int[][] buckets = new int[bucketAmount][];
    // ---装桶---
    for (int value : arr) {
        // 找到 value 属于哪个桶
        int index = (int) ((value - min) / gap);
        buckets[index] = add(buckets[index], value);
    }
    int index = 0;
    // ---排序---
    // 对每个桶内的数字进行单独排序
    for (int i = 0; i < bucketAmount; i++) {
        if (buckets[i] == null || buckets[i].length == 0) continue;
        // 这里需要结合其他排序算法，例如：插入排序
        insertSort(buckets[i]);
        // 排序完成后将桶内的结果收集起来
        System.arraycopy(buckets[i], 0, arr, index, buckets[i].length);
        index += buckets[i].length;
    }
}

// 数组扩容
public static int[] add(int[] arr, int num) {
    if (arr == null) return new int[]{num};
    int[] newArr = Arrays.copyOf(arr, arr.length + 1);
    newArr[arr.length] = num;
    return newArr;
}
```
<!-- endtab -->

<!-- tab 链表桶 -->
链表桶与数组桶的整体思路类似，不过得益于链表的数据结构特性，我们不需要额外编写“扩容方法”，装桶时**不会有额外的空间浪费**。
但对于链表来说，因为链表内元素在内存中并不像数组那样是逐个连在一起的，因此装桶后的**排序会比较耗时**。访问 LinkedList 链表时，get 和 set 方法都需要从链表头部开始，逐个向后寻找结点，效率较低。
使用链表排序还有一个问题：由于链表中**不能存储基本类型**，所以我们不得不将链表类型声明为 LinkedList<Integer>，int 和 Integer 互相转换的过程被称为 「**装箱**」和「**拆箱**」，这也会造成额外的性能消耗。
```Java
public static void bucketSort(int[] arr) {
    // 判空及防止数组越界
    if (arr == null || arr.length <= 1) return;
    // 找到最大值，最小值
    int max = arr[0];
    int min = arr[0];
    for (int i = 1; i < arr.length; i++) {
        if (arr[i] > max) max = arr[i];
        else if (arr[i] < min) min = arr[i];
    }
    // 确定取值范围
    int range = max - min;
    // 设置桶的数量，这里我们设置为 100 个，可以任意修改。
    int bucketAmount = 100;
    // 桶和桶之间的间距
    double gap = range * 1.0 / (bucketAmount - 1);
    HashMap<Integer, LinkedList<Integer>> buckets = new HashMap<>();
    // 装桶
    for (int value : arr) {
        // 找到 value 属于哪个桶
        int index = (int) ((value - min) / gap);
        if (!buckets.containsKey(index)) {
            buckets.put(index, new LinkedList<>());
        }
        buckets.get(index).add(value);
    }
    int index = 0;
    // 对每个桶内的数字进行单独排序
    for (int i = 0; i < bucketAmount; i++) {
        LinkedList<Integer> bucket = buckets.get(i);
        if (bucket == null) continue;
        // 这里需要结合其他排序算法，例如：插入排序
        insertSort(bucket);
        // 排序完成后将桶内的结果收集起来
        for (int num : bucket) {
            arr[index++] = num;
        }
    }
}
```
<!-- endtab -->

<!-- tab 折中：装桶链表、排序数组 -->
通过前面的分析，我们可以看出数组桶和链表桶各有利弊：
- 数组桶在装桶时如果初始化每个桶长度为0，扩容时速度较慢。在装桶时初始化每个桶长度为n，产生大量内存消耗。但数组桶的排序速度较快；
- 链表桶装桶时速度较快，无额外内存消耗，但排序速度较慢。

那如果我们各取所长，用链表装桶、数组排序呢？

```Java
public static void bucketSort(int[] arr) {
    // 判空及防止数组越界
    if (arr == null || arr.length <= 1) return;
    // 找到最大值，最小值
    int max = arr[0];
    int min = arr[0];
    for (int i = 1; i < arr.length; i++) {
        if (arr[i] > max) max = arr[i];
        else if (arr[i] < min) min = arr[i];
    }
    // 确定取值范围
    int range = max - min;
    // 设置桶的数量，这里我们设置为 100 个，可以任意修改。
    int bucketAmount = 100;
    // 桶和桶之间的间距
    double gap = range * 1.0 / (bucketAmount - 1);
    HashMap<Integer, Queue<Integer>> buckets = new HashMap<>();
    // 装桶
    for (int value : arr) {
        // 找到 value 属于哪个桶
        int index = (int) ((value - min) / gap);
        if (!buckets.containsKey(index)) {
            buckets.put(index, new LinkedList<>());
        }
        buckets.get(index).add(value);
    }
    int index = 0;
    // 对每个桶内的数字进行单独排序
    for (int i = 0; i < bucketAmount; i++) {
        Queue<Integer> bucket = buckets.get(i);
        if (bucket == null) continue;
        // 将链表转换为数组，提升排序性能
        int[] arrInBucket = bucket.stream().mapToInt(Integer::intValue).toArray();
        // 这里需要结合其他排序算法，例如：插入排序
        insertSort(arrInBucket);
        // 排序完成后将桶内的结果收集起来
        System.arraycopy(arrInBucket, 0, arr, index, arrInBucket.length);
        index += arrInBucket.length;
    }
}
```
我们通过
```Java
int[] arrInBucket = bucket.stream().mapToInt(Integer::intValue).toArray();
```
这行代码将链表转换为数组，代价是这里多了一个**中间变量** arrInBucket，它会占用 O(n) 的空间，并且 LinkedList 转换为 int[] 的过程需要遍历一次数组，这会增加 O(n) 的时间。
<!-- endtab -->
{% endtabs %}

### 桶排序 VS (计数排序 || 基数排序)

关于计数排序与基数排序是否是桶排序的一种特殊情况：
- **桶排序 VS 计数排序**
虽然计数排序也有划分子区间的操作，但是计数排序在统计了每个数字出现的次数后，主要是通过计算每个数字在排序完成后的数组中的最终位置来完成排序，并没有真正把数字装到桶中。而桶排序则是将所有数字装入了桶里，最后从桶里取出每个数字。桶排序的过程比较像我们在计数排序的文章中介绍的「伪计数排序 2.0 版本」。

- **桶排序 VS 基数排序**
如果把基数排序看作桶排序，那么基数排序的过程就是不断地装桶，基数排序并没有桶内排序这一步。而桶排序主要分为两步：装桶和桶内排序，桶内排序时需要借助其他排序算法。

并且桶排序基于输入数据均匀分布的假设，计数排序和基数排序则没有这样的限制。

因此，桶排序和这两种算法还是有明显区别的，在《算法导论》一书中也没有说计数排序和基数排序是桶排序的特例。

| 复习周期 |   1d   |   2d   |   7d   |   21d  |
|  :----: | :----: | :----: | :----: | :----: |
|  /      | <i class="fa-solid fa-circle-check" style="color:green"></i> |        |        |        |