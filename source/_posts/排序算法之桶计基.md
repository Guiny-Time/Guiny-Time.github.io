---
title: 排序算法之桶计基
tags: ['算法与数据结构','算法','计算机科学技术','面试相关']
categories: 算法与数据结构
date: '2024-03-14 21:47:16'
copyright_author: 时光
cover: geometry_glacier_httpss.mj.runklX034FNpZk_httpss.mj.runNOHRT7vJ_436f1ab3-00ce-43fc-bd27-5df52a390a4b.png
katex: true
---

在不同领域，排序算法的实现各有千秋。总体来看，排序算法大致可分为十类：

- {% label 选泡插 red %}：选择排序/Selection Sort、冒泡排序/Bubble Sort、插入排序/Insertion Sort
- {% label 快归希堆 green %}：快速排序/Quick Sort、归并排序/Merge Sort、希尔排序/Shell Sort、堆排序/Heap Sort
- {% label 桶计基 blue %}：桶排序/Bucket sort、计数排序/Counting Sort、基数排序/Radix Sort

本文将介绍第三类排序算法，它们的时间复杂度均为O(n)级别，属于“空间换时间”。

# 时间复杂度为O(n)的排序算法
## 计数排序/Counting Sort
- Stable/Out-place
- 时间复杂度：O(n+k)，k为数据的范围大小
- 空间复杂度：O(n+k)，k为数据的范围大小

计数排序是一种时间复杂度为 O(n) 的排序算法，该算法于 1954 年由 Harold H. Seward 提出。在对一定范围内的整数排序时，它的复杂度为 O(n+k)（其中 k 是整数的范围大小）。
O(n) 级的排序算法存在已久，但他们只能用于**特定的场景**。以计数排序为例，我们需要先根据待排序数据的范围构建一个**计数数组**，而如果这个范围很大（例如Ingeter.MIN_VALUA ~ Integer.MAX_VALUE）时，光是建立一个计数数组就要16G左右的内存，其开销是非常可怕的。

### 两种伪计数排序
#### 伪计数排序1.0
伪计数排序1.0的基本思路如下：
1. 确定待排序数组的范围
2. 构建计数数组
3. 遍历计数
4. 遍历输出

比如说，当我们需要对一列数组排序，而且这个数组中每个元素正好都是 [1, 9] 区间内的整数时，我们可以构建一个长度为 9 (下标为 0 ~ 8 )的数组用于**计数**。这个数组称为“**计数数组**”。计数数组的**下标**（其实是下标 - 1，因为元素范围是从 1 开始的）分别对应区间内的整数。
接下来遍历待排序的数组，将区间内每个整数**出现的次数**统计到计数数组中**对应下标的位置**（即在遍历过程中，每遇到一次该元素，计数数组在该位置上的元素 + 1）。
最后遍历计数数组，将每个元素输出，输出的次数就是对应位置记录的次数。

<img src="https://pic.leetcode-cn.com/1620707085-FdqElS-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.gif" width=500 title="图解伪计数排序1.0" />

```Java
public static void countingSort9(int[] arr) {
    // 建立长度为 9 的数组，下标 0~8 对应数字 1~9
    int[] counting = new int[9];
    // 遍历 arr 中的每个元素
    for (int element : arr) {
        // 将每个整数出现的次数统计到计数数组中对应下标的位置
        counting[element - 1]++;
    }
    int index = 0;
    // 遍历计数数组，将每个元素输出
    for (int i = 0; i < 9; i++) {
        // 输出的次数就是对应位置记录的次数
        while (counting[i] != 0) {
            arr[index++] = i + 1;
            counting[i]--;
        }
    }
}
```
伪计数排序1.0的问题在于，排序结束后的 arr 中记录的元素已经不再是最开始的那个元素了，他们只是**值相等，但却不是同一个对象**。因为我们只是记录了某个值出现的次数，但没有记录值本身。由此，我们可以衍生出改良后的**伪计数排序2.0**：

#### 伪计数排序2.0
在统计元素出现的次数时，同时把真实的元素保存到一个哈希表中，输出时，从哈希表中取真实的元素。
1. 确定待排序数组的范围
2. 构建计数数组和记录元素本身的哈希表
3. 遍历计数，填入哈希表
4. 遍历输出

算法实现如下：

```Java
public static void countingSort9(int[] arr) {
    // 建立长度为 9 的数组，下标 0~8 对应数字 1~9
    int[] counting = new int[9];
    // 记录每个下标中包含的真实元素，使用队列可以保证排序的稳定性
    HashMap<Integer, Queue<Integer>> records = new HashMap<>();
    // 遍历 arr 中的每个元素
    for (int element : arr) {
        // 将每个整数出现的次数统计到计数数组中对应下标的位置
        counting[element - 1]++;
        if (!records.containsKey(element - 1)) {
            records.put(element - 1, new LinkedList<>());
        }
        records.get(element - 1).add(element);
    }
    int index = 0;
    // 遍历计数数组，将每个元素输出
    for (int i = 0; i < 9; i++) {
        // 输出的次数就是对应位置记录的次数
        while (counting[i] != 0) {
            // 输出记录的真实元素
            arr[index++] = records.get(i).remove();
            counting[i]--;
        }
    }
}
```

但这也不是真正的计数排序。

{% tabs 计数排序的写法 %}
<!-- tab 一般来说的写法 -->
真正的计数排序的思路如下所示：
1. 确定待排序数组的范围
2. 构建计数数组
3. 遍历计数
4. 遍历待排序数组，计算出每个元素在排序完成后的位置，然后将元素赋值到对应位置

区别主要就在于最后一步，我们不需要新建哈希表，但是需要记录“排序后所在的位置”。

{% folding cyan closed, 一个例子 %}

举个例子，班上有 10 名同学：他们的考试成绩分别是：[7,8,9,7,6,7,6,8,6,6]，他们需要按照成绩从低到高坐到 0～9 共 10 个位置上。用计数排序完成这一过程需要以下几步：

- 第一步仍然是计数，统计出：4 名同学考了 6 分，3 名同学考了 7 分，2 名同学考了 8 分，1 名同学考了 9 分；
- 然后从头遍历数组：第一名同学考了 7 分，共有 4 个人比他分数低，所以第一名同学坐在 4 号位置（也就是第 5 个位置）；
- 第二名同学考了 8 分，共有 7 个人（4 + 3）比他分数低，所以第二名同学坐在 7 号位置；
- 第三名同学考了 9 分，共有 9 个人（4 + 3 + 2）比他分数低，所以第三名同学坐在 9 号位置；
- 第四名同学考了 7 分，共有 4 个人比他分数低，并且之前已经有一名考了 7 分的同学坐在了 4 号位置，所以第四名同学坐在 5 号位置。
- ...依次完成整个排序

{% endfolding %}

```Java
public static void countingSort(int[] arr) {
    // 判空及防止数组越界
    if (arr == null || arr.length <= 1) return;
    // 找到最大值，最小值
    int max = arr[0];
    int min = arr[0];
    for (int i = 1; i < arr.length; i++) {
        if (arr[i] > max) max = arr[i];
        else if (arr[i] < min) min = arr[i];
    }
    // 确定计数范围
    int range = max - min + 1;
    // 建立长度为 range 的数组，下标 0~range-1 对应数字 min~max
    int[] counting = new int[range];
    // 遍历 arr 中的每个元素
    for (int element : arr) {
        // 将每个整数出现的次数统计到计数数组中对应下标的位置，这里需要将每个元素减去 min，才能映射到 0～range-1 范围内
        counting[element - min]++;
    }
    // 记录前面比自己小的数字的总数
    int preCounts = 0;
    for (int i = 0; i < range; i++) {
        // 当前的数字比下一个数字小，累计到 preCounts 中
        preCounts += counting[i];
        // 将 counting 计算成当前数字在结果中的起始下标位置。位置 = 前面比自己小的数字的总数。
        counting[i] = preCounts - counting[i];
    }
    int[] result = new int[arr.length];
    for (int element : arr) {
        // counting[element - min] 表示此元素在结果数组中的下标
        result[counting[element - min]] = element;
        // 更新 counting[element - min]，指向此元素的下一个下标
        counting[element - min]++;
    }
    // 将结果赋值回 arr
    for (int i = 0; i < arr.length; i++) {
        arr[i] = result[i];
    }
}
```
<!-- endtab -->

<!-- tab 倒序遍历的计数排序 -->
计数排序还有一种写法，在计算元素在最终结果数组中的下标位置这一步，不是计算初始下标位置，而是计算最后一个下标位置。最后倒序遍历 arr 数组，逐个将 arr 中的元素放到最终位置上。这种写法在性能上更好一些。

```Java
public static void countingSort(int[] arr) {
    // 防止数组越界
    if (arr == null || arr.length <= 1) return;
    // 找到最大值，最小值
    int max = arr[0];
    int min = arr[0];
    for (int i = 1; i < arr.length; i++) {
        if (arr[i] > max) max = arr[i];
        else if (arr[i] < min) min = arr[i];
    }
    // 确定计数范围
    int range = max - min + 1;
    // 建立长度为 range 的数组，下标 0~range-1 对应数字 min~max
    int[] counting = new int[range];
    // 遍历 arr 中的每个元素
    for (int element : arr) {
        // 将每个整数出现的次数统计到计数数组中对应下标的位置，这里需要将每个元素减去 min，才能映射到 0～range-1 范围内
        counting[element - min]++;
    }
    // 每个元素在结果数组中的最后一个下标位置 = 前面比自己小的数字的总数 + 自己的数量 - 1。我们将 counting[0] 先减去 1，后续 counting 直接累加即可
    counting[0]--;
    for (int i = 1; i < range; i++) {
        // 将 counting 计算成当前数字在结果中的最后一个下标位置。位置 = 前面比自己小的数字的总数 + 自己的数量 - 1
        // 由于 counting[0] 已经减了 1，所以后续的减 1 可以省略。
        counting[i] += counting[i - 1];
    }
    int[] result = new int[arr.length];
    // 从后往前遍历数组，通过 counting 中记录的下标位置，将 arr 中的元素放到 result 数组中
    for (int i = arr.length - 1; i >= 0; i--) {
        // counting[arr[i] - min] 表示此元素在结果数组中的下标
        result[counting[arr[i] - min]] = arr[i];
        // 更新 counting[arr[i] - min]，指向此元素的前一个下标
        counting[arr[i] - min]--;
    }
    // 将结果赋值回 arr
    for (int i = 0; i < arr.length; i++) {
        arr[i] = result[i];
    }
}
```
<!-- endtab -->
{% endtabs %}

### 为什么计数排序与O(nlogn)级的算法不同？
计数排序之所有能够突破 O（nlogn）的限制是因为借助了辅助数组，没有进行**对比**，直接绕过了逆序对这个思路。
一个数组所有可能的排序情况可以用一颗决策树来表示，其中从根结点到叶结点之间的最长简单路径的长度，就表示比较排序算法中最坏情况下的比较次数。而树的高度

$$h ≥ \log{(n!)}$$

因此，基于对比的算法无论怎么优化都无法突破 O(nlogn) 的下界。

## 基数排序/Radix Sort


## 桶排序/Bucket Sort