---
title: §1-1渲染流水线
date: 2021-07-13
tags: ['渲染管线', '计算机图形学']
categories: UnityShader
cover: https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/20211109234019.png
---

<img src="https://raw.githubusercontent.com/Guiny-Time/PictureBed/main/DUJU%24%40WJJ1S(5%7D%7E%40%25JHPB3D.png"/>

# 渲染流水线的整体流程

分为三个主要的阶段：
## 应用阶段（Application）
处理场所：CPU
主要流程：

- 准备好场景数据
- 颗粒度剔除等操作
- 加载数据到显存
- 设置渲染状态
- 调用DrawCall
- **输出渲染图元**(Rendering Primitives)作为几何阶段的输入
### **粗粒度剔除**
指的是剔除掉被遮挡住或者在屏幕外的不在摄像机范围内不需要被渲染的元素。对他们进行渲染是浪费时间和性能的，所以要先剔除掉这部分元素以节省接下来的时间。
### **加载数据到显存**
在应用阶段，数据会先从硬盘加载到RAM中，随后网格、纹理等数据又被加载到显存上。加载到显存上之后，数据就会被移除。
之所以这么做是因为GPU访问显存的速度比访问前两者更快，而且多数显卡可能无法直接访问RAM。
### **设置渲染状态**
就是针对不同的网格，使用不同的顶点着色器(Vertex Shader)、不同的片元着色器(Fragment Shader)、不同的纹理进行渲染，是渲染的准备工作。
### **调用DrawCall**
DrawCall本质上是CPU向GPU传递的命令，CPU告诉GPU下一个渲染谁，GPU接收命令之后开始渲染。这是一个不停进行的过程，但过多drawCall会让操作变慢，因为GPU的处理速度比CPU快很多。

## 几何阶段（Geometry）
处理场所：GPU
主要流程：
- 逐顶点操作(顶点着色器)
- 曲面细分(曲面细分着色器，**可选**)
- 逐多边形操作(几何着色器，**可选**)
- 顶点裁剪(删掉屏幕外的部分)
- 屏幕映射(输出二维坐标)
- **输出屏幕空间的顶点信息**为光栅化阶段的输入
### 逐顶点操作
顶点着色使用了顶点着色器，顶点着色器对每个顶点进行操作，但不知道顶点之间彼此的联系，这一阶段十分快速
顶点着色器主要的两个功能是**坐标变换**和**逐顶点光照**
>- **坐标变换**
> 将顶点的模型坐标转换到齐次裁剪空间，再由硬件做透视除法后最终得到设备坐标
>- **逐顶点光照**
> 计算输出顶点的颜色
### **可选处理**
 主要是几种着色器的选择。它们不是必须的。
>- **曲面细分着色器(Tessellation Shader)**
> 用于细分图元
>- **几何着色器(Geometry Shader)**
> 用于逐图元着色或产生更多的图元
### **裁剪(Clipping)**
针对部分在摄像机范围外的图形进行裁剪的处理，使用一些新的顶点来代替被裁剪的部分
这样能节省资源，你可以自定义裁剪配置以获得最优化体验
### **屏幕映射(Screen Mapping)**
屏幕映射将每个图元的x、y坐标转换到屏幕坐标系(Screen Coordinates, 并不考虑z轴，因为屏幕是二维的，没有必要浪费资源)
屏幕坐标系和z坐标一起被称作窗口坐标系(Window Coordinates)

## 光栅化阶段
处理场所：GPU
主要流程（计算每个图元覆盖了哪些像素，并计算它们的颜色）：
- 三角形(点/线)设置(将二维坐标组装成三角形)
- 三角形遍历
- 片元着色器

### **三角形设置(Triangle Setup)**
计算三角网格表示数据的过程，得到三角网格对像素的覆盖情况
### **三角形遍历(Triangle Traversal)**
检查每个像素是否被一个三角形网格覆盖，如果覆盖的话则生成一个**片元(Fragment)**, 这个阶段也被成为**扫描变换(Scan Conversion)**
经过三角形遍历我们会得到一个片元序列，片元不等同于像素，而是包含了屏幕坐标、深度信息(通过插值得到)、顶点信息等的状态合集
### **逐片元操作(Per-Fragment Operations)**
在这个阶段会使用到片元着色器(Fragment Shader), 片元着色器会计算每个片元的输出颜色。这个操作也被成为输出合并阶段(Output Operations)，主要决定了每个片元的可见性(在这个阶段需要对片元进行多种测试，如模板测试和深度测试等等)和片元的混合
>- **模板测试(Stencil Test)**
> 模板测试将**模板缓冲区中的模板值**与**参考值**进行比较，可以自己配置比较的方式，比较的结果决定一个片元是否通过测试。通过模板测试的片元可以参与下一阶段的深度测试(如果开启了的话)，否则被舍弃
>- **深度测试(Depth Test)**
> 深度测试比较了片元的深度值和已存在于深度缓冲区中的深度值，可以自己配置比较的方式，比较的结果决定一个片元是否通过深度测试。如果没有通过，需要舍弃该片元
深度测试在正常的思维中是近处覆盖远处(深度值小覆盖深度值大，同时缓冲区内的深度值被替换成当前深度值)
>- **混合(Blend)**
> 混合操作对于半透明物体而言十分重要。如果没有开启混合功能，GPU会直接使用片元的颜色覆盖掉颜色缓冲区中的颜色。而如果开启了混合功能，GPU会取出颜色缓冲区中的颜色(目标颜色)与片元的颜色(源颜色)进行插值混合
对混合更好的理解是PS或者Sai2中的混合模式(比如叠加、正片叠底、滤色等等)，实际上就是混合图层与下面的图层进行混合。在片元着色器的混合中，因为存在深度(z轴参数不同)，所以实际上片元也存在图层的前后关系

## 后处理
简单来说就是屏幕的后期处理，在图像已经渲染完之后，在屏幕前加上了“滤镜”。
经典的后处理比如Unity的Post-Processing，提供了多种多样的处理类型，这里不再细说









