---
title: LD49复盘：游戏中的观察者模式
tags: ['游戏编程','经验分享','项目复盘','Unity']
categories: 项目复盘
date: '2021-10-07'
updated: '2021-10-10'
copyright_author: 时光
cover: https://observer.com/wp-content/uploads/sites/2/2022/05/ObserverBannerNocturnal.png
---

Ludum Dare 49圆满结束了，我们的《绝地天通(Babel Blocks)》最终取得了1413名，放在三千多个参赛作品中也还是不错的！欢迎大家试玩我们的游戏：https://guinytime.itch.io/babel-blocks

在此我想对我在本次开发中负责的模块做一些复盘。UI部分已经是老生常谈了，我想聊聊我在开发中用到的观察者模式。

# 从C#的event关键字说起
C#将观察者模式集成到了event上，而event是对于**委托**（delegate）的一种更安全的封装方式（只能作为成员存在于类/接口或结构体中），程序员无法在类外部赋值或调用事件，这使得委托的使用更加安全。
> C# event 是一种成员，用于将特定的事件通知发送给订阅者。事件通常用于实现**观察者模式**，它允许一个对象将状态的变化通知其他对象，而不需要知道这些对象的细节。
事件基本上说是一个用户操作，如按键、点击、鼠标移动等等，或者是一些提示信息，如系统生成的通知。应用程序需要在事件发生时响应事件。

## 使用event实现一些基本功能
事件通过以下方式进行声明：
```C#
// 事件对应的委托类型（以无参无返回值为例）
public delegate void onPlayerHurt();
// 访问修饰符 event 委托类型 事件名；
public event onPlayerHurt playerHurtEvent;
```

事件必须位于类/接口/结构体中，例如声明一个用于处理事件业务逻辑的发布者类PlayerHurtEvent：

```C#
public class PlayerHurtEvent{
    public delegate void onPlayerHurt();
    public event onPlayerHurt playerHurtEvent;

    // 触发事件的方法，因为无法在外部直接触发事件（委托可以），因此需要加一层封装
    // 这是一个受保护的方法，使用 ?.Invoke 语法来确保只有在有订阅者时才调用事件。
    protected virtual void OnPlayerHurtEvent()
    {
        playerHurtEvent?.Invoke();
    }

    // 模拟业务逻辑过程并触发事件
    public void StartProcess()
    {
        Console.WriteLine("触发事件");
        // 业务逻辑完成，触发事件
        OnPlayerHurtEvent();
    }
}
```

观察者（订阅者）类：

```C#
// 订阅者类
public class EventSubscriber
{
    // 为事件添加回调函数
    public void Subscribe(PlayerHurtEvent process)
    {
        // 取消事件用 -= 就行
        process.playerHurtEvent += Process_ProcessCompleted;
    }
    // 具体的回调函数
    private void Process_ProcessCompleted()
    {
        Console.WriteLine("订阅者收到事件触发，处理相关逻辑");
        // ......
    }
}
```

在具体的应用场景中，可能是：

```C#
class Program
{
    static void Main(string[] args)
    {
        PlayerHurtEvent process = new PlayerHurtEvent();
        EventSubscriber subscriber = new EventSubscriber();

        // 订阅事件
        subscriber.Subscribe(process);

        // 启动过程
        process.StartProcess();
    }
}
```

- **优点**
  1. **解耦**
    - 观察者与主题是松耦合的，便于扩展。
    - 增加新的观察者无需修改发布者。
  2. **扩展性好**
    - 新的功能只需增加观察者即可，不需要改变原有代码。
  3. **灵活性高**
    - 支持动态注册和移除观察者。
- **缺点**
  1. **复杂性增加**
    - 对于大量观察者的管理和通知机制需要谨慎，可能增加复杂度。
  2. **性能问题**
    - 当观察者数量较多时，通知过程可能影响性能，因此一个可行的方向是将订阅者分成更小的组，减少需要通知的订阅者的数量。
  3. **可能产生循环依赖**
    - 如果观察者和主题之间的关系处理不当，可能出现循环依赖，导致难以调试。

# 结合中介者模式的观察者模式
在实际开发中，我们可能会采用**中介者**+**观察者**的模式实现事件管理，通过中介者（如下文中的EventCenter）统一管理观察者和通知，进一步降低耦合。
这次的Ludum Dare 49我们开发的游戏《Bable Block》中我使用了hll学长的代码，其中 EventCenter 的部分被我用来实现了**底部广播**的功能。底部广播由一个定时器触发，每隔10秒钟更新广播的内容，实现新闻联播中底部新闻的效果（我认为这样可以使游戏更**幽默**一些，因为LD49的评分维度有幽默一项）。

## EventCenter
EventCenter包含了数项基本功能，并通过字典来存储事件和事件对应的需要触发的订阅。基本功能包括：
- 增加事件监听
- 移除事件监听
- 触发事件
- 清空事件和订阅

```C#
using System.Collections.Generic;
using UnityEngine.Events;

public class EventInfo
{
    public UnityAction actions;

    public EventInfo(UnityAction action)
    {
        actions += action;
    }
}

/// <summary>
/// 事件中心 单例模式对象
/// 1.Dictionary
/// 2.委托
/// 3.观察者设计模式
/// 4.泛型
/// </summary>
public class EventCenter : BaseManager<EventCenter>
{
    //key —— 事件的名字（比如：怪物死亡，玩家死亡，通关 等等）
    //value —— 对应的是 监听这个事件 对应的委托函数们
    private Dictionary<string, EventInfo> eventDic = new Dictionary<string, EventInfo>();

    /// <summary>
    /// 监听不需要参数传递的事件
    /// </summary>
    /// <param name="name">事件的名字</param>
    /// <param name="action">准备用来处理事件 的委托函数</param>
    public void AddEventListener(string name, UnityAction action)
    {
        //有没有对应的事件监听
        //有的情况
        if (eventDic.ContainsKey(name))
        {
            (eventDic[name]).actions += action;
        }
        //没有的情况
        else
        {
            eventDic.Add(name, new EventInfo(action));
        }
    }


    /// <summary>
    /// 移除不需要参数的事件
    /// </summary>
    /// <param name="name">事件的名字</param>
    /// <param name="action">对应之前添加的委托函数</param>
    public void RemoveEventListener(string name, UnityAction action)
    {
        if (eventDic.ContainsKey(name))
            (eventDic[name]).actions -= action;
    }

    /// <summary>
    /// 事件触发（不需要参数的）
    /// </summary>
    /// <param name="name">哪一个名字的事件触发了</param>
    public void EventTrigger(string name)
    {
        //有没有对应的事件监听
        //有的情况
        if (eventDic.ContainsKey(name))
        {
            if ((eventDic[name]).actions != null)
                (eventDic[name]).actions.Invoke();
        }
    }

    /// <summary>
    /// 清空事件中心
    /// 主要用在 场景切换时
    /// </summary>
    public void Clear()
    {
        eventDic.Clear();
    }
}
```

如果我们希望事件携带参数该怎么办呢？可以通过一个空接口结合里氏替换原则实现多态，改写如下：

```C#
using System.Collections.Generic;
using UnityEngine.Events;

//用空接口是因为要把他存到字典里，要用里式转换原则转成其他的T类型
public interface IEventInfo
{

}

public class EventInfo : IEventInfo
{
    public UnityAction actions;

    public EventInfo(UnityAction action)
    {
        actions += action;
    }
}

public class EventInfo<T> : IEventInfo
{
    public UnityAction<T> actions;

    public EventInfo( UnityAction<T> action)
    {
        actions += action;
    }
}

/// <summary>
/// 事件中心 单例模式对象
/// 1.Dictionary
/// 2.委托
/// 3.观察者设计模式
/// 4.泛型
/// </summary>
public class EventCenter : BaseManager<EventCenter>
{
    //key —— 事件的名字（比如：怪物死亡，玩家死亡，通关 等等）
    //value —— 对应的是 监听这个事件 对应的委托函数们
    private Dictionary<string, IEventInfo> eventDic = new Dictionary<string, IEventInfo>();

    /// <summary>
    /// 添加事件监听
    /// </summary>
    /// <param name="name">事件的名字</param>
    /// <param name="action">准备用来处理事件 的委托函数</param>
    public void AddEventListener<T>(string name, UnityAction<T> action)
    {
        //有没有对应的事件监听
        //有的情况
        if( eventDic.ContainsKey(name) )
        {
            (eventDic[name] as EventInfo<T>).actions += action;
        }
        //没有的情况
        else
        {
            eventDic.Add(name, new EventInfo<T>( action ));
        }
    }

    /// <summary>
    /// 移除对应的事件监听
    /// </summary>
    /// <param name="name">事件的名字</param>
    /// <param name="action">对应之前添加的委托函数</param>
    public void RemoveEventListener<T>(string name, UnityAction<T> action)                  //移除监听
    {
        if (eventDic.ContainsKey(name))
            (eventDic[name] as EventInfo<T>).actions -= action;
    }

    /// <summary>
    /// 事件触发
    /// </summary>
    /// <param name="name">哪一个名字的事件触发了</param>
    public void EventTrigger<T>(string name, T info)
    {
        //有没有对应的事件监听
        //有的情况
        if (eventDic.ContainsKey(name))
        {
            //eventDic[name]();
            if((eventDic[name] as EventInfo<T>).actions != null)
                (eventDic[name] as EventInfo<T>).actions.Invoke(info);
            //eventDic[name].Invoke(info);
        }
    }

    /// <summary>
    /// 清空事件中心
    /// 主要用在 场景切换时
    /// </summary>
    public void Clear()
    {
        eventDic.Clear();
    }
}
```

最后，需要强调的是在使用观察者模式时需要留意**内存泄漏**风险。我们需要确保所有添加的委托都能正确移除，特别是在**对象销毁**时，避免事件中心持有不再使用的对象造成内存泄漏。当对象仍被实践中心持有时它将不会被GC。
