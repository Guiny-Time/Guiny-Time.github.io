---
title: 排序算法
date: 2024-03-02 12:40:59
tags:
---

> 通俗易懂了解算法方面我强烈推荐油管主Michael Sambol

在不同领域，排序算法的实现各有千秋。总体来看，排序算法大致可分为十类：

- {% label 选泡插 red %}：选择排序/Selection Sort、冒泡排序/Bubble Sort、插入排序/Insertion Sort
- {% label 快归希堆 green %}：快速排序/Quick Sort、归并排序/Merge Sort、希尔排序/、堆排序/Heap Sort
- {% label 桶计基 blue %}：桶排序/Bucket、计数排序（LSD）、基数排序/MSD

在排序算法中，按照其特性，还有以下两种分类方式：

- **稳定stable/不稳定unstable**
A stable sorting algorithm is any sorting algorithm that preserves the relative ordering of items with equal values. 
> 一个稳定的排序算法是**保持具有相等值的项**的**相对顺序**的任何排序算法。通俗的说就是：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i] = r[j]，且 r[i] 在 r[j] 之前，而在排序后的序列中，r[i] 仍在 r[j] 之前，则称这种排序算法是稳定的；否则称为不稳定的。

- **就地in-place/不就地out-place**
An in-place algorithm is an algorithm which transforms input using no auxiliary data structure. 
> 就地算法是一种**不使用辅助数据结构**对输入进行转换的算法。

以上提及的几种算法中，除了heap sort（堆排序）以外都是基于比较的排序算法（？）。

# 时间复杂度为O(n^2)的排序算法
## 冒泡排序/bubble sort
- Stable/In-place
- 最优时间复杂度：O(n)，即已经排序好的情况下
- 最差时间复杂度：O(n^2)，即完全没排序的情况，或原始算法
- 空间复杂度：O(1)
<img src="https://img11.360buyimg.com/ddimg/jfs/t1/158015/1/42815/50715/65e2d284Fdf45dfbe/89a05babfa393505.jpg" width=500 title="图解冒泡排序" />

{% video CS210-1.mp4 %}
<br/>

{% tabs 冒泡排序的写法 %}
<!-- tab 一般来说的写法 -->
根据上面的视频，我们不难写出：
```Java
public static int[] bubbleSort(int[] arr){
    for(int i = arr.length - 1; i > 0; i--){      // 每次比较的上限
        for(int j = 0; j < arr.length - i; j++){  // 范围内进行两两比较
            if(arr[j] > arr[j + 1]){
                // 如果比后面的元素大，则交换.这里的交换是伪代码
                swap(arr[j], arr[j + 1])；
            } 
        }
    }
    return A;
}
```
改写一下for循环，使其统一为++的形式，则有：
```Java
public static void bubbleSort(int[] arr) {
    for (int i = 0; i < arr.length - 1; i++) {
        for (int j = 0; j < arr.length - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                // 如果左边的数大于右边的数，则交换，保证右边的数字最大
                swap(arr, j, j + 1);
            }
        }
    }
}
```
<!-- endtab -->

<!-- tab 经过优化的写法(交换确认) -->
使用一个变量**swaped**记录当前轮次的比较是否发生过交换，如果没有发生交换表示已经有序，不再继续排序。
```Java
public static void bubbleSort(int[] arr) {
    boolean swaped;
    for (int i = 0; i < arr.length - 1; i++) {
        swaped = false;
        for (int j = 0; j < arr.length - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                // 如果左边的数大于右边的数，则交换，保证右边的数字最大
                swaped = true;
                swap(arr, j, j + 1);
            }
        }
        // 如果这一轮遍历都没有发生过交换，直接退出循环
        if (!swapped) break;
    }
}
```
<!-- endtab -->

<!-- tab 更进一步优化的写法 -->
在前一种排序方法的基础上，我们还可以更进一步优化算法，即在下一轮比较时，只需比较到上一轮比较中，**最后一次发生交换的位置**即可。因为后面的所有元素都没有发生过交换，必然已经有序了。
当一轮比较中从头到尾都没有发生过交换，则表示整个列表已经有序，排序完成。
因此我们需要引入两个变量：**swaped** 和 **lastSwapIndex**。

```Java
public static void bubbleSort(int[] arr) {
    boolean swaped = true;
    // 最后一个没有经过排序的元素的下标
    int indexOfLastUnsortedElement = arr.length - 1;
    // 上次发生交换的位置
    int swappedIndex = -1;
    while (swapped) {
        swapped = false;
        for (int i = 0; i < indexOfLastUnsortedElement; i++) {
            if (arr[i] > arr[i + 1]) {
                // 如果左边的数大于右边的数，则交换，保证右边的数字最大
                swap(arr, i, i + 1);
                // 表示发生了交换
                swapped = true;
                // 更新交换的位置
                swappedIndex = i;
            }
        }
        // 最后一个没有经过排序的元素的下标就是最后一次发生交换的位置
        indexOfLastUnsortedElement = swappedIndex;
    }
}
```
<!-- endtab -->
{% endtabs %}


### 更高效的交换算法
{% tabs 冒泡排序的写法 %}
<!-- tab 初学者写法 -->
在前面的代码中，我并没有写出交换方法 **swap** 的具体实现。作为初学者，很容易写出以下方法：
```Java
public static void swap(int[] arr, int a, int b){
    int temp = arr[a];
    arr[a] = arr[b];
    arr[b] = temp;
}
```
<!-- endtab -->

<!-- tab 位运算魔法 -->
创建新变量temp无疑增大了空间复杂度，有没有不引入新变量又安全的方法呢？隆重推出：**位运算魔法**！
```Java
public static void swap(int[] arr, int a, int b){
    arr[a] = arr[a] ^ arr[b];
    arr[b] = arr[b] ^ arr[a];
    arr[a] = arr[a] ^ arr[b];
}
```
两个相同的值相与的时候，返回1；此时与任何元素相与都会得到元素本身。这种写法不会出现越界问题，较于数学方法更安全。
<!-- endtab -->

<!-- tab 数学方法 -->
```Java
public static void swap(int[] arr, int a, int b){
    arr[a] = arr[a] + arr[b];
    arr[b] = arr[a] - arr[b];
    arr[a] = arr[a] - arr[b];
}
```
<!-- endtab -->
{% endtabs %}

## 选择排序/selection sort
在未排序部分找到最小的数，放到未排序的首位
- Unsatble/In-place
- 时间复杂度：O(n^2)
- 空间复杂度：O(1)

<img src="https://img14.360buyimg.com/ddimg/jfs/t1/230674/34/14634/49156/65e2d43aF55757290/ecad4d4afdca897f.jpg" width=500 title="图解选择排序" />

{% video CS210-2.mp4 %}

<br>

选择排序中，最小值和首位交换的过程可能会破坏稳定性。比如数列：[2, 2, 1]，在选择排序中第一次进行交换时，原数列中的两个 2 的相对顺序就被改变了，因此，我们说选择排序是不稳定的。
算法稳定性的意义在于：当要排序的内容是一个对象的多个属性，且其原本的**顺序存在意义**时，如果我们需要在二次排序后**保持原有排序的意义**，就需要使用到稳定性的算法。

> **选择排序算法如何实现稳定排序呢？**
实现的方式有很多种，这里给出一种最简单的思路：新开一个数组，将每轮找出的最小值依次添加到新数组中，选择排序算法就变成稳定的了。
但如果将寻找最小值的比较条件由arr[minIndex] > arr[j]修改为arr[minIndex] >= arr[j]，即使新开一个数组，选择排序算法依旧是不稳定的。所以分析算法的稳定性时，需要结合具体的实现逻辑才能得出结论，我们通常所说的算法稳定性是基于一般实现而言的。

{% tabs 选择排序的写法 %}
<!-- tab 一般来说的写法 -->
```Java
public static void selectionSort(int[] array) {
    int min;
    for (int outer = 0; outer < array.length; outer++) {//未排序的部分
        min = outer;//要检查的槽位 
        for (int i = outer + 1; i < array.length; i++) {//内循环，遍历未排序的部分
            if (array[i] < array[min]) { 
                min = i; //找到最小值
            }
        } 
        // 将最小元素交换至首位
        swap(outer, min);
    }
}
```
<!-- endtab -->

<!-- tab 经过优化的写法(二元选择) -->
选择排序算法也是可以优化的，既然每轮遍历时找出了**最小值**，何不把**最大值**也顺便找出来呢？这就是二元选择排序的思想。
使用二元选择排序，每轮选择时记录最小值和最大值，可以把数组需要遍历的范围**缩小一倍**。
```Java
public static void selectionSort2(int[] arr) {
    int minIndex, maxIndex;
    // i 只需要遍历一半
    for (int i = 0; i < arr.length / 2; i++) {
        minIndex = i;
        maxIndex = i;
        for (int j = i + 1; j < arr.length - i; j++) {
            if (arr[minIndex] > arr[j]) {
                // 记录最小值的下标
                minIndex = j;
            }
            if (arr[maxIndex] < arr[j]) {
                // 记录最大值的下标
                maxIndex = j;
            }
        }
        // 如果 minIndex 和 maxIndex 都相等，那么他们必定都等于 i，且后面的所有数字都与 arr[i] 相等，此时已经排序完成
        if (minIndex == maxIndex) break;

        // 将最小元素交换至首位
        swap(i, minIndex);

        // 如果最大值的下标刚好是 i，由于 arr[i] 和 arr[minIndex] 已经交换了，所以这里要更新 maxIndex 的值。
        if (maxIndex == i) maxIndex = minIndex;

        // 将最大元素交换至末尾
        int lastIndex = arr.length - 1 - i;
        swap(lastIndex, maxIndex);                                                 
    }
}
```
<!-- endtab -->
{% endtabs %}


## 插入排序/insertion sort
- Stable/In-place

<img src="https://img14.360buyimg.com/ddimg/jfs/t1/182518/29/36021/31240/65e2d459F2dc463b5/57b367697ae574f0.jpg" width=500 title="图解插入排序" />

{% video CS210-3.mp4 %}

```Java
public static void insertionSort(int[] array) { 
    int temp = 0;
    for (int outer = 1; outer < array.length; outer++) {		//O（n）
        // outer是下一个要被sorting的元素，默认第一个已经sort好了
        int inner = outer; // inner是用来判断交换的
        while (inner > 0 && array[inner - 1] >= array[inner]) { 	//O（n）
            temp = array[inner-1];
            array[inner - 1] = array[inner];
            array[inner] = temp;
            inner--; 
        } 
    } 
} 
```

## quick sort
- 时间复杂度：O(nlogn)
- Unsatble/Out-place

{% video CS210-4.mp4 %}

```Java
public static int[] qsort(int arr[],int start,int end) {        //start和end指的是要排序的部分
    int pivot = arr[start];      	  //取第一个作为pivot
    int i = start;        			//数组头
    int j = end;        			//数组尾
    while (i < j) {            
        while ((i < j)&&(arr[j] > pivot)) {                
            j--;            
       	}            
        while ((i < j)&&(arr[i] < pivot)) {                
            i++;            
       	}            
        if ((arr[i]==arr[j]) && (i < j)) {                
            i++;            
      	} else {                
          	Swap（arr[i], arr[j]）;     
       	}        
    }

    if (i-1>start) 
        arr = qsort(arr,start,i-1);        //递归的部分
    if (j+1<end)
        arr = qsort(arr,j+1,end);

    return (arr);
}    
```

## heap sort
- Unstable/In-place
- O(lgn)

{% video CS210-6.mp4 %}

## merge sort
- O(nlgn)
- Stable/Out-place

{% video CS210-5.mp4 %}
会画图已经ok了，老师说不考代码
关于递归实现merge的思路见[第九章](@note/9：第九章.md) 

